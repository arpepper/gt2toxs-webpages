#!/usr/bin/perl -w

#
# gt4garage [show=<options>] logname [simday]
#
# gt4garage produces a garage listing for optional given simday
#   But see also show=
#
# Audits:
#   Crudely checks the real "date lines"
#   lists resultant garage entries (obtained via buy,win,sell)
#                              win was implied in "old-style" event entries
#       shows "prize origin" of garage entries
#       verifies car counts given in status lines
#   day counter
#   license test medals (G/S/B)  (requires interpreting license lines)
#   car selection for events (a biggie for catching mistakes caused by copying)
#   Events must match definitions listed, usually in included gtN-racedefs
#       (which then become prize indicators via "next" and "win")
#   Verifies that "buy parts" and "mod car" have balanced items and Cr entries.
#
# Also:
#   "show=carlog" (optional "show=verbose,carlog")
#     produces output listed for each recognized car
#   "show=licen[sc]e" tracks license progress
#   "show=rawevents"
#   "show=events"
#   "show=prizes"
#       dump stored tables of event/prizes; seem redundant
#   "show=sold" "show=sell" "show=sales" "show=buy"
#     somewhat haphazardly attempt to track those car transactions
#         E.g. "show=sold,sell,sales,buy"
#   "show=origin" shows origins based on carid table (i.e. shows creating line)
#   "show=carids" dumps internal table of carids; useful when you need them
#
#   "show=rawparts" dumps processed version of all "buy parts" and "mod" lines
#   "show=mods" really debugging; shows extracted power and weight mod notes
#   "show=carprices" dumps carprices table (also "show=prices")
#   "show=carparts" dumps carparts table (also "show=parts")
#   "show=carpartstotals" gives per-car parts cost (also "show=partstotals")
#
#   "show=warn" tries to add extra warnings
#   "show=pragmas"  FWIW - some "pragma" evaluation will in future
#                              be replaced by use of "setvar"
#   "show=garage" is the default
#
# Now also:
#   setvar variable = value
#      - just numbers for now?
#   Primarily to allow "gt4garage ARRI-game2" to work
#       setvar minlicenseinc = 0
#       setvar maxlicenseinc = 1
#
# Future possibilities (getting few)
#   Credit sanity (increased or decreased as appropriate).
#   Percentage sanity; should never decrease.
#   A: and B:  should only ever increase, but they are gt4-specific
#   Parts availability for particular cars?  (Would seem to be difficult)
#   Prize legitimacy could conceivably be defined in gtN-racedefs
#   Prize origin should be indicated for a "carlog" entry.
#
#   It would be nice, but likely not possible, to arrange that
#     gt1 and gt2 logs could be processed too, with suitable gtN-racedefs
#   define recognized cars before win/buy ?  (working towards gt1/gt2)
#  
#


require 5.002;
use strict;

sub
warn {
	print @_;
}

%main::var = ();	# variables to set along with racedefs
$main::var{'minlicenseinc'} = 1;
$main::var{'maxlicenseinc'} = 1;
$main::var{'minseriesinc'} = 1;
$main::var{'maxseriesinc'} = 1;
$main::var{'allowanyprize'} = 0;

$main::done = 0;
$main::enddate = "";
$main::mintoday = 0;
$main::maxtoday = 1;
$main::selected = "";
$main::pragmas = ",";

@main::cardata = ();   # now we initialize all data via "buy" or "win" in log
@main::prizes = ();
@main::events = ();
$main::prize_event = ""; # pending event from "next", for "win"

%main::league = ();
%main::series = ();
%main::serieslen = ();
$main::maxserieslen = 6;
%main::track = ();

%main::carlist = ();  # now carlist is just an error suppressor
%main::origin = ();  # map carid to line which created it
%main::carid = ();  # map usual shortform to a carid (can conflict?)
$main::ncarsnow = 0;  # set to count when changes

# Discovered following defined only by use
%main::carids = ();  # see findcarid
%main::carnames = ();
%main::cardefs = ();  # special names created via "cardef" command
%main::carstates = ();
%main::carlist = (); # shortforms
%main::carprices = ();

%main::carmodels = ();  # Devoid of colour, price, etc

#
# proposed new scheme would just mark things as sold, not shuffle arrays
#
#@main::newgarage = ();
#@main::desc = ();
#@main::parts = ();
#@main::fitted = ();
#@main::sold = ();
#$main::lastid = 0;
#%main::aliases = ();     # returns "carid", index into above arrays

		
my($name);
while (@main::cardata) {
# This (i.e. cardata) is empty for later games
	$name = shift @main::cardata;
	$main::carlist{$name} = $name;
};

sub
lidsub() {  # sort license test names B1..A1..IB1..IA1..S1..S16
	my($n1, $n2, );

	$n1 = $a;
	$n1 =~ s/^\D+//;
	$n1 =~ s/\n//g;
	$n1 = 0 if ($n1 eq "");  # ?  probably got coffee results?
	$n1 += 0;
	$n1 += 100 if ($a =~ /B/);   # Allow for C or IC licenses
	$n1 += 200 if ($a =~ /A/);
	$n1 += 1000 if ($a =~ /I/);
	$n1 += 10000 if ($a =~ /S/);

	$n2 = $b;
	$n2 =~ s/^\D+//;
	$n2 =~ s/\n//g;
	$n2 = 0 if ($n2 eq "");  # ?
	$n2 += 0;
	$n2 += 100 if ($b =~ /B/);   # Allow for C or IC licenses
	$n2 += 200 if ($b =~ /A/);
	$n2 += 1000 if ($b =~ /I/);
	$n2 += 10000 if ($b =~ /S/);

	return $n1 <=> $n2;
}

sub
caridcolonsub() { # Compare  car123:T-R2  car234-2:T-R5
	my($n1,$m1, $n2, $m2);
	my($suf1, $suf2);

	$suf1 = $a;
	if ($suf1 =~ /:/ ) {
		$suf1 =~ s/^[^:]*://;
	}
	else {
		$suf1 = "";
	}
	$n1 = $a;
	$n1 =~ s/:.*//;
	$n1 =~ s/^car//;
	$n1 =~ s/ .*$//;  # allow more on the line
	$m1 = $a;
	$m1 =~ s/:.*//;
	$m1 =~ s/ .*$//;  # allow more on the line
	if ($m1 !~ /-/) {
		$m1 = 1;
	}
	else {
		$m1 =~ s/.*-//;
		$n1 =~ s/-.*//;
	}

	$suf2 = $b;
	if ($suf2 =~ /:/ ) {
		$suf2 =~ s/^[^:]*://;
	}
	else {
		$suf2 = "";
	}
	$n2 = $b;
	$n2 =~ s/:.*//;
	$n2 =~ s/^car//;
	$n2 =~ s/ .*$//;  # allow more on the line
	$m2 = $b;
	$m2 =~ s/:.*//;
	$m2 =~ s/ .*$//;  # allow more on the line
	if ($m2 !~ /-/) {
		$m2 = 1;
	}
	else {
		$m2 =~ s/.*-//;
		$n2 =~ s/-.*//;
	}
	if ( $n1 == $n2 ) {
		if ( $m1 == $m2 ) {
			return $suf1 cmp $suf2;
		}
		return $m1 <=> $m2;
	}
	else {
		return $n1 <=> $n2;
	}
}

sub
caridsub() {  # sort carid1, carid10-2, carid100 ...
	my($n1,$m1, $n2, $m2);

	$n1 = $a;
	$n1 =~ s/^car//;
	$n1 =~ s/ .*$//;  # allow more on the line
	$m1 = $a;
	$m1 =~ s/ .*$//;  # allow more on the line
	if ($m1 !~ /-/) {
		$m1 = 1;
	}
	else {
		$m1 =~ s/.*-//;
		$n1 =~ s/-.*//;
	}

	$n2 = $b;
	$n2 =~ s/^car//;
	$n2 =~ s/ .*$//;  # allow more on the line
	$m2 = $b;
	$m2 =~ s/ .*$//;  # allow more on the line
	if ($m2 !~ /-/) {
		$m2 = 1;
	}
	else {
		$m2 =~ s/.*-//;
		$n2 =~ s/-.*//;
	}
	if ( $n1 == $n2 ) {
		return $m1 <=> $m2;
	}
	else {
		return $n1 <=> $n2;
	}
}
	
#
# checkcar - just check car matches selection
#
sub
checkcar {
	my($car,$line) = @_;

	if ($main::selected eq "") {
		return 1 if (findcarid($car,$line));
		return 0;
	}
	return 1 if ($car eq $main::selected);
	&warn("Not using selection ${main::selected}: $line\n");
	return 0;
}

$main::lastcarday = -1;
$main::cardaycount = 1;
sub
gencarid { # every cars unequivocable ID is carNNN-N where NNN is gameday
	my($string);

	if ($main::mintoday != $main::lastcarday) {
		$main::cardaycount = 0;
	}
	$main::lastcarday = $main::mintoday;
	++$main::cardaycount;
	$string = "car$main::lastcarday";
	if ($main::cardaycount != 1) {
		$string = $string . "-" . "$main::cardaycount";
	}
	$string;
}

sub
getcarprice {
	my($id,$line) = @_;
	my($price);

	$price = "Cr0";
	if ($line =~ m/\(Cr[0-9][0-9,]*/ ) {
		$line =~ s/,([^0-9])/, $1/;
		while ($line =~ m/Cr[0-9][0-9]*,/ ) {
			$line =~ s/(Cr[0-9][0-9]*),/$1/;
		}
		if ( $line =~ m/\((Cr[0-9][0-9]*)/ ) {
			$price = $1;
		}
	}
	$price;
}

sub
carsnow {  # expensive count of cars today
# try to call this only when we expect it to have changed
# $main::ncarsnow = carsnow();
	my($k,$i);
	$i = 0;
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold") {
			#printf("%3d %s\n", $i+1, $main::carnames{$k});
			++$i;
		}
	}
	$i;
}

sub
getcar {
	my($shortform,$fullname,$line) = @_;
	my($newid);

	$newid = &gencarid();
	$main::carids{$newid} = $shortform;  # actually see findcarid
	$main::carnames{$newid} = $fullname;
	$main::carstates{$newid} = "got";   # s.b. "won" or "new" or "used"?
	$main::carlist{$shortform} = $shortform;
	$main::origin{$newid} = $line;
	$main::carprices{$newid} = getcarprice($newid,$line);
	$main::carid{$shortform} = $newid;  # stupid names carids vs carid
	$main::ncarsnow = carsnow();   # expensive?
	my($model) = ($fullname);
	if ($model =~ /['][0-9][0-9]\b/) {
		$model =~ s/(['][0-9][0-9]\b).*$/$1/;
	}
	else {
		while ($model =~ /[(].*[)]\s*$/) {
			# (prize)  (dup) (Cr10.000,new)  (colour)
			if ( $model =~ /[)]\s*[)]\s*$/ ) {
				# (Malachit (green))
				$model =~ s/\s*[(][^)]*[)]\s*[)]\s*$/)/;
			}
			$model =~ s/\s*[(][^()]*[)]\s*$//;
		}
	}
	$main::carmodels{$newid} = $model;
		
}

sub
carvariants {
	my($car) = @_;

	# Hope matching works; only count prizes
	my($i,$count);
	my($car1,$car2);
	my(%hash,@list);

	$count = 0;
	$car1 = $car;
	$car1 =~ s/es$//;
	$car2 = $car1;
	$car1 =~ s/s$//;
	@list = (reverse sort caridsub keys %main::carids);
	foreach $i (@list) {
		if ($main::carstates{$i} ne "sold" &&
				$main::carnames{$i} =~ /\(prize/ ) {
#printf("Maybe got %s /$car/\n", $main::carnames{$i});
			#  this is a little atrocious
			if ( $main::carnames{$i} =~ /$car/i ||
					$main::carnames{$i} =~ /$car1/i ||
					$main::carnames{$i} =~ /$car2/i ) {
#printf("Got %s\n", $main::carnames{$i});
				$hash{$main::carnames{$i}} = 1;
			}
		}
	}
	@list = keys %hash;
	undef(%hash);
	return @list;

}

sub
carcount {
	my($car,$exact) = @_;

	# Hope matching works; only count prizes
	my($i,$count);
	my($car1,$car2);
	my(@list);

	$count = 0;
	if ($exact) {
		# suitable for results of carvariants
		#  avoids blueSilEighty matching dkBlueSileighty -- sheesh
		@list = (reverse sort caridsub keys %main::carids);
		foreach $i (@list) {
			if ($main::carstates{$i} ne "sold" &&
				$main::carnames{$i} eq $car ) {
				++$count;
			}
		}
	}
	else {
		$car =~ s/[()]/\\$&/g;
		$car1 = $car;
		$car1 =~ s/es$//;
		$car2 = $car1;
		$car1 =~ s/s$//;
		@list = (reverse sort caridsub keys %main::carids);
		foreach $i (@list) {
			if ($main::carstates{$i} ne "sold" &&
				$main::carnames{$i} =~ /\(prize/ ) {
				#  this is a little atrocious
				if ( $main::carnames{$i} =~ /$car/i ||
					$main::carnames{$i} =~ /$car1/i ||
					$main::carnames{$i} =~ /$car2/i ) {
					++$count;
				}
			}
		}
	}
#print "carcount:$count $car\n";
	return $count;

}

sub
sellcarid {
	my($carid,$match) = @_;
	my($what);

	if (!defined($main::carstates{$carid})) {
		&warn("Attempt to sell bad carid: $carid $match\n");
		return;
	}
	if ($main::carstates{$carid} eq "sold") {
		&warn("Carid already sold: $carid $match\n");
		return;
	}
	$what = $main::carnames{$carid};
	$match =~ s/\s*->.*$//;
	$match =~ s/$/.*/;
	if ($what !~ /$match/) {
		&warn("Carid $carid ($what) does not match /$match/\n");
		return;
	}
	$main::carstates{$carid} = "sold";
	if ($main::showlist =~ /,sold,/i ) {
		print "${main::maxtoday}:$carid ($what) sold!\n";
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
sellentry {
	my($num,$car) = @_;
	my($i,$k,$what,$temp);

	$i = 0;
	$what = "";
	$temp = "";
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold") {
			if (++$i == $num) {
				$temp = $main::carnames{$k};
				if ($temp =~ /$car/ ) {
					$what = $temp;
					$main::carstates{$k} = "sold";
					last;
				}
			}
		}
	}
	if ($what) {
		if ($main::showlist =~ /,sold,/i ) {
			print "${main::maxtoday}:$car ($what) sold!\n";
		}
	}
	else {
		print "${main::maxtoday}:Entry $num ($temp) doesn't match \/$car\/\n";
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
marksold {
	# I do not think we use this
	my($id) = @_;

	$main::carstates{$id} = "sold";   # I think that's all we need, now
}

sub
sellcar {
	my($car,$oldest) = @_;
	my($i,$what,$temp,$temp2);
	my($ix,@list);

	# if ($oldest) we want to remove oldest car, else most recent

	$car =~ s/^\s*//;
	$car =~ s/\s*$//;
	@list = (sort caridsub keys %main::carids);
	@list = reverse @list if not ($oldest);
	foreach $ix (@list) {
		$temp = $main::carnames{$ix};
		$temp =~ s/^\s*//;
		$temp =~ s/\s*$//;
		$temp2 = $temp;
		# (prize,B/Sunday) is now an unexpected suffix
		$temp2 =~ s/\s*\(prize[^\)]*\)\s*$//;
		if ( ($temp eq "$car" || $temp2 eq "$car")
			&& $main::carstates{$ix} ne "sold") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	foreach $ix (@list) {
		$temp = $main::carnames{$ix};
		# this is sort of dumb...
		# prize annotation should not be part of car name?
		$temp =~ s/\(prize.*\)$//;
		if ($temp eq "$car" && $main::carstates{$ix} ne "sold") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	foreach $ix (@list) {
		$temp = $main::carnames{$ix};
		if ($temp =~ /\(prize/ && $temp =~ /$car/i &&
				$main::carstates{$ix} ne "sold") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	while ($car =~ /es$/) {
		$car =~ s/es$//;
	}
	while ($car =~ /s$/) {
		$car =~ s/s$//;
	}
	foreach $ix (@list) {
		$temp = $main::carnames{$ix};
		if ($temp =~ /\(prize/ && $temp =~ /$car/i &&
				$main::carstates{$ix} ne "sold") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
#print "Could not find $car.\n";
	return "";
}

sub
sell {
	my($stuff) = @_;
	my(@count,@name);
	my(@variants);
	my($i,$n,$tname,$oldest,$sold,$var);
	
	$oldest = 0; #default always sell youngest
	@count = ();
	@name = ();

	
	if ($main::showlist =~ /,sell,/ ) {
		print "${main::maxtoday}:sell: $stuff\n";
	}
	$stuff =~ s/^\s*car //i;
	$oldest = $stuff =~ /^\s*oldest\b/i;
	$stuff =~ s/^\s*oldest\b//i;
	$stuff =~ s/^\s*//;
	$stuff =~ s/\s*->.*//;
	# Either need to make sellcar handle optional (prize,...)
	# Or repeat the attempt here
	# Actually problem is garage says "(prize" but sell line doesn't
	if ($sold = &sellcar($stuff, $oldest) ) {
		# literal sale, usually of purchased car...
		if ($main::showlist =~ /,sold,/i ) {
			print "${main::maxtoday}:$stuff ($sold) sold!\n";
		}
		return;
	}
	$stuff =~ s/\bCr[1-9][0-9,]*//g;
	$stuff =~ s/\s*$//;
	if ($stuff =~ /^entry\s+(\d+)\s+(.*)/ && defined($2)) {
#print "sell entry:$1 $2\n";
		&sellentry($1,$2);
		return;
	}
	if ($stuff =~ /^carid\s+([\-\w]+)\s+(.*)/ && defined($2)) {
#print "sell entry:$1 $2\n";
		&sellcarid($1,$2);
		return;
	}
	$stuff =~ s/\b[1-9][0-9]* {0,1}cars{0,1}//g;
	$stuff =~ s/\bday {0,1}[1-9][0-9]*//g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}day//g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}day//g;
	$stuff =~ s/\ba\b/1/gi;
	$stuff =~ s/\(\d+\)//g;
	$stuff =~ s/\band\b//gi;
	$stuff =~ s/\bold\b//gi;
	$stuff =~ s/\balso\b//gi;
	$stuff =~ s/\bmost\b//gi;
	$stuff =~ s/\brecent\b//gi;
	while ($stuff =~ /[\w\[\]\-]/ ) {
		$stuff =~ s/^[^\w\[\]\-]//;
#print "stuff:$stuff\n";
		if ($stuff =~ /^(\d+)/ && defined($1) ) {
#print "number:$1\n";
			push @count,$1;
			$stuff =~ s/^\d+//;
		}
		else {
			if ($stuff =~ /^excess */) {
				push @count,-1;
				$stuff =~ s/^excess *//;
			}
			else {
				push @count,1;
			}
		}
		$stuff =~ s/^[^\w\[\]\-]+//;
		if ($stuff =~ /^([\w'\/\[\]\-#.]+)/ && defined($1) ) {
			push @name,$1;
			$stuff =~ s/^[\w'\/\[\]\-#.]+//;
		}
		else {
			last;
		}
	}
	for ($i = 0; defined($name[$i]); ++$i) {
		if ($main::showlist =~ /,sales,/ ) {
			print "${main::maxtoday}:Sell $count[$i] $name[$i].\n";
		}
		$tname = $name[$i];
		$n = $count[$i];
		for ($n = $count[$i]; $n > 0; --$n) {
			if ($sold = &sellcar($tname, $oldest)) {
				if ($main::showlist =~ /,sold,/i ) {
					print "${main::maxtoday}:$tname ($sold) sold!\n";
				}
			}
			else {
				print "${main::maxtoday}:Could not sell $tname.\n";
				last;
			}
		}
		if ($n < 0) {
			$n = -$n;
			@variants = &carvariants($tname);
			foreach $var (@variants) {
#printf("Sell  - $n $var, (%d).\n", &carcount($var,1));
				while (&carcount($var,1) > $n) {
#print "Sell $var.\n";
					if ($sold = &sellcar($var, $oldest)) {
						if ($main::showlist =~ /,sold,/i ) {
							print "${main::maxtoday}:$var ($sold) sold!\n";
						}
					}
					else {
						print "${main::maxtoday}:Could not sell $var.\n";
						last;
					}
				}
			}
		}
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
daycheck {
	my($day) = @_;

	if ($day < $main::mintoday || $main::maxtoday < $day) {
		return 0;
	}
	return 1;
}

sub
dodateline {
	my($line) = @_;

	if ($line !~ /1999$/ && $line !~ /20[012][0-9]$/) {
		&warn("Bad date line: $_\n");
	}
	if ($main::enddate ne "") {
		$main::done = $line =~ /$main::enddate/i;
	}
	$main::lastdateline = $line."\n";
	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		# Problem is we really want this in the log not selected yet
		addcarlog($main::selected,$line);		
	}
}

sub
dopragma {
	my($line) = @_;
	my($what,$value,$league,$length);

	$line =~ /^\s*pragma\s+(\w+)/;
	$what = $1;

	if ($what =~ /^no/) {
		$what =~ s/^no//;
		$main::pragmas =~ s/,$what,/,/;
	}
	else {
		if ($main::pragmas !~ /,$what,/) {
			$main::pragmas .= "$what,";
		}
	}

}

sub
doselect{
	my($line,$rest,$r1,$r2) = @_;

	if ($rest =~ /^select\s*car\s+(\S+)/ && defined($1)) {
		if ($1 eq "none") {
# Wed Apr 14, 2021
# Empty selection turns off selection checking
# We never used this, so change it to be something which cannot match
			$main::selected = "no car selected";
# This will be useful to allow "verbose carlog" to include comments and status
			return;
		}
		if ( findcarid($1,$line) ) {
			$main::selected = $1;
			addcarlog($1,$line);		
			return;
		}
	}
	&warn("Bad select: $line\n");
}

sub
getgsb { # get Gold, Silver, Bronze (counts)
	my %h = @_;
	my ($i, @sorted, %m);

	%m = ();
	@sorted = sort lidsub keys %h;
	for ($i = 0; $i <= $#sorted; ++$i) {
		++$m{$h{$sorted[$i]}};  # create $m{"G"}, $m{"S"}, $m{"B"}
	}

	return %m;
}
	

%main::lresults = ();
sub
updatemedal {
	my($lid,$medal) = @_;
	my($oldr);

#printf "updatemedal %s %s\n", $lid, $medal;
	$medal = "F" if !defined($medal);
	return if ($medal eq "F");
	if (!defined($main::lresults{$lid})) {
		$main::lresults{$lid} = $medal;   # know $medal is not F
	}
	else {
		$oldr = $main::lresults{$lid};
		if ($medal eq "G") {
			$main::lresults{$lid} = $medal;
		}
		elsif ($medal eq "S") {
			$main::lresults{$lid} = $medal if ($oldr ne "G");
		}
		# $medal must be B, and $lresults is defined
	}
} 

sub
dolicenseline {
	my($line,$rest,$start,$end) = @_;
	my($diff);
	my($lid,$medal);

#&warn("Good license line: $line\n");
	if (!&daycheck($start) ) {
		&warn("Bad license start day(not ${main::maxtoday}): $_\n");
	}
	$diff = $end - $start;
	if ( $diff < 0 ) {
		&warn("Bad license end day: $_\n");
	}
	$main::mintoday = $end + $main::var{'minlicenseinc'};
	$main::maxtoday = $end + $main::var{'maxlicenseinc'};
	# Almost need completely different routine for GT3, but maybe not?
	return if $main::pragmas !~ /,gt4,/;

	$lid = $rest;   # Note, line includes the day number
	#$lid =~ s/\s*\d+\s+//;  # Remove day number
	$lid =~ s/^licen[^ ]*\s+//;   # Must be a license line
	$lid =~ s/^\s+//;
	$lid =~ s/\s+.*$//;
	$lid =~ s/\n//g;
	$lid =~ s/\(.*//;  # Allow a parenthetical (!) or something
	if ($lid =~ /coffee/) {
		; # handle coffee later
	}
	# Note Gran Turismo actually uses hyphens in test names, e.g. S-16
	elsif ($lid !~ /^[I]{0,1}[BAS][\-]{0,1}[\d]{1,2}$/ || $lid =~ /IS/) {
		&warn("Bad license line (result first?): $line\n");
	}
	else {
		$lid =~ s/[\-]//;  # allow B-1, but use B1 internally
		$medal = $rest;
		#$medal =~ s/\s*\d+\s+//;  # Remove day number
		$medal =~ s/^licen[^ ]*\s+//;
		$medal =~ s/^\s+//;
		$medal =~ s/^I{0,1}[BAS]\d+[\-]{0,1}(\([^ ]*){0,1}\s+//;  # Remove $lid; we allow IS!
		if ( $medal =~ /^([FBSG])\b/ ) {
			$medal = $1;
		}
		else {
# Probably we should just complain in this case
			# Comments between $lid and $medal
#print "S14 medal=$medal\n" if ($lid eq "S14");
			&warn("License medal not first: $line\n")
				if ($main::showlist =~ /,licen[sc]e,/ );
			$medal =~ s/^[A-Za-z]+\s+//;
			$medal =~ s/[A-Za-z]{3,}//g;   # Seattle
			$medal =~ s/^[^ ]+\@[^ ]+//;   # FordGT@Seattle
			$medal =~ s/\bI{0,1}[BAS]\d+\b//g;  # lid can fool us
#			$medal =~ s/\b[\-\+][\:\.\d]{3,100}[BSG]\b//g;  # ignore +0.001G
# For some reason \b prevented matches
			$medal =~ s/[\-\+][\:\.\d]{3,}[BSG]{0,1}//g;  # ignore +0.001G
#print "S14 medal=$medal\n" if ($lid eq "S14");
			if ($medal =~ /[0-9\s]([BSG])\b/) { # 1st medal letter
				$medal = $1;
			}
			else {
				$medal =~ /([BSG])\b/;
				$medal = $1;
			}
		}
#print "S14 medal=$medal\n" if ($lid eq "S14");
		$medal = "F" if !defined($medal);
		updatemedal($lid,$medal);
	}

}

sub
otherprize {
	my($prize) = @_;

	$prize =~ s/\s*\(.*//;
	$prize =~ s/^\s//;
	return 1 if ($prize eq "full");
	return 1 if ($prize eq "none");
	return 1 if ($prize eq "next");  # Hmm...
	return 1 if ($prize eq "1st");
	return 1 if ($prize =~ /^2nd/);
	return 1 if ($prize =~ /^3rd/);
	return 1 if ($prize =~ /^4th/);
	return 1 if ($prize =~ /^5th/);
	return 1 if ($prize =~ /^6th/);
	return 1 if ($prize =~ /^8-/);   #  8-(
	return 1 if ($prize =~ /\s8-/);   #  8-(
                              # but don't match Z28-30th
	#return 1 if ($prize =~ /credits/);
	return 0;
}

sub
event_length {
	my($event) = @_;

	if (defined($main::serieslen{$event})) {
		return $main::serieslen{$event};
	}
	return 0;
}

sub
check_event {
	my($event) = @_;
	my($league,$series,$track,$rest);

	return 0 if !defined($event);
	if ( $event =~ /([^\/]*)\/(.*)/ ) {
		($league,$series) = ($1,$2);
	}
	return 0 if !defined($league) || !defined($main::league{$league});
	return 0 if !defined($series);
	if ($series =~ /[\/]/) {
		$series =~ /([^\/]*)\/(.*)/;
		($series,$track) = ($1,$2);
		return 0 if !defined($main::series{"$league/$series"});
		return 0 if !defined($main::track{$track});
	}
	else {
		return 0 if !defined($main::series{"$league/$series"});
	}
	return 1;
}

sub
record_race_prize {
	my ($r,$s) = @_;  # race, prize
	my ($temp);

	return if ($s =~ /credits/ || &otherprize($s));
	$temp = $s;
	$temp =~ s/\s*\(sold\)\s*//;
	$temp =~ s/\s*\(dup\)\s*//;
	$temp =~ s/\s*$//;
	# Perhaps one of these should record some of the above?
	# Currently they are same info; presumably want to derive from them
	push @main::prizes,"${r}: $temp";
	push @main::events,"${r}: $temp";
}

sub
doseriesline {
	my($line,$rest,$start,$end) = @_;
	my($diff);
	my($i,$none,$pat,$race,$event,$length,$suff,$prev,$after);
	my($car,$prize,$count,$status,$temp);

	if ($start eq "") {
		return;		# assume a harmless comment?
	}
	if (!&daycheck($start) ) {
		&warn("Bad start day(not ${main::maxtoday}): $_\n");
	}
	# there's sort of an assumption every event takes at least one day
	#  so daycounter actually becomes $end+1 i.e. $start+$diff+1
	$diff = $end - $start;
	if ( $diff < 0 || $main::maxserieslen < $diff) {
		&warn("Bad end day: $_\n");
	}
	$main::mintoday = $end + $main::var{'minseriesinc'};
	$main::maxtoday = $end + $main::var{'maxseriesinc'};
	$none = 1;
	if ($rest =~ /(\S+)\s+(\S+)\s+(.*)/ ) {
		($car,$event,$after) = ($1,$2,$3);
	}
	if ( !defined($event) ) {
		&warn("event not defined: $line\n");
		return;
	}
	if (&check_event($event) == 0) {
		&warn("Unrecognized event ($event): $line\n");
		$event = " ";
		return;
	}
	else {
		$length = &event_length($event);
		if ($diff != $length) {
			&warn("Bad end day for series \"$event\": $line\n");
		}
		$car =~ s/^\s*//;
		$car =~ s/[,\s].*//;
		checkcar($car,$line);
		addcarlog($car,$line);
		
	}
	$none = 0;
	if ( !defined($event) ) {
		&warn("event not defined: $line\n");
		return;
	}
	if ( $rest =~ m/(\S+.*\s+)(\S+[\/]${event})(\s.*)/ ) {
		$rest =~ /(\S+.*\s+)(\S+\/${event})(\s.*)/ ;
		($prev,$race,$after) = ($1,$2,$3);
	}
	else {
		$rest =~ /(\S+.*\s+)(${event})(\s.*)/ ;
		($prev,$race,$after) = ($1,$2,$3);
	}
	if ( !defined($after) ) {
		&warn("$rest has no after\n");
		return;
	}
	$status = "";
	$prize = $rest;
	$prize =~ s/red /red#/g;
	$prize =~ s/black /black#/g;
	$prize =~ s/ LM/#LM/g;
        $prize =~ s/^.* ([\w\[])/$1/;
        $prize =~ s/[!]//g;
	if ($prize =~ /([(].*)/ && defined($1)) {
		$status = $1;
		$prize =~ s/[(].*//;
	}
	if ($prize !~ /ConceptCar/ ) {
		$prize =~ s/Concept/ConceptCar/;
	}
	$prize =~ s/#/ /g;
	$prize =~ s/ *$//g;
#	if ( &otherprize($prize) == 0 &&
#			$main::raceprizes{$event} !~ /,${prize},/ ) {
#		&warn("Unrecognized prize ($prize) for $race: $line\n");
#	}
	if ($status =~ /([(][^)]*[)])(.*)/) {
		$count = $1;
		$status = $2;
		if ($status =~ /([(][^)]*[)])(.*)/) {
			$status = $1;
		}
	}
	if ($prize eq "next") {
		if (defined($main::prize_event) && $main::prize_event ne "") {
			 &warn("Next for $main::prize_event never claimed: $line\n");
		}
		$main::prize_event = $race;
	}
	record_race_prize($race,$prize);
	if ($status ne "(sold)" && $line !~ /[(]sold[)]/ ) {
		if ($prize !~ /credits/ && &otherprize($prize) == 0) {
			getcar($prize,"$prize(prize, $race)",$line);
		}
	}
}

sub
check_hash {
	my($old, $new) = @_;

	if (defined($old) && $old ne "") {
		&warn("Duplicate definition: $new\n");
	}
	return $new;
}


sub
docardef {
	my($line) = @_;
	my($what,$value,$carid);

	$line =~ /^\s*cardef\s+(\S+)\s+([\S]+)/;
	$what = $1;
	$value = $2;

	if (!defined($what) || !defined($value)) {
		&warn("Bad cardef: $line\n");
		return;
	}
	if (defined($main::cardefs{$what})) {
		&warn("Already defined: $line\n");
		return;
	}
	$carid = findcarid($value,$line);
	if (!$carid) {
		&warn("Bad carid: $line\n");
		return;
	}
	if ($main::carstates{$carid} eq "sold") {
		&warn("Already sold car: $line\n");
		return;
	}
	$main::cardefs{$what} = $carid;
}

sub
douncardef {
	my($line) = @_;
	my($what);

	$line =~ /^\s*uncardef\s+(\S+)/;
	$what = $1;

	if (!defined($main::cardefs{$what})) {
		&warn("No such cardef: $line");
		return;
	}
	delete($main::cardefs{$what});
 	# is following advisable?
	#if (defined($main::carlist{$what})) {
	#	delete($main::carlist{$what});
	#}
}

sub
dosetvar {
	my($line) = @_;
	my($what,$value,$carid);

	if ( !($line =~ /^\s*setvar\s+(\S+)\s*\=\s*([\S]+)/) ) {
		&warn("Bad setvar: $line\n");
		return;
	}
	$what = $1;
	$value = $2;
	# assert defined($what) && defined($value)

	$main::var{$what} = $value;
}

sub
findcarid { # given explicit cardef or carid, or unique shortform, return carid
	    # warn (first time) about unresolvable names
	my($carname,$line) = @_;
	my($k,$id);

	if (defined($main::carids{$carname})) {
		# We were given a carid; just return it (NOT carids{$carname})
		return $carname;
	}
# We have both %carids and %carid
	if (defined($main::carid{$carname})) {
		# quick map of short forms to carid
		return $main::carid{$carname};
	}
	if (defined($main::cardefs{$carname} )) {
		return $main::cardefs{$carname};
	}
	# Did not find via above; search all $carids{}
	$id = "";
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carids{$k} eq $carname &&
				$main::carstates{$k} ne "sold") {
			if ($id eq "") {
				$id = $k;
			}
			else {
				if ($line ne "") {
					# should we warn here?
				&warn("Ambiguous car ($carname): $line\n");
					# Use first if $line is not set
					return undef;
				}
			}
		}

	}
	if ( $id ne "" ) {
		return $id;
	}
	if (!defined($main::carlist{$carname})) {
		&warn("Unrecognized car ($carname): $line\n");
		# Reduce diagnostics by defining here
		$main::carlist{$carname} = $carname;
	}
	return undef;
}

sub
dodefine {
	my($line) = @_;
	my($what,$value,$league,$length);

	$line =~ /^\s*define\s+(\w+)\s+([\S]+)/;
	$what = $1;
	$value = $2;

	if ($what =~ /league/i) {
	   $main::league{$value} = &check_hash($main::league{$value}, $value);
	}
	elsif ($what =~ /series/i) {
	   $league = "";
	   if ($value !~ /^([^\s\/]+)\/([^\s\/]+)$/) {
		#Problems: A/S+S E/All-night
		&warn("Bad series name: $value\n");
	   }
	   else {
		   $league = $1;
	   }
	   if (!defined($main::league{$league})) {
		&warn("Undefined league in series name: $value\n");
	   }
	   $main::series{$value} = &check_hash($main::series{$value}, $value);
	   $length = 1;
	   if ( $line =~ /^\s*define\s+(\w+)\s+([\S]+)\s+(\d+)/ ) {
		$length = $3;
	   }
	   if ($length > $main::maxserieslen) {
		$main::maxserieslen = $length;
	   }
	   $main::serieslen{$value} = $length-1;
	}
	elsif ($what =~ /track/i) {
	   $main::track{$value} = &check_hash($main::track{$value}, $value);
	}
	else {
		&warn("Bad definition: $line");
	}
}


$main::fid = 'LOG0';
sub
doinclude {
	no strict 'refs';
	my($line) = @_;
	my($filename, $oldfid, $n);

	$line =~ /^\s*include\s+(\S+)/;
	$filename = $1;
	$oldfid = $main::fid;
	$n = $main::fid;
	$n =~ s/LOG//;
	++$n;
#print "$main::fid $n\n";
	$main::fid = 'LOG' . "$n";
	if (!open($main::fid,"<$filename") ) {
		&warn("Cannot open include \"$filename.\"\n");
		$main::fid = $oldfid;
	}
}

sub
dostatusline {
	my($line,$rest,$r1,$r2) = @_;
	#my($day,$stuff,$sf,$fullname);

	if (!&daycheck($r1) ) {
		&warn("Bad single day note(not ${main::maxtoday}): $line\n");
	}
	# Assert $rest =~ /^Cr[0-9]/
	# grr... seems difficult to undef $1 ...
	# If you need to, 'a' =~ /a/   will do it. I.e. a successful match.

	# Later check Ncars, medal counts perhaps license standing?

	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		addcarlog($main::selected,$line);		
	}
	if ( $main::pragmas =~ /,gt4,/ && $rest =~
	   m:([0-9]{1,2}[GB][ /]{1,3}[0-9]{1,2}[S][ /]{1,3}[0-9]{1,2}[GB]): ) {
		# Later perhaps license stats for GT3
		my $licstats = $1;
		my ($m, $s);
		my (%gsb);
		$s = "";
		%gsb = getgsb(%main::lresults);
		for $m ("G", "S", "B") {
			if (!defined($gsb{$m}) ) {
				$gsb{$m} = 0;
			}
			$s .= sprintf("%d%s ", $gsb{$m}, $m);
		}
		# Compare %gsb/$s with canonical version of $licstats
		my ($logresults) = ("");
		$licstats =~ /\b([0-9]+G)\b/;
		$logresults .= "$1 " if (defined($1));
		$licstats =~ /\b([0-9]+S)\b/;
		$logresults .= "$1 " if (defined($1));
		$licstats =~ /\b([0-9]+B)\b/;
		$logresults .= "$1 " if (defined($1));
		if ($main::showlist =~ /,licen[sc]e,/ ) {
			printf "%s %s %s - %s\n",
				$r1, $licstats, $logresults, $s;
		}
		if ( $logresults ne $s ) {
			&warn("$logresults ne $s: $line\n");
		}
	}
	if ( ( $main::showlist =~ /,warn,/i || $main::showlist !~ /,garage,/)
		 && $rest =~ m:\b([0-9]{1,4})[ ]{0,3}car[s]{0,1}\b:i ) {
		# commas?
		my ($logncars);
		$logncars = $1;
		if ($logncars != $main::ncarsnow) {
			&warn("Car count not ${main::ncarsnow}): $line\n");
		}
	}

	$main::mintoday = $r2;
	$main::maxtoday = $r2;
}


# $e = set_from_race($e);
sub
race_to_set {  # derive "set" (event) name from one of its races
	my($s) = @_;
# E,g, GT4   B/Sunday/AMii  => B/Sunday
#   But  SC/Normal/AmalfiR => SC/Normal/Amalfi

	# A prize is for the set, not the race
	# Perhaps this depends on pragma
	# Or perhaps we need "prizeevent" defns
	if ($s !~ m:/(Easy|Normal|Hard)/: ) { # ugh!
		while ($s =~ m:/.*/: ) {
			$s =~ s:/[^/]*$:: ;
		}
	}
	else {  # and ugh!
		$s =~ s/R$//;
		$s =~ s/ii$//;
	}
	return $s;
}

sub
dowin {   # Handle  150 +1 win car  RSC'02  Toyota RSC Rally Raid Car '02
# Note: also   59 +1 win car Nike   Nike One 2022 (prize,IBlicenseB)
	my($line,$rest,$r1,$r2) = @_;
	#my($day,$stuff,$sf,$fullname);
	my($stuff,$sf,$fullname);
	my($tstuff,$event);

	if ($rest !~ /^win\s+(.*)/ || !defined($1)) {
		return;
	}
	$stuff = $1;
#print "stuff:$stuff\n";
	if ($main::selected ne "") {
		addcarlog($main::selected,$line);
	}
	if ($stuff !~ /^\s*car\s+(\S+)/ || !defined($1) ) {
		if (!$main::var{'allowanyprize'} ) {
			&warn("Bad win: $line\n");
		}
		else {
			getcar($stuff,$stuff,$line);
			$main::prize_event = "";
		}
		return;
	}
	$event = "";
	$tstuff = $stuff;
	while ($tstuff =~ m:\s*\([^\)]*\)\s*$: ) {
#&warn("Eat parentheses: $line\n");
		if ($tstuff =~ m:(\(prize[^\)]*)\)\s*$: ) {
#&warn("Found prize: $line\n");
			$event = $1;
			$event =~ s/^\(prize,//;
			$event =~ s/\)\s*$//;
			last;
		}
# Good candidate for infinite loop here...
		$tstuff =~ s:\s*\([^\)]*\)\s*$:: ;
	}


	if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
#$main::prize_event = "";
# Problem: some prize car names include parentheses
		$sf = $1;
		if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
			$fullname = $2;
			$fullname =~ s/^[^\w\[]*//;
			$fullname =~ s/->\s.*//;
			$fullname =~ s/\s*$//;
			$fullname =~ s/^\s*//;
			if ($event ne "") {
				# Actually probably a non-race prize
				record_race_prize($event,$fullname);
			}
			elsif (defined($main::prize_event) && $main::prize_event ne "") {
				my ($e) = ($main::prize_event);
				# assert ($event eq "")
				$e = race_to_set($e);
				$fullname =~ s/$/ (prize,$e)/;
				# push event info here...
				record_race_prize($e,$fullname);
			}
			# Need a GOOD way for prize info to be passed
			getcar($sf,$fullname,$line);
			if ($main::showlist =~ /,buy,/i) {
				print "${main::maxtoday}:win $sf - $fullname.\n";
			}
		}
		else {
			# Need a way for prize info to be passed
			# I don't think we ever use this form?
			getcar($sf,$sf,$line);
		}
	}
	if ($event eq "") {
# Perhaps having $main::prize_event set for a win with event should be an error
		if (!defined($main::prize_event) || $main::prize_event eq "") {
			&warn("prize_event not set: $line\n");
		}
		$main::prize_event = "";
	}

}

sub
normalizeparts {
	my($car,$line) = @_;
	my($stuff, $dayno, $op);
	my ($tok);
	my ($mod);

# 208  mod car   CivicTypeR WR1 WR2 WR3  -805-780-755  Cr1000 Cr5000 Cr20,000
# 451  buy parts whiteCelica'70 (Tom's) Rmuff Cr4600 Rbr Bctlr  Cr4600 Cr10,300
# 451  mod car   whiteCelica'70   pol+bal  Cr5250  Cr11,000
# 451  mod car   whiteCelica'70   WR1 WR2 WR3 Cr1100 Cr5300 Cr21,000
	$stuff = $line;
	$stuff =~ s/\n//g;
	$stuff =~ s/^\s*//;  # Had had obscure bug ctrl\ instead of "^\"
	$stuff =~ s/^\s*$//;   # Can't hurt
	$dayno = $stuff;
	$dayno =~ s/\s+.*$//;
	$stuff =~ s/^\S+\s*//;
	$op = $stuff;
	if ($op =~ /^\+\d/) {
		# In GT4, this actually implies wheels
		$stuff =~ s/^\S+\s*//;
		$op = $stuff;
	}
	$op =~ s/\s.*$//;  #  s.b. "buy" or "mod"
			# Will later make into "parts" or "mod"
	$stuff =~ s/^\S+\s*//;
	$tok = "";
	for ( ; ; ) {
		last if ($stuff eq "");
		$tok = $stuff;
		$tok =~ s/\s+.*$//;
		$op = $tok if ($tok eq "parts");
		$stuff =~ s/^\S+\s*//;
		last if ($tok eq $car);
	}
	if ($tok ne $car) {
		# Perhaps this will be redundant noise given "select"
		&warn("Could not find $car: $line\n");
	}
	while ($stuff =~ /,\s*Cr/i ) {
		# Ensure prices are separated by spaces, not commas
		$stuff =~ s/,\s*Cr/ Cr/ig;
	}
	while ($stuff =~ /Cr\d+,\d/i ) {
		# Reomve optional commas from Cr10,000
		$stuff =~ s/(Cr\d+),(\d)/$1$2/;
	}
	while ($stuff =~ /Cr\d+[.]\d/i ) {
		&warn("Period instead of comma: $line\n");
		$stuff =~ s/(Cr\d+)[.](\d)/$1$2/;
	}
	# Now for things like
        # 117 mod car   Silvia'88K  WR1  Cr1000  ->1071kg
        # 120 buy parts Silvia'88K  Rmuff  ->257hp
        # 706  mod car  March  WR1 WR2 WR3 -805-780-755  Cr1000 Cr5000 Cr20,000
	# Appears we only did 805 -> 780 in comments
	# Recently we usually use only "-" with no spaces
	# We cannot safely remove spaces before "-".
	$stuff =~ s/(\d)to(\d)/$1-$2/g;  # probably should've just changed log
	my($p) = $stuff;
	$mod = "";
	while ( $stuff =~ m/(\d*-[\d\-\>]+(hp|kg){0,1})/ ) {
		$mod .= $1;
		$stuff =~ s/\d*-[\d\-\>]+(hp|kg){0,1}//;
		 # remove anything with digits and "->"
		# avoid T-S3 changing to TS3
	}
# Maybe later we can use such mod information somehow
	if ($main::showlist =~ /,mods,/ && $p ne $stuff) {
		print " B:",$p,"\n A:",$stuff,"\n";
		print " mod:$mod\n";
	}

	# Back in gt3-game1 I tended to put prices in parentheses
	#  But they do not seem semantically significant
	while ($stuff =~ /\((Cr\d+[^()]*)\)/ ) {
		#  72   buy parts Trueno SpSusp (Cr3,000)
		#  72   buy parts Trueno SpSusp (Cr3000)
		# Add space in case parenthesis was used as token separator
		$stuff =~ s/\((Cr\d+[^()]*)\)/ $1/;
		#  72   buy parts Trueno SpSusp  Cr3000
	}
	$stuff =~ s/\(\?\)//g;  # FWIW
	$stuff =~ s/,/ /g;  # Any remaining commas could be spaces
	$stuff =~ s/\+/ /g; # I use "pol+bal" a lot; also "cage+refresh"
	$stuff =~ s/\s+/ /g;   # Multiple spaces not semantically significant
	$stuff =~ s/\s*$//;  # just to be sure
	$stuff =~ s/^\s*//;  # just to be sure
	#  Note in GT3 you bought tire combinations e.g. T-R3/T-R3
  	#  66   buy parts Trueno T2/T2 (Cr10,000)

	#return ($op, $tok. $stuff);  # Sure I assigned funcs to arrays before
	return $op . " " . $tok . " " . $stuff;
}

sub
doparts {
	my($car,$line) = @_;


	my($buf);
	my($stuff, $op);
	my ($tok);

	#($op, $tok, $stuff) = normalizeparts($car,$line);
	$buf = normalizeparts($car,$line);
# A question becomes, what should be left after normalize ?
#  For now we leave anything left in parentheses, and also NNNkg and NNNhp
#	print "$buf\n"  if ($main::showlist =~ /,rawparts,/ );
	($op, $tok, $stuff) = split(/\s/,$buf,3);
# N.B. if you don't specify ",3" you get only the first solitted element
	print "$op $tok :$stuff\n"  if ($main::showlist =~ /,rawparts,/ );

# Mostly gt3-game1 use of parentheses...
# Old "alias" throwback
#   (alias [R]FalconXR8)
# Tuner names
#   (Trial)
#   (HKS)
#   (Mine's)
#   (Amuse)
#   (from Blitz)
# "Daily wheels"
#   (daily)
# Colours (for wings and wheels)
#   (silver)
#   (Black)
#   (black)
#   (yellow)
#   (red)
#   (red 4x2 spokes)
# Asides
#   (don't fit)
# Alternate GT3 tire designations
#   (SSl/SSl)
#   (M/M)
#
# Also brief attempt in gt4-game2 to track the "codenames"
# I will simply remove those, however.
# buy Cougar :Rtrans("FC") 3clu("TR") Cr10000 Cr4600

# So...
#  buy Crossfire :NA1 NA2 Cr4700 Cr12000 chip N2O Cr1250 Cr5000
#  becomes $parts{"Crossfire:NA1"} = "Cr4700";
#  becomes $parts{"Crossfire:NA2"} = "Cr12000";
#  becomes $parts{"Crossfire:chip"} = "Cr4700";
#  becomes $parts{"Crossfire:N2O"} = "Cr5000";
#
# Assume Cr0 applies to all everything before it, i.e.
# buy redSkyline'67 :T-N1 T-N2 T-N3 Cr0 T-S1 T-S3 Cr4100 Cr5600
# becomes $parts{"redSkyline'67:T-N1"} = "Cr0";
# becomes $parts{"redSkyline'67:T-N2"} = "Cr0";
# becomes $parts{"redSkyline'67:T-N3"} = "Cr0";
# becomes $parts{"redSkyline'67:T-S1"} = "Cr4100";
# becomes $parts{"redSkyline'67:T-S3"} = "Cr5600";
#
# Except we want to use   car2495 redSkyline'67 Nissan Skyline 2000GT-B ...
# So...  $parts{"car2495:T-N1"} = "Cr0";
# etc...
#
	my($id);
	my(@prices);
	my(@parts);
	my(@tokens);
	my($t,$p);

	@prices = ();
	@parts = ();
	$id = findcarid($tok);
	if (!defined($id)) {  # probably can't happen
		&warn("Cannot find carid for $tok, $line\n");
		return;
	}
	if ($stuff =~ /\bwheel/ || $stuff =~ /\bwing/ ) {
		# This test is very data dependent
		$t = "Cr0";
		if ( $stuff =~ /\b(Cr\d+)\b/ ) {
			$t = $1;
			$stuff =~ s/\bCr\d+\b//;
			$stuff =~ s/\s+/ /g;
		}
		$p = $id.":".$stuff;
		$main::carparts{$p} = $t;
		return;
	}
	$stuff =~ s/\s+\([^\)]*\)\s+/ /g;  # till we figure out how to process
	$stuff =~ s/\s+\([^\)]*\)/ /g;  # till we figure out how to process
	$stuff =~ s/\([^\)]*\)\s+/ /g;  # till we figure out how to process
	# Any remaining parentheses must be embedded in a "token"...
	$stuff =~ s/\([^\)]*\)//g;  # till we figure out how to process
	$stuff =~ s/\s+/ /g;
	$stuff =~ s/^\s+//g;  # sigh.  split will return empty tokens...
	$stuff =~ s/\s+$//g;
	@tokens = split(/\s+/,$stuff);
	for $t (@tokens) {
		if ($t =~ /^\d+hp$/i || $t =~ /\d+kg/i ||
			$t =~ /^\(/ || $t =~ /\)$/ ) {
			; # skip these "comments"
			# problem: we handle "(this comment)"
			#            but not "(this is a comment)"
			# Except that we removed them earlier...
		}
		elsif ($t eq "Cr0") {
			while (defined($p = shift(@parts)) ) {
				$p = $id.":".$p;
				$main::carparts{$p} = $t;
			}
		}
		elsif ($t =~ /^Cr\d/) {
			if (!defined($p = shift(@parts)) ) {
				&warn("No part for $t, $line\n");
			}
			else {
				$p = $id.":".$p;
				$main::carparts{$p} = $t;
			}
		}
		else {
			$t =~ s/\s*\(.*\)\s*//;
			push @parts, $t;
		}
	}
	while (defined($p = shift(@parts)) ) {
		$p = $id.":".$p;
		if ($main::showlist =~ /,carparts,/ ||
			  $main::showlist =~ /,warn,/ ) {
			&warn("No price for $p, $line\n");
			# currently a problem with "wheels" purchases
		}
		$main::carparts{$p} = "Cr0";
	}
}

sub
dodaynote {
	my($line,$rest,$r1,$r2) = @_;
	my($day,$stuff,$sf,$fullname);

	if (!&daycheck($r1) ) {
		&warn("Bad single day note(not ${main::maxtoday}): $_\n");
	}
	# grr... seems difficult to undef $1 ...
	if ($rest =~ /^buy\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "stuff:$stuff\n";
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
			$sf = $1;
			if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
				$fullname = $2;
				$fullname =~ s/^[^\w\[]*//;
				$fullname =~ s/->\s.*//;
				$fullname =~ s/\s*$//;
				$fullname =~ s/^\s*//;
				&getcar($sf,$fullname,$line);
				if ($main::showlist =~ /,buy,/i) {
					print "${main::maxtoday}:buy $sf - $fullname.\n";
				}
			}
			else {
				&getcar($sf,$sf,$line);
			}
		}
		elsif ($stuff =~ /^\s*parts\s+(\S+) /) {
			checkcar($1,$line);
			addcarlog($1,$line);
			doparts($1,$line);
		}
		elsif ($stuff =~ /^\s*wheels\s+/) {
			# In gt4, wheels are really a part
			;
		}
		else {
			&warn("Bad purchase: $line\n");
		}
	}
	if ($rest =~ /^win\s+(.*)/ && defined($1)) {
		dowin($line,$rest,$r1,$r2);
	}
	if ($rest =~ /^change\s+(.*)/ && defined($1)) {
		my ($stuff) = ($1);
		$stuff =~ s/^\s*oil\s*//;
		$stuff =~ s/^\s*car\s*//;
#print "stuff:$stuff\n";
# this was cheating; eventually identifier will be checked
		if ($stuff =~ /^(\S+)/ && defined($1) ) {
			checkcar($1,$line);
			addcarlog($1,$line);
		}
		else {
			&warn("Bad change: $line\n");
		}
	}
	if ($rest =~ /^mod\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "stuff:$stuff\n";
# this was cheating; eventually identifier will be checked
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
			checkcar($1,$line);
			addcarlog($1,$line);
			doparts($1,$line);
		}
		else {
			&warn("Bad mod: $line\n");
		}
	}
	if ($rest =~ /^sell\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "sell stuff:$stuff\n";
		&sell($stuff);
	}

	$main::mintoday = $r2;
	$main::maxtoday = $r2;
}

sub
donote {
	my($line) = @_;

	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		addcarlog($main::selected,$line);		
	}
}

sub
getlog {  # get lines, closing includes
	no strict 'refs';
	my($line) = @_;
	my($n);


	for (;;) {
		$line = <$main::fid>;
		if (!defined($line)) {
			close($main::fid);
			$n = $main::fid;
			$n =~ s/LOG//;
			if ( $n == 0 ) {
				return $line;
			}
			--$n;
			$main::fid = 'LOG' . "$n";
		}
		else {
			return $line;
		}
	}
}

my($log,$daylimit);

$main::lastdateline = "";
%main::carlogs = ();
sub
addcarlog {
	my($car,$line) = @_;

	if ($car eq "" || $car eq "no car selected") {
		return;
	}
	if (!defined($main::carlogs{$car})) {
		$main::carlogs{$car} = "";
		if ($main::showlist =~ /,verbose,/) {
			$main::carlogs{$car} = $main::lastdateline;
		}
	}
	if ($line !~ /^\s*$/) {
		$main::carlogs{$car} .= $line."\n";
	}
}
	

while ( defined($ARGV[0]) ) {
	my($temp);
	if ( $ARGV[0] =~ /^show=/i ) {
		$temp = $ARGV[0];
		$temp =~ s/^show=//i;	
		$temp = ",$temp,";
		$temp =~ s/,+/,/g;
		# Expand a few lazy alternatives we allow
		$temp =~ s/,partstotals,/,carpartstotals,/;
		$temp =~ s/,parts,/,carparts,/;
		$temp =~ s/,prices,/,carprices,/;
		# Would be nice to make plurals optional
		$main::showlist .= ",$temp,";
	}
	elsif (!defined($log)) {
		$log = $ARGV[0];
	}
	elsif (!defined($daylimit)) {
		if ($ARGV[0] =~ /^\d+$/) {
			$daylimit = $ARGV[0];
		}
		else {
			$temp = $ARGV[0];
			# change something like "Jan 10"
			#   into a pattern, like...
			# /^Jan[^0-9]*10/
			$temp =~ s/,/ /g;
			$temp =~ s/ +/[^0-9]*/;
			$temp =~ s/$/\\b/;
			$temp =~ s/^/^/;
			$main::enddate = $temp;
			
		}
	}
	shift @ARGV;
}
if (!defined($log)) {
	$log = "log";
}
if (!defined($daylimit)) {
	$daylimit = -1;
}
if (!defined($main::showlist)) {
	$main::showlist = ",garage,";
}
$main::showlist =~ s/all/pragmas,buy,sell,sales,sold,carids,garage,/;

{
	no strict 'refs';
	if (!open($main::fid,"<$log") ) {
		die "Cannot open log $log.\n";
	}
}


#while ($main::mintoday <= $daylimit && <LOG>) {
while (defined($_ = &getlog())) {
	my($line) = $_;
	my($license,$r1,$r2,$rest);

	last if ($main::done);
	last if ($daylimit > 0 && $main::mintoday > $daylimit);
	$line =~ s/\n//g;
	$license = $line;
	$license =~ s/^.{10}//;
	$license =~ s/(\S+)\s.*/$1/;
	$r1 = "";
	$r2 = "";
	$rest = $line;
	if ( $line =~ /^[A-Z]/) {
		;
	}
	elsif ( $line =~ /^ {9,9}/ ) {
		# line beginning with 9 spaces assumed to be comment
		;
	}
	elsif ( $line =~ /^([ \d]{3,3}\d)\-(\d[ \d]{3,3})(.*)/ ) {
		# day range (numbers max 4 digits)
		$r1 = $1;
		$r2 = $2;    # n.b. must grab all $N before doing other subs
		$rest = $3;
		$r1 =~ s/\s//g;
		$r2 =~ s/\s//g;
	}
	elsif ( $line =~ /^\s*(\d+)\s*\+(\d+)(.*)/ ) {
		# new range indication by +increment
		$r1 = $1;
		$r2 = $2;    # n.b. must grab all $N before doing other subs
		$rest = $3;
		$r2 += $r1;
	}
	elsif ( $line =~ /^\s*(\d+)\s+(.*)/ ) {
		# single day
		$r1 = $1;
		$rest = $2;
		$r2 = $r1;
	}
	$rest =~ s/^\s*//;

	if ( $line =~ /^\s*note/i ) {
		&donote($line);
	}
	elsif ( $line =~ /^\s*pragma/i ) {
		&dopragma($line);
	}
	elsif ( $line =~ /^\s*include/i ) {
		&doinclude($line);
	}
	elsif ( $line =~ /^\s*define/i ) {
		&dodefine($line);
	}
	elsif ( $line =~ /^[A-Z]/) {
		&dodateline($line);
	}
	elsif ( $line =~ /^\s*cardef/i ) {
		&docardef($line);
	}
	elsif ( $line =~ /^\s*uncardef/i ) {
		&douncardef($line);
	}
	elsif ( $line =~ /^\s*setvar/i ) {
		&dosetvar($line);
	}
	elsif ( $line =~ /^ {9,9}/ ) {
		# line beginning with 9 spaces assumed to be comment
		# ORLY?
		;
	}
	elsif ( $rest =~ /^Cr[0-9]/ ) {
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^power\b/ ) {
		$rest =~ s/^power\s*//;  # process stats on power off lines
		$rest =~ s/^off\s*//;
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^reset\b/ ) {
		$rest =~ s/^reset\s*//;  # process stats on reset lines
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^select\b/ ) {
		&doselect($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^buy\b/ ||
		$rest =~ /^change\b/ ||
		$rest =~ /^fit\b/ ||
		$rest =~ /^mod\b/ ||
		$rest =~ /^perm\b/ ||
		$rest =~ /^sell\b/ ||
		$rest =~ /^skip\b/ ||
		$rest =~ /^wash\b/ ||
		$rest =~ /^win\b/ ) {
		&dodaynote($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $rest =~ /^licen[sc]e/ ) {
		if ($line =~ /^\s*\d+\s+\+\d+/ ) {
			# for historical reasons, use $r2-1
			&dolicenseline($line,$rest,$r1,$r2-1);
			# at least until we reason it out
		}
		else {
			&dolicenseline($line,$rest,$r1,$r2);
		}
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\-\d+\s+/ ) {
		&doseriesline($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\s+\+\d+/ ) {
		# for historical reasons, use $r2-1
		&doseriesline($line,$rest,$r1,$r2-1);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\s+/ ) {
		&doseriesline($line,$rest,$r1,$r2);
	}
	elsif ( $line =~ /^\s{0,20}\d/ ) {
		&warn("Unrecognized line: $line\n");
	}
	else {
		# Surprisingly, lines beginning "#' will fall through to here
		&donote($line);
	}
}
close ($main::fid);

sub
expand {
	my($s) = @_;

	$s;
}

if ($main::showlist =~ /,pragmas,/ ) {
	printf("%s\n", $main::pragmas);
}
if ($main::showlist =~ /,rawevents,/ ) {
	my($i);
	for ($i = 0; $i <= $#main::events; ++$i) {
		printf("%s\n", &expand($main::events[$i]) );
	}
}
if ($main::showlist =~ /,events,/ ) {
	my($i,$prev,@sorted);
	@sorted = sort @main::events;
	$prev = "";
	for ($i = 0; $i <= $#sorted; ++$i) {
		if ($sorted[$i] ne $prev) {
			printf("%s\n", &expand($sorted[$i]) );
			$prev = $sorted[$i];
		}
	}
}
if ($main::showlist =~ /,prizes,/ ) {
	my($i,$prev,@sorted);
	@sorted = sort @main::prizes;
	$prev = "";
	for ($i = 0; $i <= $#sorted; ++$i) {
		if ($sorted[$i] ne $prev) {
			printf("%s\n", &expand($sorted[$i]) );
			$prev = $sorted[$i];
		}
	}
}
if ($main::showlist =~ /,carids,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carids) {
		printf("%s %s %s (%s)\n", $k, $main::carids{$k},
			$main::carnames{$k}, $main::carstates{$k});
	}
}
if ($main::showlist =~ /,prices,/ || $main::showlist =~ /,carprices,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carprices) {
		printf("%s %s %s\n", $k, $main::carids{$k},
			$main::carprices{$k});
	}
}

sub
tocredits {  # N.B. money, not attributions/accolades
	my ($num) = @_;
	my ($portion,$remain);
	my ($sign,$s);

	$sign = "";
	$remain = $num;
	if ($remain < 0) {
		$sign = "-";
		$remain = 0 - $remain;
	}
	$s = "";
	for ( ;; ) {
		$portion = $remain;
		$remain = int ( $remain / 1000);
		$portion -= $remain * 1000;
		if ($remain > 0) {
			$s = sprintf(",%3.3d", $portion) . $s;
		}
		else {
			$s = sprintf("Cr%d", $portion) . $s;
		}
		last if ($remain <= 0);
	}
	return $sign . $s;
}
sub
fromcredits {  # N.B. money, not attributions/accolades
	my ($s) = @_;
	my ($num);

	$s =~ s/^Cr//i;
	$s =~ s/,//g;
	$num = 0 + $s;
	return $num;
}
	
if ( $main::showlist =~ /,carparts,/ ||
		$main::showlist =~ /,carpartstotals,/ ) {
	my($k,$cark,$car);
	my($prevk,$total,$prevcar);
	$prevk = "";
	$prevcar = "";
	$total = 0;
	foreach $k (sort caridcolonsub keys %main::carparts) {
		$cark = $k;
		$cark =~ s/:.*//;
		$car = $main::carids{$cark};
		$car = "WHAT?" if (!defined($car));
		if ( $cark ne $prevk ) {
			if ($prevk ne "" &&
				   $main::showlist =~ /,carpartstotals,/ ) {
				printf("%s %s:Total %s\n", $prevcar, $prevk,
					&tocredits($total) );
			}
			$prevk = $cark;
			$prevcar = $car;
			$total = 0;
		}
		if ( $main::showlist =~ /,carparts,/ ) {
			printf("%s %s %s\n", $car, $k, $main::carparts{$k});
		}
		$total += &fromcredits($main::carparts{$k});
	}
	if ($prevk ne "" && $main::showlist =~ /,carpartstotals,/ ) {
		printf("%s %s:Total %s\n", $prevcar, $prevk,
			&tocredits($total) );
	}
	
}
if ($main::showlist =~ /,garage,/ ) {
	my($k,$i);
	$i = 0;
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold") {
			printf("%3d %s\n", $i+1, $main::carnames{$k});
			++$i;
		}
	}
}
if ($main::showlist =~ /,licen[sc]e,/ ) {
	my($i,@sorted);
	@sorted = sort lidsub keys %main::lresults;
	for ($i = 0; $i <= $#sorted; ++$i) {
		printf("%s: %s\n", $sorted[$i], $main::lresults{$sorted[$i]} );
	}

	
}
if ($main::showlist =~ /,origin,/ ) {
	# Shows origins based on carid
	my($i,@sorted);
	@sorted = sort caridsub keys %main::origin;
	for ($i = 0; $i <= $#sorted; ++$i) {
		printf("%s - %s\n", $sorted[$i], $main::origin{$sorted[$i]} );
	}
}
if ($main::showlist =~ /,models,/ ) {
	# Shows models based on carid
	my($i,@sorted);
	@sorted = sort caridsub keys %main::carmodels;
	for ($i = 0; $i <= $#sorted; ++$i) {
	      printf("%s - %s\n", $sorted[$i], $main::carmodels{$sorted[$i]} );
	}
}
if ($main::showlist =~ /,carlog,/ ) {
	my($i,@sorted);
	@sorted = sort keys %main::carlogs;
	for ($i = 0; $i <= $#sorted; ++$i) {
		my($sf,$ci,$org);
		$sf = $sorted[$i];
		#$ci = $main::carid{$sf};
		$ci = findcarid($sf,"");
		if (defined($ci) && defined($main::origin{$ci}) ) {
			$org = $main::origin{$ci}."\n";
		}
		else {
			$org = "";
		}
		printf("%s:\n", $sf );
		printf("%s", $org );
		printf("%s\n", $main::carlogs{$sorted[$i]} );
	}
}

