#!/usr/bin/perl -w

#
# gt4garage [show=<options>] logname [simday]
#
# gt4garage produces a garage listing for the given simday (default last day)
#   But see also show=
#
# By using suitable gt1-racedefs and gt2-racedefs (and for a long time
#   gt3-racedefs), gt1 and gt2 (and gt3) logs can be processed too.
#   A heuristic autoinclude means an explicit include is not required.
#   A new define of "fullprizename" allows some prize checking, and
#     "prettier" garage entries.
#   Various "setvar" values handle differences in game day counter behaviour
#     and also changes in logging style.
#   Logs for ARRI (Alfa Romeo Racing Italiano) can even be processed.
#     (Most garage entries in that case are actually clothing).
#
# Audits:
#   Crudely checks the real "date lines"
#   lists resultant garage entries (obtained via buy,win,sell)
#                              win was implied in "old-style" event entries
#       shows "prize origin" of garage entries
#       verifies car counts given in status lines
#   day counter
#   license test medals (G/S/B)  (requires interpreting license lines)
#   car selection for events (a biggie for catching mistakes caused by copying)
#   Events must match definitions listed, usually in included gtN-racedefs
#       (which then become prize indicators via "next" and "win")
#   Verifies that "buy parts" and "mod car" have balanced items and Cr entries.
#   Optionally:
#     show=audita - Aspec - should not decrease
#     show=auditb - Bspec - should not decrease
#     show=auditc - Credits (and debits); crude checks for expected plus/minus
#     All three are assigned to current car and shown by show=carlog
#   Immediately sold prizes on same line (pre-GT4) now get a carid
#        previously they were "unknown"
#        their carids will shift daycounter (old games buy used no days)
#             can assert such (other) carids were never used in practice
#
# Also:
#   "show=carlog" (optional "show=verbose,carlog")
#     produces output listed for each recognized car
#   "show=licen[sc]e" tracks license progress
#   "show=rawevent"
#   "show=event"
#   "show=prize"
#       dump stored tables of event/prizes; seem redundant
#   "show=sold" "show=sell" "show=sales" "show=buy"
#     somewhat haphazardly attempt to track those car transactions
#         E.g. "show=sold,sell,sale,buy"
#         Not so haphazard?
#         sell => show intended sell lines  e.g.  sell excess DB7 excess Demio
#         sales => show parsed portions of those lines  e.g. sell -1 DB7
#         sold => track actual transitions (sold!)
#   "show=origin" shows origins based on carid table (i.e. shows creating line)
#   "show=carid"  dumps internal table of carids; useful when you need them
#   "show=audit" does all three of the following
#       "show=audita" - Aspec
#       "show=auditb" - Bspec
#       "show=auditc" - Credits (and debits)
#
#   "show=trace"  debugging print of all lines, and partial walkthrough of many
#   "show=echo"   prints all input lines
#                     useful with "show=audit"
#   "show=heuristic"  debugging related to heuristic includes
#   "show=rawpart" dumps processed version of all "buy parts" and "mod" lines
#   "show=mod" really debugging; shows extracted power and weight mod notes
#   "show=carprice" dumps carprices table (also "show=prices")
#   "show=carpart" dumps carparts table (also "show=parts")
#   "show=carpartstotal" gives per-car parts cost (also "show=partstotals")
#
#   "show=var" dumps the "setvar" variable values (debugging)
#   "show=warn" tries to add extra warnings
#   "show=pragma"  FWIW - some "pragma" evaluation will in future
#                              be replaced by use of "setvar"
#
#   Note: "s" will be ignored on any option, so plurals are optional
#       E.g. pragmas, carparts, prizes, heuristics
#       But also: solds, sells, traces, warns, buys, verboses
#
#   "show=garage" is the default
#
# Now also:
#   setvar variable = value
#   Allow "gt4garage" to work on gt1, gt2 and ARRI logs
#       setvar minlicenseinc = 0
#       setvar maxlicenseinc = 1
#   Also enhanced to allow pattern definition
#       setvar seriesdelim = ""
#       setvar licensepatterns = "(((A|B|IA)(-){0,1}[1-8])|TT)"
#
# Future possibilities (getting few)
#   Validate, fix if necessary, autoinclude wrt nested includes
#   Credit sanity (increased or decreased as appropriate). (partially done)
#   Percentage sanity; should never decrease.
#   A: and B:  should only ever increase, but they are gt4-specific
#      Patterns could possibly be specified by setvar
#      Difficult for %
#   Parts availability for particular cars?  (Would seem to be difficult)
#   Prize legitimacy could conceivably be defined in gtN-racedefs
#   Prize origin should be indicated for a "carlog" entry.
#   carlog entries should be indexed by carid, not shortforms
#      Currently should be from %main::carlis; # shortforms
#   I.e. all of following should be changed from shortform to carid...
#                 %main::carlogs = ();
#                 %main::carcredits = ();
#                 %main::cardebits = ();
#                 %main::caraspecs = ();
#                 %main::carbspecs = ();
#                 %main::carbmachines = ();
#                 %main::carbcourses = ();
#                 %main::carbbattles = ();
#   Also
#                 sub bspecstring  should take carid
#   Note
#		  findcarid(carid,"")  # should return itself
#   Mystery
#        Can car0-56 "[R]KureR33 [R]KureR33 (alias)" be mapped to a true carid?
#        Looks like no; alias is too flexible (e.g. you cannot sell by alias)
#   Possibilities re: initial car purchase price
#     1) assign all purchases to "game"
#     2) instead assign to individual car
#          (assign as debit to carid, and decrease known credit tally)
#          But...
#             Either have lots of carlog entries with purchase/acquisition only
#             Or Credits to purchase unused cars
#                   will disappear from balance sheet
#   I had thought e.g. gt2-mfr would have had lots of failures
#      I had thought sold cars would not show up in final carlog.
#      But, in fact, they do.  They even get an origin which is even weirder.
#      A possibility is that the car raced is not the one sold, sort of.
# 
#      In fact, one thing to watch when switching to carigs is that THAT
#      does not cause similar problems (car being detected as no longer
#      existing).
#         But it should be possible to avoid that, and it might even be
#         possible and nice to log the "sold car" lines.
#         (Though for old logs like gt2-mfr, usually the sale won't be traced).
#


require 5.002;
use strict;

sub
warn {
	print @_;
}

%main::var = ();	# variables to set along with racedefs
$main::var{'includesdone'} = 0;   # allow us to do autoinclude

# This set arguably relates to the day counter behaviour for different games
$main::var{'minlicenseinc'} = 1;
$main::var{'maxlicenseinc'} = 1;
$main::var{'minseriesinc'} = 1;
$main::var{'maxseriesinc'} = 1;

$main::var{'maxunknownracedays'} = 0;  # set to 1 for GT1

# For show=audit
$main::var{'minprizecredits'} = 1;  # most games you get credits even for 6th
#$main::var{'maxprizecredits'} = 5000000;   # Eventually use this...


# This set allow flexibility in data
# But in some cases could be argued to reflect chosen log style
$main::var{'allowanyprize'} = 0;
$main::var{'seriesdelim'} = "/";    # If this is e.g. "(" bad things happen
$main::var{'trackdelim'} = "/";    # If this is e.g. "(" bad things happen

# The following set really just reflect changes in logging style
$main::var{'autocarids'} = 0;
$main::var{'autoselectcarids'} = 0;
# We would like to use 9 for the following, 
#   but we need smaller for some old GT1 and GT2 logs. 
$main::var{'commentspacecount'} = 4;  # was used in older logs; 9 for newer
# "noincserieslines = 1"  interprets lines with no increment as series lines
$main::var{'noincserieslines'} = 1;  # 0 for GT1 (had many single day notes)
# We want to process old GT1/2 logs where license was implied...
$main::var{'licensepatterns'} = "";  # kludgish for GT1/2 (add patterns)
$main::var{'seriescarcruft'} = "";  # kludge for GT1/2 (add patterns)
$main::var{'checkparts'} = 1;   # 0 for GT1, but could set in individual logs

$main::seriescarcruft = "";
@main::seriescarcrufts = ();

$main::done = 0;
$main::enddate = "";
$main::mintoday = 0;
$main::maxtoday = 1;
# Feb2022 - selected and mentioned should use carids; currently use shortform
$main::selected = "";    # track current car, explicitly set using "select"
$main::mentioned = "";   # allow carlog,verbose to work even if select not used
$main::selectedid = "";  # try doing carid in addition
$main::mentionedid = ""; #    ditto
$main::pragmas = ",";

@main::cardata = ();   # now we initialize all data via "buy" or "win" in log
@main::prizes = ();
@main::events = ();
$main::prize_event = ""; # pending event from "next", for "win"

%main::fullprizenames = ();   # Mostly to generate pretty GT1 garages

%main::league = ();
%main::series = ();
%main::seriesmindays = ();
%main::seriesmaxdays = ();
$main::maxserieslen = 6;
%main::track = ();

%main::carlist = ();  # now carlist is just an error suppressor
%main::origin = ();  # map carid to line which created it
%main::carid = ();  # map usual shortform to a carid (can conflict?)
$main::ncarsnow = 0;  # set to count when changes

# Discovered following defined only by use
%main::carids = ();  # see findcarid
%main::carnames = ();
%main::cardefs = ();  # special names created via "cardef" command
%main::carstates = ();
%main::carlist = (); # shortforms
%main::carprices = ();

%main::carmodels = ();  # Devoid of colour, price, etc

# Previously we put this further down, causing a re-allocation
$main::autocaridcount = 0;
#$main::cardefs{"game"} = "the default car";  # kludge to make game look like a car name
&newautocarid("game","");  # better kludge?
# N.B. gt1-mazda had used "none" to turn off selection checking entirely


#
# proposed new scheme would just mark things as sold, not shuffle arrays
#
#@main::newgarage = ();
#@main::desc = ();
#@main::parts = ();
#@main::fitted = ();
#@main::sold = ();
#$main::lastid = 0;
#%main::aliases = ();     # returns "carid", index into above arrays

sub
publish {
	my($car,$line) = @_;
#	my($id);

	print $line; 
	print "\n" if ($line !~ /\n/);	# sigh
	$line =~ s/\n//;      # sigh
	addcarlog($car,"",$line);
}

		
my($name);
while (@main::cardata) {
# This (i.e. cardata) is empty for later games
	$name = shift @main::cardata;
	$main::carlist{$name} = $name;
};

sub
lidsub() {  # sort license test names B1..A1..IB1..IA1..S1..S16
	my($n1, $n2, );

	$n1 = $a;
	$n1 =~ s/^\D+//;
	$n1 =~ s/\n//g;
	$n1 = 0 if ($n1 eq "");  # ?  probably got coffee results?
	$n1 += 0;
	$n1 += 100 if ($a =~ /B/);   # Allow for C or IC licenses
	$n1 += 200 if ($a =~ /A/);
	$n1 += 1000 if ($a =~ /I/);
	$n1 += 10000 if ($a =~ /S/);

	$n2 = $b;
	$n2 =~ s/^\D+//;
	$n2 =~ s/\n//g;
	$n2 = 0 if ($n2 eq "");  # ?
	$n2 += 0;
	$n2 += 100 if ($b =~ /B/);   # Allow for C or IC licenses
	$n2 += 200 if ($b =~ /A/);
	$n2 += 1000 if ($b =~ /I/);
	$n2 += 10000 if ($b =~ /S/);

	return $n1 <=> $n2;
}

sub
caridcolonsub() { # Compare  car123:T-R2  car234-2:T-R5
	my($n1,$m1, $n2, $m2);
	my($suf1, $suf2);

	$suf1 = $a;
	if ($suf1 =~ /:/ ) {
		$suf1 =~ s/^[^:]*://;
	}
	else {
		$suf1 = "";
	}
	$n1 = $a;
	$n1 =~ s/:.*//;
	$n1 =~ s/^car//;
	$n1 =~ s/ .*$//;  # allow more on the line
	$m1 = $a;
	$m1 =~ s/:.*//;
	$m1 =~ s/ .*$//;  # allow more on the line
	if ($m1 !~ /-/) {
		$m1 = 1;
	}
	else {
		$m1 =~ s/.*-//;
		$n1 =~ s/-.*//;
	}

	$suf2 = $b;
	if ($suf2 =~ /:/ ) {
		$suf2 =~ s/^[^:]*://;
	}
	else {
		$suf2 = "";
	}
	$n2 = $b;
	$n2 =~ s/:.*//;
	$n2 =~ s/^car//;
	$n2 =~ s/ .*$//;  # allow more on the line
	$m2 = $b;
	$m2 =~ s/:.*//;
	$m2 =~ s/ .*$//;  # allow more on the line
	if ($m2 !~ /-/) {
		$m2 = 1;
	}
	else {
		$m2 =~ s/.*-//;
		$n2 =~ s/-.*//;
	}
	if ( $n1 == $n2 ) {
		if ( $m1 == $m2 ) {
			return $suf1 cmp $suf2;
		}
		return $m1 <=> $m2;
	}
	else {
		return $n1 <=> $n2;
	}
}

sub
caridsub() {  # sort carid1, carid10-2, carid100 ...
	my($n1,$m1, $n2, $m2);

	$n1 = $a;
	$n1 =~ s/^car//;
	$n1 =~ s/ .*$//;  # allow more on the line
	$m1 = $a;
	$m1 =~ s/ .*$//;  # allow more on the line
	if ($m1 !~ /-/) {
		$m1 = 1;
	}
	else {
		$m1 =~ s/.*-//;
		$n1 =~ s/-.*//;
	}

	$n2 = $b;
	$n2 =~ s/^car//;
	$n2 =~ s/ .*$//;  # allow more on the line
	$m2 = $b;
	$m2 =~ s/ .*$//;  # allow more on the line
	if ($m2 !~ /-/) {
		$m2 = 1;
	}
	else {
		$m2 =~ s/.*-//;
		$n2 =~ s/-.*//;
	}
	if ( $n1 == $n2 ) {
		return $m1 <=> $m2;
	}
	else {
		return $n1 <=> $n2;
	}
}
	
#
# checkcar - just check car matches selection
#
sub
checkcar {
	my($car,$line) = @_;
	my($id);

	# Following probably happened when we
	#  called with $main::mentioned or $main::mentionedid ?
	return 1 if ($car eq "none");
	if ($main::selected eq "" || $main::selected eq "no car selected") {
		$id = findcarid($car,$line);
		if ($id) {
			$main::mentioned = $car;
			$main::mentionedid = $id;
			return 1;
		}
		return 0;
	}
	return 1 if ($car eq $main::selected);
	&warn("Not using selection ${main::selected}: $line\n");
	return 0;
}

$main::lastcarday = -1;
$main::cardaycount = 1;
sub
gencarid { # every cars unequivocable ID is carNNN-N where NNN is gameday
	my($string);

	if ($main::mintoday != $main::lastcarday) {
		$main::cardaycount = 0;
	}
	$main::lastcarday = $main::mintoday;
	++$main::cardaycount;
	$string = "car$main::lastcarday";
	if ($main::cardaycount != 1) {
		$string = $string . "-" . "$main::cardaycount";
	}
	$string;
}

sub
getcarprice {
	my($id,$line) = @_;
	my($price);

	#$price = "Cr0";
	$price = 0;
	if ($line =~ m/\(Cr[0-9][0-9,]*/ ) {
		$line =~ s/,([^0-9])/, $1/;
		while ($line =~ m/Cr[0-9][0-9]*,/ ) {
			$line =~ s/(Cr[0-9][0-9]*),/$1/;
		}
		if ( $line =~ m/\(Cr([0-9][0-9]*)/ ) {
			$price = $1;
		}
	}
	$price;
}

sub
carsnow {  # expensive count of cars today
# try to call this only when we expect it to have changed
# $main::ncarsnow = carsnow();
	my($k,$i);
	$i = 0;
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold" &&
			$main::carstates{$k} ne "alias" ) {
			#printf("%3d %s\n", $i+1, $main::carnames{$k});
			++$i;
		}
	}
	$i;
}

sub
getcar {
	my($shortform,$fullname,$line) = @_;
	my($newid,$price);

# shortform could be from old GT1, i.e. greenSilviaLM
# Should we lookup a fullname table here, or should caller?
#  102-103  [R]FCRX7         All-nightI   q1st1st       greenSilviaLM(1/2)

	$newid = &gencarid();
	$main::carids{$newid} = $shortform;  # actually see findcarid
	$main::carnames{$newid} = $fullname;
	$main::carstates{$newid} = "got";   # s.b. "won" or "new" or "used"?
	$main::carlist{$shortform} = $shortform;
	$main::origin{$newid} = $line;
	$price = getcarprice($newid,$line);
	$main::carprices{$newid} = "Cr" . $price;
	$main::carcredits{$newid} = 0;
	$main::cardebits{$newid} = $price;
	#$main::carcredits{$shortform} = 0;       # for now...
	#$main::cardebits{$shortform} = $price;   # for now...
	$main::knownaudit -= $price;  # Avoid charging price to current car
	if ( !defined($main::carid{$shortform}) ) {
		$main::carid{$shortform} = $newid;
		$main::cardebits{$shortform} = $price;
	}
	else {
		# Only replace carid for shortform if previous has been sold
		if (defined($main::carstates{$main::carid{$shortform}} ) ) {
			if ("sold" eq
				$main::carstates{$main::carid{$shortform}} ) {
				$main::carid{$shortform} = $newid;
				$main::cardebits{$shortform} = $price;
			}
		}
		# else quick map for shortform remains the old value
	}
	#$main::carid{$newid} = $newid;  # ?
	if (defined($main::carid{$newid}) ) {
		&warn("carid{$newid} already defined (should not happen): $line\n");
	}
	else {
		$main::carid{$newid} = $newid;  # facilitate carid reference
	}
	$main::ncarsnow = carsnow();   # expensive?
	my($model) = ($fullname);
	if ($model =~ /['][0-9][0-9]\b/) {
		$model =~ s/(['][0-9][0-9]\b).*$/$1/;
	}
	else {
		while ($model =~ /[(].*[)]\s*$/) {
			# (prize)  (dup) (Cr10.000,new)  (colour)
			if ( $model =~ /[)]\s*[)]\s*$/ ) {
				# (Malachit (green))
				$model =~ s/\s*[(][^)]*[)]\s*[)]\s*$/)/;
			}
			$model =~ s/\s*[(][^()]*[)]\s*$//;
		}
	}
	$main::carmodels{$newid} = $model;
	return $newid;
}

sub
carvariants {  # obtain variants of a token in a "sell" line
	# E.g.  sell DB7 => (redDB7, whiteDB7, purpleDB7)
	my($car) = @_;

# Somewhere along the line, carnames table became the verbose name
# Really we can say that "sell" (not "sell car") should take only shortforms
# Note the current peculiar case of "sell excess red.delSol"
# Basically, "sell" (not "sell car") is only intended to work with prizes

	# Hope matching works; only count prizes
	my($i,$count);
	my($car1,$car2);
	my(%hash,@list);

	$count = 0;
	$car1 = $car;
	$car1 =~ s/es$//;
	$car2 = $car1;
	$car1 =~ s/s$//;
	@list = (reverse sort caridsub keys %main::carids);
	foreach $i (@list) {
		if ($main::carstates{$i} ne "sold" &&
				$main::carnames{$i} =~ /\(prize/ ) {
# 2021/Jun/29 - removed match against carnames
#printf("Maybe got %s /$car/\n", $main::carnames{$i});
			#  this is a little atrocious
			if ( $main::carids{$i} =~ /$car/i ||
					$main::carids{$i} =~ /$car1/i ||
					$main::carids{$i} =~ /$car2/i ) {
#printf("Got %s\n", $main::carnames{$i});
####				$hash{$main::carnames{$i}} = 1;
				$hash{$main::carids{$i}} = 1;
			}
		}
	}
	@list = keys %hash;
	undef(%hash);
	return @list;

}

sub
carcount {
	my($car,$exact) = @_;

	# Hope matching works; only count prizes
	my($i,$count);
	my($car1,$car2);
	my(@list);

# Probably we want to do this only on carids, not carnames at all
	$count = 0;
	if ($exact) {
		# suitable for results of carvariants
		#  avoids blueSilEighty matching dkBlueSileighty -- sheesh
		# Probably here we should match carids table only...
		@list = (reverse sort caridsub keys %main::carids);
		foreach $i (@list) {
			if ($main::carstates{$i} ne "sold" &&
			    $main::carstates{$i} ne "alias" &&
				( $main::carids{$i} eq $car ||
				  $main::carnames{$i} eq $car ) ) {
				++$count;
			}
		}
	}
	else {
		$car =~ s/[()]/\\$&/g;
		$car1 = $car;
		$car1 =~ s/es$//;
		$car2 = $car1;
		$car1 =~ s/s$//;
		@list = (reverse sort caridsub keys %main::carids);
		foreach $i (@list) {
			if ($main::carstates{$i} ne "sold" &&
			    $main::carstates{$i} ne "alias" &&
				$main::carnames{$i} =~ /\(prize/ ) {
				#  this is a little atrocious
				if ( $main::carnames{$i} =~ /$car/i ||
					$main::carnames{$i} =~ /$car1/i ||
					$main::carnames{$i} =~ /$car2/i ||
					$main::carids{$i} =~ /$car/i ||
					$main::carids{$i} =~ /$car1/i ||
					$main::carids{$i} =~ /$car2/i ) {
					++$count;
				}
			}
		}
	}
#print "carcount:$count $car\n";
	return $count;

}

sub
sellcarid {
	my($carid,$match) = @_;
	my($what);

	$main::maxaudit = $main::MAXAUDIT;  # for now
	if (!defined($main::carstates{$carid})) {
		&warn("Attempt to sell bad carid: $carid $match\n");
		return;
	}
	if ($main::carstates{$carid} eq "sold") {
		&warn("Carid already sold: $carid $match\n");
		return;
	}
	if ($main::carstates{$carid} eq "alias") {
		# Could use $line
		&warn("Carid is alias: $carid $match\n");
		return;
	}
	$what = $main::carnames{$carid};
	$match =~ s/\s*->.*$//;
	$match =~ s/$/.*/;
	if ($what !~ /$match/) {
		&warn("Carid $carid ($what) does not match /$match/\n");
		return;
	}
	$main::carstates{$carid} = "sold";
	if ($main::showlist =~ /,sold,/i ) {
		print "${main::maxtoday}:$carid ($what) sold!\n";
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
sellentry {  # sell the given $num garage slot, if it matches $car
	my($num,$car) = @_;
	my($i,$k,$what,$temp,$temp2);

# This was from GT1, and actually seems to still work!
	$i = 0;
	$what = "";
	$temp = "";
	$temp2 = "";
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold" &&
		    $main::carstates{$k} ne "alias") {
			if (++$i == $num) {
				$temp = $main::carnames{$k};
				if ($temp =~ /$car/ ) {
					$what = $temp;
					$main::carstates{$k} = "sold";
					last;
				}
				$temp2 = $main::carids{$k};
				if ($temp2 =~ /$car/ ) {
					# Match temp2 but show the fullname
					$what = $temp;
					$main::carstates{$k} = "sold";
					last;
				}
			}
		}
	}
	if ($what) {
		if ($main::showlist =~ /,sold,/i ) {
			print "${main::maxtoday}:$car ($what) sold!\n";
		}
	}
	else {
		print "${main::maxtoday}:Entry $num ($temp) doesn't match \/$car\/\n";
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
marksold {
	# Began to use this when we began generating carids for sold prizes
	my($id) = @_;

	$main::carstates{$id} = "sold";   # I think that's all we need, now
	$main::ncarsnow = carsnow();   # expensive?
}

sub
sellcar {
	my($car,$oldest) = @_;
	my($i,$what,$temp,$temp2,$temp3,$temp4);
	my($ix,@list);

	# if ($oldest) we want to remove oldest car, else most recent

	$car =~ s/^\s*//;
	$car =~ s/\s*$//;
	@list = (sort caridsub keys %main::carids);
	@list = reverse @list if not ($oldest);
	foreach $ix (@list) {
		# Sell the first exact match of $car against fullname
		$temp = $main::carnames{$ix};
		$temp =~ s/^\s*//;
		$temp =~ s/\s*$//;
		$temp2 = $temp;
		# (prize,B/Sunday) is now an unexpected suffix
		$temp2 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		$temp3 = $main::carids{$ix};   # short form
		$temp4 = $temp3;
		$temp4 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		if ( ($temp eq "$car" || $temp2 eq "$car" ||
		      $temp3 eq "$car" || $temp4 eq "$car")
			&& $main::carstates{$ix} ne "sold" &&
			   $main::carstates{$ix} ne "alias") {
			$what = $temp;
			# Could use &sellcarid()
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	foreach $ix (@list) {
		# Sell the first exact match of $car against fullname
		$temp = $main::carnames{$ix};
		# this is sort of dumb...
		# prize annotation should not be part of car name?
		$temp =~ s/\(prize.*\)$//i;
		$temp4 = $main::carids{$ix};   # short form
		$temp4 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		if (  ($temp eq "$car" || $temp4 eq "$car")  &&
			   $main::carstates{$ix} ne "sold" &&
			   $main::carstates{$ix} ne "alias") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	foreach $ix (@list) {
		# Sell the first pattern match of $car against fullname
		# But ONLY if the car is a prize
		$temp = $main::carnames{$ix};
		$temp4 = $main::carids{$ix};   # short form
		$temp4 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		if ($temp =~ /\(prize/i &&   # ) for vi
			($temp =~ /$car/i || $temp4 =~ /$car/i) &&
				$main::carstates{$ix} ne "sold" &&
				$main::carstates{$ix} ne "alias") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	# Remove plurals and try for removing prizes again
	while ($car =~ /es$/) {
		$car =~ s/es$//;
	}
	while ($car =~ /s$/) {
		$car =~ s/s$//;
	}
	foreach $ix (@list) {
		# Sell the first pattern match of $car against fullname
		# But ONLY if the car is a prize
		$temp = $main::carnames{$ix};
		$temp4 = $main::carids{$ix};   # short form
		$temp4 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		if ($temp =~ /\(prize/i &&  # ) for vi
			($temp =~ /$car/i || $temp4 =~ /$car/i) &&
				$main::carstates{$ix} ne "sold" &&
				$main::carstates{$ix} ne "alias") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	# We need to try $car against $carid{} (sic!)
#print "Could not find $car.\n";
	return "";
}

sub
sell {
	my($stuff) = @_;
	my(@count,@name);
	my(@variants);
	my($i,$n,$tname,$oldest,$sold,$var);
	
	$oldest = 0; #default always sell youngest
	@count = ();
	@name = ();

	# $main::minaudit = $main::minaudit - 1;  # can sell for zero?
	$main::maxaudit = $main::MAXAUDIT;
	if ($main::showlist =~ /,sell,/ ) {
		print "${main::maxtoday}:sell: $stuff\n";
	}
	$stuff =~ s/^\s*car //i;
	$oldest = $stuff =~ /^\s*oldest\b/i;
	$stuff =~ s/^\s*oldest\b//i;
	$stuff =~ s/^\s*//;
	$stuff =~ s/\s*->.*//;
	# Either need to make sellcar handle optional (prize,...)
	# Or repeat the attempt here
	# Actually problem is garage says "(prize" but sell line doesn't
	if ($sold = &sellcar($stuff, $oldest) ) {
		# literal sale, usually of purchased car...
		if ($main::showlist =~ /,sold,/i ) {
			print "${main::maxtoday}:$stuff ($sold) sold!\n";
		}
		return;
	}
	$stuff =~ s/\bCr[1-9][0-9,]*//g;
	$stuff =~ s/\s*$//;
	if ($stuff =~ /^entry\s+(\d+)\s+(.*)/ && defined($2)) {
#print "sell entry:$1 $2\n";
		&sellentry($1,$2);
		return;
	}
	if ($stuff =~ /^carid\s+([\-\w]+)\s+(.*)/ && defined($2)) {
#print "sell entry:$1 $2\n";
		&sellcarid($1,$2);
		return;
	}
	$stuff =~ s/,/ /g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}cars{0,1}//g;
	$stuff =~ s/\bday {0,1}[1-9][0-9]*//g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}day//g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}day//g;
	$stuff =~ s/\ba\b/1/gi;
	$stuff =~ s/\(\d+\)//g;
	$stuff =~ s/\band\b//gi;
	$stuff =~ s/\bold\b//gi;
	$stuff =~ s/\balso\b//gi;
	$stuff =~ s/\bmost\b//gi;
	$stuff =~ s/\brecent\b//gi;
	while ($stuff =~ /[\w\[\]\-]/ ) {
		$stuff =~ s/^[^\w\[\]\-]//;
#print "stuff:$stuff\n";
		if ($stuff =~ /^(\d+)/ && defined($1) ) {
#print "number:$1\n";
			push @count,$1;
			$stuff =~ s/^\d+\s*//;
		}
		else {
			if ($stuff =~ /^excess */) {
				push @count,-1;
				$stuff =~ s/^excess *//;
			}
			else {
				push @count,1;
			}
		}
		$stuff =~ s/^[^\w\[\]\-]+//;
		if ($stuff =~ /^([\w'\/\[\]\-#.]+)/ && defined($1) ) {
			push @name,$1;
			$stuff =~ s/^[\w'\/\[\]\-#.]+\s*//;
		}
		else {
			last;
		}
	}
	for ($i = 0; defined($name[$i]); ++$i) {
		if ($main::showlist =~ /,sale,/ ) {
			print "${main::maxtoday}:Sell $count[$i] $name[$i].\n";
		}
		$tname = $name[$i];
		$n = $count[$i];
		for ($n = $count[$i]; $n > 0; --$n) {
			if ($sold = &sellcar($tname, $oldest)) {
				if ($main::showlist =~ /,sold,/i ) {
					print "${main::maxtoday}:$tname ($sold) sold!\n";
				}
			}
			else {
				print "${main::maxtoday}:Could not sell $tname.\n";
				last;
			}
		}
		if ($n < 0) {
			$n = -$n;
			@variants = &carvariants($tname);
			foreach $var (@variants) {
#printf("Sell  - $n $var, (%d).\n", &carcount($var,1));
				while (&carcount($var,1) > $n) {
#print "Sell $var.\n";
					if ($sold = &sellcar($var, $oldest)) {
						if ($main::showlist =~ /,sold,/i ) {
							print "${main::maxtoday}:$var ($sold) sold!\n";
						}
					}
					else {
						print "${main::maxtoday}:Could not sell $var.\n";
						last;
					}
				}
			}
		}
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
daycheck {
	my($day) = @_;

	return 0 if ($day =~ /\D/);
	return 0 if ($day !~ /\d/);
	if ($day < $main::mintoday || $main::maxtoday < $day) {
		return 0;
	}
	return 1;
}

sub
dodateline {
	my($line) = @_;

	print " Date: $line\n" if ($main::showlist =~ /,trace,/ );
	if ($line !~ /1999$/ && $line !~ /20[012][0-9]$/) {
		&warn("Bad date line: $_\n");
	}
	if ($main::enddate ne "") {
		$main::done = $line =~ /$main::enddate/i;
	}
	$main::lastdateline = $line."\n";
	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		# Problem is we really want this in the log not selected yet
		addcarlog($main::mentioned,$main::mentionedid,$line);		
	}
}

sub
dopragma {
	my($line) = @_;
	my($what,$value,$league,$length);

	$line =~ /^\s*pragma\s+(\w+)/;
	$what = $1;

	print " Pragma: $line\n" if ($main::showlist =~ /,trace,/ );
	if ($what =~ /^no/) {
		$what =~ s/^no//;
		$main::pragmas =~ s/,$what,/,/;
	}
	else {
		if ($main::pragmas !~ /,$what,/) {
			$main::pragmas .= "$what,";
		}
	}

}

sub
doselect{
	my($line,$rest,$r1,$r2) = @_;
	my($car,$id);

	print " ${main::maxtoday} Select: $rest\n" if ($main::showlist =~ /,trace,/ );
	if ($rest =~ /^select\s*car\s+(\S+)/ && defined($1)) {
		$car = $1;
#print "|$car|\n";
		if ($car eq "none") {
# Wed Apr 14, 2021
# Empty selection turns off selection checking
# We never used this, so change it to be something which cannot match
# Actually we used it in gt1-mazda
			#$main::carids{"none"} = "none";  # hope no trouble
			$main::mentioned = "none";
			$main::selected = "no car selected";
			$main::mentionedid = "";  # ?
			$main::selectedid = "";
			return;
		}
		if ($car eq "game") {
# Indicate use of the "non-garage car" in e.g. licenses and Missions.
			$main::mentioned = "game";
			$main::selected = "game";
			if (!defined(findcarid("game",$line)) || 
				findcarid("game",$line) eq "" ) {
				# Don't think this will ever happen now
				&newautocarid("game",$line);
			}
			$id = findcarid("game",$line);
			$main::mentionedid = $id;
			$main::selectedid = $id;
# This will be useful to allow "verbose carlog" to include comments and status
			addcarlog($car,$id,$line);
			return;
		}
		$id = findcarid($car,$line);
		if ( $id ) {
			$main::selected = $car;
			$main::mentioned = $car;
			$main::mentionedid = $id;
			$main::selectedid = $id;
			addcarlog($car,$id,$line);		
			return;
		}
	}
	if ($main::var{'autoselectcarids'} && defined($car) && $car ne "" 
		&& $car ne "none" ) {
		&newautocarid($car,$line);
		$main::selected = $car;
		$main::mentioned = $car;
		$id = findcarid($car,$line);
		$main::mentionedid = $id;
		$main::selectedid = $id;
		addcarlog($car,$id,$line);		
		return;
	}
	&warn("Bad select: $line\n");
}

sub
getgsb { # get Gold, Silver, Bronze (counts)
	my %h = @_;
	my ($i, @sorted, %m);

	%m = ();
	@sorted = sort lidsub keys %h;
	for ($i = 0; $i <= $#sorted; ++$i) {
		++$m{$h{$sorted[$i]}};  # create $m{"G"}, $m{"S"}, $m{"B"}
	}

	return %m;
}
	

%main::lresults = ();
sub
updatemedal {
	my($lid,$medal) = @_;
	my($oldr);

#printf "updatemedal %s %s\n", $lid, $medal;
	$medal = "F" if !defined($medal);
	return if ($medal eq "F");
	if (!defined($main::lresults{$lid})) {
		$main::lresults{$lid} = $medal;   # know $medal is not F
	}
	else {
		$oldr = $main::lresults{$lid};
		if ($medal eq "G") {
			$main::lresults{$lid} = $medal;
		}
		elsif ($medal eq "S") {
			$main::lresults{$lid} = $medal if ($oldr ne "G");
		}
		# $medal must be B, and $lresults is defined
	}
} 

sub
dolicenseline {
	my($line,$rest,$start,$end) = @_;
	my($diff);
	my($lid,$medal);

	print " ${main::maxtoday} License: $rest\n" if ($main::showlist =~ /,trace,/ );
#&warn("Good license line: $line\n");
	#addcarlog($main::mentioned,$main::mentionedid, $line);
	# Perhaps in a future game licenses will be ascribed to a car?
	addcarlog("game","", $line);
	if (!&daycheck($start) ) {
		&warn("Bad license start day(not ${main::maxtoday}): $_\n");
	}
	$diff = $end - $start;
	if ( $diff < 0 ) {
		&warn("Bad license end day: $_\n");
	}
	$main::mintoday = $end + $main::var{'minlicenseinc'};
	$main::maxtoday = $end + $main::var{'maxlicenseinc'};
	# Almost need completely different routine for GT3, but maybe not?
	return if $main::pragmas !~ /,gt4,/;

	$lid = $rest;   # Note, line includes the day number
	#$lid =~ s/\s*\d+\s+//;  # Remove day number
	$lid =~ s/^licen[^ ]*\s+//;   # Must be a license line
	$lid =~ s/^\s+//;
	$lid =~ s/\s+.*$//;
	$lid =~ s/\n//g;
	$lid =~ s/\(.*//;  # Allow a parenthetical (!) or something
	if ($lid =~ /coffee/) {
		; # handle coffee later
	}
	# Note Gran Turismo actually uses hyphens in test names, e.g. S-16
	elsif ($lid !~ /^[I]{0,1}[BAS][\-]{0,1}[\d]{1,2}$/ || $lid =~ /IS/) {
		&warn("Bad license line (result first?): $line\n");
	}
	else {
		$lid =~ s/[\-]//;  # allow B-1, but use B1 internally
		$medal = $rest;
		#$medal =~ s/\s*\d+\s+//;  # Remove day number
		$medal =~ s/^licen[^ ]*\s+//;
		$medal =~ s/^\s+//;
		$medal =~ s/^I{0,1}[BAS]\d+[\-]{0,1}(\([^ ]*){0,1}\s+//;  # Remove $lid; we allow IS!
		if ( $medal =~ /^([FBSG])\b/ ) {
			$medal = $1;
		}
		else {
# Probably we should just complain in this case
			# Comments between $lid and $medal
#print "S14 medal=$medal\n" if ($lid eq "S14");
			&warn("License medal not first: $line\n")
				if ($main::showlist =~ /,licen[sc]e,/ );
			$medal =~ s/^[A-Za-z]+\s+//;
			$medal =~ s/[A-Za-z]{3,}//g;   # Seattle
			$medal =~ s/^[^ ]+\@[^ ]+//;   # FordGT@Seattle
			$medal =~ s/\bI{0,1}[BAS]\d+\b//g;  # lid can fool us
#			$medal =~ s/\b[\-\+][\:\.\d]{3,100}[BSG]\b//g;  # ignore +0.001G
# For some reason \b prevented matches
			$medal =~ s/[\-\+][\:\.\d]{3,}[BSG]{0,1}//g;  # ignore +0.001G
#print "S14 medal=$medal\n" if ($lid eq "S14");
			if ($medal =~ /[0-9\s]([BSG])\b/) { # 1st medal letter
				$medal = $1;
			}
			else {
				$medal =~ /([BSG])\b/;
				$medal = $1;
			}
		}
#print "S14 medal=$medal\n" if ($lid eq "S14");
		$medal = "F" if !defined($medal);
		updatemedal($lid,$medal);
	}

}

sub
otherprize {
	my($prize) = @_;

	$prize =~ s/\s*\(.*//;
	$prize =~ s/^\s//;
	return 1 if ($prize eq "full");
	return 1 if ($prize eq "none");
	return 1 if ($prize eq "next");  # Hmm...
	return 1 if ($prize eq "1st");
	return 1 if ($prize =~ /^2nd/);
	return 1 if ($prize =~ /^3rd/);
	return 1 if ($prize =~ /^4th/);
	return 1 if ($prize =~ /^5th/);
	return 1 if ($prize =~ /^6th/);
	return 1 if ($prize =~ /^8-/);   #  8-(
	return 1 if ($prize =~ /\s8-/);   #  8-(
                              # but don't match Z28-30th
	#return 1 if ($prize =~ /credits/);
	return 0;
}

sub
event_mindays {
	my($event) = @_;

	if (defined($main::seriesmindays{$event})) {
		return $main::seriesmindays{$event};
	}
	return 0;
}
sub
event_maxdays {
	my($event) = @_;

	if (defined($main::seriesmaxdays{$event})) {
		return $main::seriesmaxdays{$event};
	}
	return $main::var{'maxunknownracedays'};  # +1 for GT1
}

sub
check_event {
	my($event) = @_;
	my($league,$series,$track,$rest);

	return 0 if !defined($event);
	return 1 if defined($main::events{$event});

	my ($delim,$delim2);
	$delim = $main::var{'seriesdelim'};
	$delim2 = $main::var{'trackdelim'};
        # Now we need to handle "series/track"
	if ($delim  eq "") {
		$series = $event;
	}
	else {
		# This could be expensive each series line
		if ( $event =~ /([^${delim}]*)[${delim}](.*)/ ) {
			# Couldn't we assume event structure was checked by "define"
			($league,$series) = ($1,$2);
		}
		return 0 if !defined($league) || !defined($main::league{$league});
		return 0 if !defined($series);
	}
	if ($series =~ /[${delim2}]/) {   # handle a race in a series
		# In GT1 all series had an extra day for all qualifying
		# E.g. GV300 clocked 2 days, but UKvsUS clocked 6
		# Spot/DFRW etc were listed explicitly as 1 day => 2
		# In GT4 a length of 0 meant 1 day, and worked
		# Similarly in  GT2 a length of 0 meant 1 day, and worked
		$series =~ /([^${delim2}]*)[${delim2}](.*)/;
		($series,$track) = ($1,$2);
		# So we need to set a length for GT1
		my ($e);
		$e = $event;
		$e =~ s/[${delim2}][^${delim2}]*$//;
		return 0 if !defined($main::series{"$e"});
		return 0 if !defined($main::track{$track});
	}
	else {
		return 0 if !defined($main::series{"$event"});
		#return 0 if !defined($main::series{"$league/$series"});
	}
	return 1;
}

sub
record_race_prize {
	my ($r,$s) = @_;  # race, prize
	my ($temp);

	return if ($s =~ /credits/ || &otherprize($s));
	$temp = $s;
	$temp =~ s/\s*\(sold\)\s*//;
	$temp =~ s/\s*\(dup\)\s*//;
	$temp =~ s/\s*$//;
	# Perhaps one of these should record some of the above?
	# Currently they are same info; presumably want to derive from them
	push @main::prizes,"${r}: $temp";
	push @main::events,"${r}: $temp";
}


sub
removeseriescarcruft {   # $rest = removeseriescarcruft($rest);
	my($r) = @_;
	my($p);

#print "${main::maxtoday}:", $r,"\n" if ( $r =~ /tune/ || $r =~ m:RT/10:);
	foreach $p (@main::seriescarcrufts) {
#print "${main::maxtoday}:". $r," ",$p,"\n" if $r =~ /tune/;
		if ($r =~ /^[^\s,]+\s*$p/ ) {
			$r =~ s/(^[^\s,]+)\s*$p/$1 /;
			# last ?
#print "${main::maxtoday}: $r\n";
#print "${main::maxtoday}: $r\n" if ($r =~ /DB7/i);
		}
	}
	$r;
}

sub
doseriesline {
	my($line,$rest,$start,$end) = @_;
	my($diff);
	my($i,$none,$pat,$race,$event,$mindays,$maxdays,$suff,$prev,$after);
	my($car,$prize,$count,$status,$temp);


	if ($start eq "") {
		print " ${main::maxtoday} Series: $line (empty)\n" if ($main::showlist =~ /,trace,/ );
		return;		# assume a harmless comment?
	}
	print " ${main::maxtoday} Series: $rest\n" if ($main::showlist =~ /,trace,/ );
	if (!&daycheck($start) ) {
		&warn("Bad start day(not ${main::maxtoday}): $_\n");
	}
	# there's sort of an assumption every event takes at least one day
	#  so daycounter actually becomes $end+1 i.e. $start+$diff+1
	$diff = $end - $start;
	if ( $diff < 0 || $main::maxserieslen < $diff) {
		&warn("Bad end day: $_\n");
	}
	$main::mintoday = $end + $main::var{'minseriesinc'};
	$main::maxtoday = $end + $main::var{'maxseriesinc'};
	$none = 1;
	# Assumption is first token is car, next is event...
	#  Here there are no assumptions about event name format
	$rest = removeseriescarcruft($rest);
	if ($rest =~ /(\S+)\s+(\S+)\s+(.*)/ ) {
		($car,$event,$after) = ($1,$2,$3);
	}
	if ( !defined($event) ) {
		&warn("event not defined: $line\n");
		return;
	}
	if (&check_event($event) == 0) {
		&warn("Unrecognized event ($event): $line\n");
		$event = " ";
		return;
	}
	else {
		if ( $main::pragmas =~ /,gt4,/ && 
			($event =~ /^World/ ||
			 $event =~ /^Original/ ||
			 $event =~ /^Dirt/ ||
			 $event =~ /^City/ ||
			 $event =~ /^Park/ ) ) {
			# costs you Cr to run some of the events
			$main::minaudit = 0;
			$main::maxaudit = $main::maxaudit + 50000;
		}
		elsif ( $main::pragmas =~ /,gt2,/ && 
			 $event =~ /^Rally/ ) {
			# No money for second place
			# $main::minaudit = $main::minaudit;
			$main::maxaudit = $main::maxaudit + 50000;
		}
		else {
			# Assume always get money for last place
			$main::minaudit = $main::minaudit + 
				$main::var{'minprizecredits'};
			$main::maxaudit = $main::MAXAUDIT;
		}
		$mindays = &event_mindays($event);
		$maxdays = &event_maxdays($event);
		if ($diff < $mindays || $maxdays < $diff) {
			# It is amazing this check usually passes
			&warn("Bad end day for series \"$event\": $line\n");
		}
		$car =~ s/^\s*//;
		$car =~ s/[,\s].*//;
		checkcar($car,$line);
		addcarlog($car,"",$line);
		
	}
	$none = 0;
	if ( !defined($event) ) {
		&warn("event not defined: $line\n");
		return;
	}
	# Note: bad ${event} can break regex  E.g. "(perm"
	if ( $rest =~ m/(\S+.*\s+)(\S+[\/]${event})(\s.*)/ ) {
		$rest =~ /(\S+.*\s+)(\S+\/${event})(\s.*)/ ;
		($prev,$race,$after) = ($1,$2,$3);
	}
	else {
		$rest =~ /(\S+.*\s+)(${event})(\s.*)/ ;
		($prev,$race,$after) = ($1,$2,$3);
	}
	if ( !defined($after) ) {
		&warn("$rest has no after\n");
		return;
	}
	# Boy there's some old cruft here
	$status = "";
	$prize = $rest;
	$prize =~ s/red /red#/g;
	$prize =~ s/black /black#/g;
	$prize =~ s/ LM/#LM/g;
        $prize =~ s/^.* ([\w\[])/$1/;
        $prize =~ s/[!]//g;
	if ($prize =~ /([(].*)/ && defined($1)) {
		$status = $1;
		$prize =~ s/[(].*//;
	}
	if ($prize !~ /ConceptCar/ ) {
		$prize =~ s/Concept/ConceptCar/;
	}
	$prize =~ s/#/ /g;
	$prize =~ s/ *$//g;
#	if ( &otherprize($prize) == 0 &&
#			$main::raceprizes{$event} !~ /,${prize},/ ) {
#		&warn("Unrecognized prize ($prize) for $race: $line\n");
#	}
	if ($status =~ /([(][^)]*[)])(.*)/) {
		$count = $1;
		$status = $2;
		if ($status =~ /([(][^)]*[)])(.*)/) {
			$status = $1;
		}
	}
	if ($prize eq "next") {
		if (defined($main::prize_event) && $main::prize_event ne "") {
			 &warn("Next for $main::prize_event never claimed: $line\n");
		}
		$main::prize_event = $race;
	}
	record_race_prize($race,$prize);
	# N.B. $prize has everything after opening parenthesis removed
	if ($prize !~ /credits/ && &otherprize($prize) == 0) {
		my ($fullprize, $id);
		$fullprize = $prize;
		if (defined($main::fullprizenames{$prize}) ) {
			$fullprize = $main::fullprizenames{$prize};
		}
		$id = getcar($prize,"$fullprize(prize, $race)",$line);
		if ($status eq "(sold)" || $line =~ /[(]sold[)]/ ) {
# It really would be  more pure to match $status or $line more precisely
			marksold($id);
		}
	}
}

sub
check_hash {
	my($old, $new) = @_;

	if (defined($old) && $old ne "") {
		&warn("Duplicate definition: $new\n");
	}
	return $new;
}


sub
docardef {
	my($line) = @_;
	my($what,$value,$carid);

	print " ${main::maxtoday} Cardef: $line\n" if ($main::showlist =~ /,trace,/ );

	$line =~ /^\s*cardef\s+(\S+)\s+([\S]+)/;
	$what = $1;
	$value = $2;

	if (!defined($what) || !defined($value)) {
		&warn("Bad cardef: $line\n");
		return;
	}
	if (defined($main::cardefs{$what})) {
		&warn("Already defined: $line\n");
		return;
	}
	$carid = findcarid($value,$line);
	if (!$carid) {
		&warn("Bad carid: $line\n");
		return;
	}
	if ($main::carstates{$carid} eq "sold") {
		&warn("Already sold car: $line\n");
		return;
	}
	$main::cardefs{$what} = $carid;
	# Feb 2022; realized $what should become new default shortname
	$main::carids{$carid} = $what;
}

sub
douncardef {
	my($line) = @_;
	my($what);

	print " ${main::maxtoday} Uncardef: $line\n" if ($main::showlist =~ /,trace,/ );
	$line =~ /^\s*uncardef\s+(\S+)/;
	$what = $1;

	if (!defined($main::cardefs{$what})) {
		&warn("No such cardef: $line");
		return;
	}
	delete($main::cardefs{$what});
 	# is following advisable?
	#if (defined($main::carlist{$what})) {
	#	delete($main::carlist{$what});
	#}
}

sub
setseriescarcruft {
	# This is really a bit much just to avoid editing old GT1 logs...
	my ($stuff,$chunk);
	# Note currently this can be repeated
	#  That mean's there is no way to empty @$main::seriescarcrufts

	$stuff = $main::seriescarcruft;
	$stuff =~ s/\n//g;
	while ($stuff ne "") {
		$chunk = $stuff;
		$chunk =~ s/\#.*//;
		$stuff =~ s/^[^\#]*//;
		$stuff =~ s/^\#//;
		push @main::seriescarcrufts, $chunk;
	}
#foreach $chunk (@main::seriescarcrufts) {
#	print "$chunk\n";
#}
}


sub
dosetvar {
	my($line) = @_;
	my($what,$value,$carid);

	print " Setvar: $line\n" if ($main::showlist =~ /,trace,/ );
	if ( $line =~ /^\s*setvar\s+(\S+)\s*\=\s*\"([^"]*)\"/ ) {  # quoted
		# can of worms
		$what = $1;
		$value = $2;
	}
	elsif ( $line =~ /^\s*setvar\s+(\S+)\s*\=\s*([\S]+)/ ) {
		# Usually number...
		$what = $1;
		$value = $2;
	}
	else {
		&warn("Bad setvar: $line\n");
		return;
	}
	# assert defined($what) && defined($value)

	$main::var{$what} = $value;
	if ($what eq "seriescarcruft") {   # super-kludge
		$main::seriescarcruft = $main::var{$what};
		setseriescarcruft();
	}
}

sub
newautocarid {
	my($carname,$line) = @_;
	my($newid);

#print "$carname: $line\n" if ($carname eq "none");
	# Almost no reason we couldn't generate a real carid
	#  But it will be nice to be able to distinguish
	++$main::autocaridcount;
	$newid = "car0-"."$main::autocaridcount";
	# Following replicates a bit of getcar()
	$main::carids{$newid} = $carname;  # actually see findcarid
	$main::carnames{$newid} = $carname;
	$main::carstates{$newid} = "alias";   # s.b. "won" or "new" or "used"?
	$main::carlist{$carname} = $carname;
	$main::origin{$newid} = $line;
	$main::carprices{$newid} = "Cr0";   # Not sure what to do here
	$main::carid{$carname} = $newid;  # stupid names carids vs carid
	if (defined($main::carid{$newid}) ) {
		&warn("carid{$newid} already defined (should not happen): $line\n");
	}
	else {
		$main::carid{$newid} = $newid;  # facilitate carid reference
	}
	# $main::ncarsnow = carsnow();   # expensive?
	# Problem: this increases the car count
	return $newid;
}

sub
findcarid { # given explicit cardef or carid, or unique shortform, return carid
	    # warn (first time) about unresolvable names
	my($carname,$line) = @_;
	my($k,$id);

# Problem: we end up calling this with value "none"
	if (defined($main::carids{$carname})) {
		# We were given a carid; just return it (NOT carids{$carname})
		return $carname;
		# $carids{} is shortform, indexed by carid
	}
# We have both %carids and %carid
# Hmm...  $carid{$c} should eq $c  if $c is a carid
	if (defined($main::carid{$carname})) {
		# quick map of short forms to carid
		return $main::carid{$carname};
	}
	if (defined($main::cardefs{$carname} )) {
		return $main::cardefs{$carname};
	}
	# Did not find via above; search all $carids{}
	# I wonder if this happens a lot?  (expensive)
	$id = "";
	foreach $k (sort caridsub keys %main::carids) {
		# keys sorted to prefer earliest match?
		if ($main::carids{$k} eq $carname &&
				$main::carstates{$k} ne "sold") {
			# N.B. In this case we must match aliases
			# Might be situations to match "sold" also...
			# Note that quick lookup table ignores sold...
			if ($id eq "") {
				$id = $k;
			}
			else {
				if ($line ne "") {
					# should we warn here?
				&warn("Ambiguous car ($carname): $line\n");
					# Use first if $line is not set
					return undef;
				}
			}
		}

	}
	if ( $id ne "" ) {
		return $id;
	}
	# Rest is just to reduce diagnostics by defining undefined
	if (!defined($main::carlist{$carname})) {
		# Reduce diagnostics by defining here
		$main::carlist{$carname} = $carname;
		if ( $main::var{'autocarids'} == 0 ) {
			&warn("Unrecognized car ($carname): $line\n");
		}
		else {
			$id = &newautocarid($carname,$line);
			# Still return undef, however...
		}
			
	}
	return undef;
}

sub
dofullprizename {
	my($argline) = @_;
	my($line, $what,$value);

	print " Fullprizename: $argline\n" if ($main::showlist =~ /,trace,/ );
	$line = $argline;
	$line =~ s/^\s*define\b\s*//i;
	if ($line =~ /^\s*fullprizename\s+([\-\w\/\#]+)\s+(.+)$/ ) {
		# black/blueSupra
		# silverNismoGT-R LM
		$what = $1;
		$value = $2;
		$what =~ s/#/ /g;
		$value =~ s/\s+$//;
		$main::fullprizenames{$what} = $value;
	}
	else {
		&warn("Bad fullprizename: $argline\n");
	}
}


sub
dodefine {
	my($line) = @_;
	my($what,$value,$league,$length);

	print " Define: $line\n" if ($main::showlist =~ /,trace,/ );
	$line =~ /^\s*define\s+(\w+)\s+([\S]+)/;
	# Should check for undefined...
	$what = $1;
	$value = $2;

	if ($what =~ /fullprizename/i) {
		dofullprizename($line);
		return;
	}
	if ($what =~ /league/i) {
	   $main::league{$value} = &check_hash($main::league{$value}, $value);
	}
	elsif ($what =~ /series/i) {
	   $league = "";
	   my($delim);
	   $delim = $main::var{'seriesdelim'};
#print "delim=|$delim|\n";
	   if ($delim ne "") {
	        if ($value !~ /^([^\s${delim}]+)${delim}([^\s${delim}]+)$/) {
		#Problems: A/S+S E/All-night
		    &warn("Bad series name: $value\n");
	        }
	        else {
		    $league = $1;
	        }
	        if (!defined($main::league{$league})) {
		    &warn("Undefined league in series name: $value\n");
	        }
	   }
	   # after this, $value can be an arbitrary string
	   # Goal here is to process old "Sunday" events from GT1 logs
#print "set series |${value}|\n";
	   $main::series{$value} = &check_hash($main::series{$value}, $value);
	   $length = 1;
	   if ( $line =~ /^\s*define\s+(\w+)\s+([\S]+)\s+(\d+)/ ) {
		$length = $3;
	   }
	   if ($length > $main::maxserieslen) {
		$main::maxserieslen = $length;
	   }
	   $main::seriesmindays{$value} = $length-1;   # Why -1 ?
	   $main::seriesmaxdays{$value} = $length-1;   # Why -1 ?
	}
	elsif ($what =~ /track/i) {
	   $main::track{$value} = &check_hash($main::track{$value}, $value);
	}
	else {
		&warn("Bad definition: $line");
	}
}


$main::fid = 'LOG0';
sub
doinclude {
	no strict 'refs';
	my($line) = @_;
	my($filename, $oldfid, $n);

# I do not believe that includes can be nested...
	print " Include: $line\n" if ($main::showlist =~ /,trace,/ );
	$line =~ /^\s*include\s+(\S+)/;
	$filename = $1;
	$oldfid = $main::fid;
	$n = $main::fid;
	$n =~ s/LOG//;
	++$n;
#print "$main::fid $n\n";
	$main::fid = 'LOG' . "$n";
	if (!open($main::fid,"<$filename") ) {
		&warn("Cannot open include \"$filename.\"\n");
		$main::fid = $oldfid;
	}
}

sub
heuristicinclude {
	my ($logname, $line) = @_;  # Current line to stash for later somehow
	my ($includefile);

	$main::saveline = $line;
	print "Attempt include for $logname\n" if ($main::showlist =~ /,heuristic,/ );
	$includefile = "gt1-racedefs";
	if ($logname =~ /^gt4/) {
		$includefile = "gt4-racedefs";
	}
	elsif ($logname =~ /^gt3/) {
		$includefile = "gt3-racedefs";
	}
	elsif ($logname =~ /^gt2/) {
		$includefile = "gt2-racedefs";
	}
	elsif ($logname =~ /^gt1/) {
		$includefile = "gt1-racedefs";
	}
	elsif ($logname =~ /^ARRI/) {
		$includefile = "ARRI-racedefs";
	}
	&doinclude("include $includefile");
}

$main::lastaspec = 0;
sub
doaudita {
	my($line,$rest,$r1,$r2) = @_;

	my ($aspec,$diff);
	if ($rest =~ /A:(\d+)/) {
		my ($a) = ($1);
		my ($car) = ($main::mentioned);  # $main::selected  ?
		my ($id) = ($main::mentionedid);  # $main::selected  ?
		if (!defined($main::caraspecs{$car})) {
			$main::caraspecs{$car} = 0;
		}
		if (!defined($main::caraspecs{$id})) {
			$main::caraspecs{$id} = 0;
		}
		$diff = $a - $main::lastaspec;
		if ($diff >= 0) {
			$main::caraspecs{$car} += ($a - $main::lastaspec);
			$main::caraspecs{$id} += ($a - $main::lastaspec)
					if ($car ne $id);
			$main::lastaspec = $a;
		}
		else {
			if ( $main::showlist=~/,audita,/ ) {
	publish($car,"Audit A:$a should be >= ${main::lastaspec}: $line\n");
			}
		}
		my $w = "";
		if ( $main::caraspecs{$main::mentioned} !=
			$main::caraspecs{$main::mentionedid} ) {
			$w = " *";
		}
		if ($main::showlist=~/,diffa,/) {
			publish($car,
				"Audit A: ".$diff." ".$main::mentionedid." ".
				$main::mentioned." ".
				$main::carids{$main::mentionedid}.$w."\n");
		}
		if ($main::showlist=~/,diffan,/) {
			publish($car,
				"Audit ".$diff." ".$main::mentioned." "."A:".
				#$main::carids{$main::mentionedid}." ".
				$main::caraspecs{$main::mentioned}.
				$w."\n");
		}
		if ($main::showlist=~/,diffai,/) {
			publish($car,
				"Audit ".$diff." ".$main::mentionedid." ".
				$main::carids{$main::mentionedid}." A:".
				$main::caraspecs{$main::mentionedid}.
				$w."\n");
		}
	}
}

$main::bspec = 0;
$main::machine = 0;
$main::course = 0;
$main::battle = 0;
sub
doauditb {
	my($line,$rest,$r1,$r2) = @_;

	my ($warn, $newbspec, $newmachine, $newcourse, $newbattle);
	my ($incbspec, $incmachine, $inccourse, $incbattle);
	my ($lineno,$note);
	$warn = "";
	if ( $rest =~ /B:(\d+)\/(\d+)\/(\d+)\/(\d+)/ ) {
		$newbspec = $1;
		$newmachine = $2;
		$newcourse = $3;
		$newbattle = $4;
		$lineno = "";
		if ($line =~ /^\s*(\d+)\s+/ ) {
			$lineno = " ".$1;
		}
		if ($rest =~ /B:\d+\/\d+\/\d+\/\d+ *\(n\/c\)/ ) {
			$incbspec = 0;
			$incmachine = 0;
			$inccourse = 0;
			$incbattle = 0;
		}
		elsif ($rest =~
		  /B:\d+\/\d+\/\d+\/\d+ *\(\+{0,1}(\d+)\/\+{0,1}(\d+)\/\+{0,1}(\d+)\/\+{0,1}(\d+)\)/ ) {
			$incbspec = $1;
			$incmachine = $2;
			$inccourse = $3;
			$incbattle = $4;
		}
		else {
#			$warn .= " NoInc";
			$incbspec = 0;
			$incmachine = 0;
			$inccourse = 0;
			$incbattle = 0;
		}
		my( $t, $c, $m, $b);
		$t = $newbspec - $main::bspec;
		$c = $newmachine - $main::machine;
		$m = $newcourse - $main::course;
		$b = $newbattle - $main::battle;
		$note =
			"Audit $lineno B:$newbspec/$newmachine/$newcourse/$newbattle" .
			"($incbspec/$incmachine/$inccourse/$incbattle)" .
# Seems we should use new in following also; not clear what we are checking
			"  B:$newbspec/$newmachine/$newcourse/$newbattle" .
			"(+$t/+$c/+$m/+$b)" . "\n";
		my($car) = ($main::mentioned);
		$main::carbspecs{$car} = 0
				if (!defined($main::carbspecs{$car}));
		$main::carbmachines{$car} = 0
				if (!defined($main::carbmachines{$car}));
		$main::carbcourses{$car} = 0
				if (!defined($main::carbcourses{$car}));
		$main::carbbattles{$car} = 0
				if (!defined($main::carbbattles{$car}));
		$main::carbspecs{$car} += $t;
		$main::carbmachines{$car} += $m;
		$main::carbcourses{$car} += $c;
		$main::carbbattles{$car} += $b;
		my($id) = findcarid($car,$line);
		if ($car ne $id) {
			# $car eq $id would be pathological
			$main::carbspecs{$id} = 0
				if (!defined($main::carbspecs{$id}));
			$main::carbmachines{$id} = 0
				if (!defined($main::carbmachines{$id}));
			$main::carbcourses{$id} = 0
				if (!defined($main::carbcourses{$id}));
			$main::carbbattles{$id} = 0
				if (!defined($main::carbbattles{$id}));
			$main::carbspecs{$id} += $t;
			$main::carbmachines{$id} += $m;
			$main::carbcourses{$id} += $c;
			$main::carbbattles{$id} += $b;
		}
		my ($w, $bcar, $bid) = ("","","");
		$bid =  $main::carbspecs{$id}."/".
			$main::carbmachines{$id}."/".
			$main::carbcourses{$id}."/".
			$main::carbbattles{$id};
		$bcar =  $main::carbspecs{$car}."/".
			$main::carbmachines{$car}."/".
			$main::carbcourses{$car}."/".
			$main::carbbattles{$car};
		if ( $bid ne $bcar) {
			$w = " *";
		}
		my ($diff) = ( $t."/". $m."/". $c."/". $b );
		if ($main::showlist=~/,diffb,/) {
			publish($car,
				"Audit B: ".$diff." ".$main::mentionedid." ".
				$main::mentioned." ".
				$main::carids{$main::mentionedid}.
				$w,"\n");
		}
		if ($main::showlist=~/,diffbn,/) {
			publish($car,
				"Audit ".$diff." ".$main::mentioned." "."B:".
				#$main::carids{$main::mentionedid}." ".
					$main::carbspecs{$car}."/".
					$main::carbmachines{$car}."/".
					$main::carbcourses{$car}."/".
					$main::carbbattles{$car}.
				$w,"\n");
		}
		if ($main::showlist=~/,diffbi,/) {
			publish($car,
				"Audit ".$diff." ".$main::mentionedid." ".
				$main::carids{$main::mentionedid}." B:".
					$main::carbspecs{$id}."/".
					$main::carbmachines{$id}."/".
					$main::carbcourses{$id}."/".
					$main::carbbattles{$id}.
				$w,"\n");
		}

# Should check for inc < 0 duh!
		if ($newbspec != ($main::bspec + $incbspec) ) {
			$warn .= " Bspec";
		}
		if ($newmachine != ($main::machine + $incmachine) ) {
			$warn .= " Mac";
		}
		if ($newcourse != ($main::course + $inccourse) ) {
			$warn .= " C";
		}
		if ($newbattle != ($main::battle + $incbattle) ) {
			$warn .= " Bat";
		}
		$main::bspec = $newbspec;
		$main::machine = $newmachine;
		$main::course = $newcourse;
		$main::battle = $newbattle;
	}
	if ($warn ne "" && $main::showlist =~ /,auditb,/) {
		&warn($note);
		#warn("$warn: $line");
		&warn("Audit - $warn: $line\n");
	}
}

#
# doaudit - attempt to keep track of what Cr total should be
#
#$main::auditracelast = 1;        # we might not need this
$main::MAXAUDIT = 100000000000;  # 100 billion for now
$main::minaudit = 0;
$main::maxaudit = $main::MAXAUDIT;
$main::knownaudit = 0;
$main::minourtotal = 0;
$main::minourtotal = 0;
sub
doaudit {
	my($line,$rest,$r1,$r2, $estimate) = @_;
	# $estimate is recorded total from statusline
	my($logto,$logtoid);

	$logto = $main::mentioned;
	$logtoid = $main::mentionedid;
	if ($logto eq "" || $logto eq "none") {
		$logto = "game";
		$logtoid = $main::carid{$logto};
	}
	# I think we have forced A: and B: to always have Cr on same line...
	# This is auditc (credidts)
	if ($estimate < $main::minaudit && $main::showlist=~/,auditc,/) {
		&warn("Audit Cr$estimate should be more than ${main::minaudit}: $line\n");
	}
	if ($main::maxaudit < $estimate && $main::showlist=~/,auditc,/) {
		&warn("Audit Cr$estimate should be less than ${main::maxaudit}: $line\n");
	}
	# if $main::mentioned is "none", we want to assume "game"
	# Perhaps when selected is set to "none", set mentioned to "game"
	# Assessing earned credits is harder than Aspec or Bspec points
	$main::carcredits{$logto} = 0
		if (!defined($main::carcredits{$logto})) ;
	$main::cardebits{$logto} = 0
		if (!defined($main::cardebits{$logto})) ;
	$main::carcredits{$logtoid} = 0
		if (!defined($main::carcredits{$logtoid})) ;
	$main::cardebits{$logtoid} = 0
		if (!defined($main::cardebits{$logtoid})) ;
	# Really, buy car should...
	# Deduct price from $main::knownaudit
	#     and add it to $main::cardebits{$car}
	#     perhaps add it to $main::cardebits{"game"}   ?
	# Note: $main::cardebits will not be seen if the car has no carlog
	my($diff) = ($estimate - $main::knownaudit);
	if ($diff >= 0) {
		$main::carcredits{$logto} += $diff;
		if ($logto ne $logtoid) {
			# Pathologically might say "select car <carid>"
			$main::carcredits{$logtoid} += $diff;
		}
	}
	else {
		$main::cardebits{$logto} += 0 - $diff; 
		if ($logto ne $logtoid) {
			$main::cardebits{$logtoid} += 0 - $diff;
		}
	}
	my $w = "";
	if ( $main::carcredits{$logto} !=
		$main::carcredits{$logtoid} ||
		$main::cardebits{$logto} !=
		$main::cardebits{$logtoid} ) {
		$w = " *";
	}
	my $car = $logto;
	if ($main::showlist=~/,diffc,/) {
		publish($car,
			"Audit ".$diff." ".$logtoid." ".
			$logto." ".
			$main::carids{$logtoid}.$w."\n");
	}
	if ($main::showlist=~/,diffcn,/) {
		publish($car,
			"Audit ".$diff." ".$logto." ".
			#$main::carids{$logtoid}." ".
			tocredits($main::carcredits{$logto}). " ".
			"(".tocredits($main::cardebits{$logto}).
			")".
			$w."\n");
	}
	if ($main::showlist=~/,diffci,/) {
		publish($car,
			"Audit ".$diff." ".$logtoid." ".
			$main::carids{$logtoid}." ".
			tocredits($main::carcredits{$logtoid}). " ".
			"(".tocredits($main::cardebits{$logtoid}).
			")".
			$w."\n");
	}
	# In some cases we might want to believe our total instead?
	$main::knownaudit = $estimate;
	$main::minaudit = $main::knownaudit;
	$main::maxaudit = $main::knownaudit;
	
	# Note doaudita and doauditb assign totals to current car
	doaudita( $line,$rest,$r1,$r2);  # audita; Aspec points
	doauditb( $line,$rest,$r1,$r2);  # auditb; Bspec points
}

sub
dostatusline {
	my($line,$rest,$r1,$r2) = @_;
	#my($day,$stuff,$sf,$fullname);

	print " ${main::maxtoday} Status: $rest\n" if ($main::showlist =~ /,trace,/ );
	if (!&daycheck($r1) ) {
		&warn("Bad single day note(not ${main::maxtoday}): $line\n");
	}
	# Assert $rest =~ /^Cr[0-9]/
	# grr... seems difficult to undef $1 ...
	# If you need to, 'a' =~ /a/   will do it. I.e. a successful match.

	# Later check Ncars, medal counts perhaps license standing?

	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		addcarlog($main::mentioned,$main::mentionedid,$line);		
	}
	if ( $main::pragmas =~ /,gt4,/ && $rest =~
	   m:([0-9]{1,2}[GB][ /]{1,3}[0-9]{1,2}[S][ /]{1,3}[0-9]{1,2}[GB]): ) {
		# Later perhaps license stats for GT3
		my $licstats = $1;
		my ($m, $s);
		my (%gsb);
		$s = "";
		%gsb = getgsb(%main::lresults);
		for $m ("G", "S", "B") {
			if (!defined($gsb{$m}) ) {
				$gsb{$m} = 0;
			}
			$s .= sprintf("%d%s ", $gsb{$m}, $m);
		}
		# Compare %gsb/$s with canonical version of $licstats
		my ($logresults) = ("");
		$licstats =~ /\b([0-9]+G)\b/;
		$logresults .= "$1 " if (defined($1));
		$licstats =~ /\b([0-9]+S)\b/;
		$logresults .= "$1 " if (defined($1));
		$licstats =~ /\b([0-9]+B)\b/;
		$logresults .= "$1 " if (defined($1));
		if ($main::showlist =~ /,licen[sc]e,/ ) {
			printf "%s %s %s - %s\n",
				$r1, $licstats, $logresults, $s;
		}
		if ( $logresults ne $s ) {
			&warn("$logresults ne $s: $line\n");
		}
	}
	if ( ( $main::showlist =~ /,warn,/i || $main::showlist !~ /,garage,/)
		 && $rest =~ m:\b([0-9]{1,4})[ ]{0,3}car[s]{0,1}\b:i ) {
		# commas?
		my ($logncars);
		$logncars = $1;
		if ($logncars != $main::ncarsnow) {
			&warn("Car count not ${main::ncarsnow}): $line\n");
		}
	}
	if ( $rest =~ /Cr\d.*Cr\d/ ) {
		# Prior to gt3, we'd put actions on status lines
		my ($credits) = ($rest);
		# assume the second credit total is more significant
		# Should we look for [-=]> ?
		$credits =~ s/\(Cr\d[^)]*\)/ /;  # diffs sometimes
		$credits =~ s/.*(Cr\d)/$1/;  # potential bugs
		$credits =~ s/ .*//;
		$credits = fromcredits($credits);
		doaudit( $line,$rest,$r1,$r2, $credits);
	}
	elsif ( $rest =~ /^Cr\d/ ) {
		my ($credits) = ($rest);
		$credits =~ s/ .*//;
		$credits = fromcredits($credits);
		doaudit( $line,$rest,$r1,$r2, $credits);
	}
	elsif ( $rest =~ /Cr\d/ ) {
		# Prior to gt3, though, we'd put actions on status lines
		my ($credits) = ($rest);
		$credits =~ s/.*Cr\d//;  # potential bugs
		$credits =~ s/ .*//;
		$credits = fromcredits($credits);
		doaudit( $line,$rest,$r1,$r2, $credits);
	}

	$main::mintoday = $r2;
	$main::maxtoday = $r2;
}


# $e = set_from_race($e);
sub
race_to_set {  # derive "set" (event) name from one of its races
	my($s) = @_;
# E,g, GT4   B/Sunday/AMii  => B/Sunday
#   But  SC/Normal/AmalfiR => SC/Normal/Amalfi

	# A prize is for the set, not the race
	# Perhaps this depends on pragma
	# Or perhaps we need "prizeevent" defns
	if ($s !~ m:/(Easy|Normal|Hard)/: ) { # ugh!
		while ($s =~ m:/.*/: ) {
			$s =~ s:/[^/]*$:: ;
		}
	}
	else {  # and ugh!
		$s =~ s/R$//;
		$s =~ s/ii$//;
	}
	return $s;
}

sub
dowin {   # Handle  150 +1 win car  RSC'02  Toyota RSC Rally Raid Car '02
# Note: also   59 +1 win car Nike   Nike One 2022 (prize,IBlicenseB)
	my($line,$rest,$r1,$r2) = @_;
	#my($day,$stuff,$sf,$fullname);
	my($stuff,$sf,$fullname);
	my($tstuff,$event);

	print " ${main::maxtoday} Win: $rest\n" if ($main::showlist =~ /,trace,/ );
	if ($rest !~ /^win\s+(.*)/ || !defined($1)) {
		return;
	}
	$stuff = $1;
#print "stuff:$stuff\n";
	#if ($main::mentioned ne "") {
	addcarlog($main::mentioned,$main::mentionedid,$line);
	#}
	if ($stuff !~ /^\s*car\s+(\S+)/ || !defined($1) ) {
		if (!$main::var{'allowanyprize'} ) {
			&warn("Bad win: $line\n");
		}
		else {
			getcar($stuff,$stuff,$line);
			$main::prize_event = "";
		}
		return;
	}
	$event = "";
	$tstuff = $stuff;
	while ($tstuff =~ m:\s*\([^\)]*\)\s*$: ) {
#&warn("Eat parentheses: $line\n");
		if ($tstuff =~ m:(\(prize[^\)]*)\)\s*$: ) {
#&warn("Found prize: $line\n");
			$event = $1;
			$event =~ s/^\(prize,//;
			$event =~ s/\)\s*$//;
			last;
		}
# Good candidate for infinite loop here...
		$tstuff =~ s:\s*\([^\)]*\)\s*$:: ;
	}


	if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
#$main::prize_event = "";
# Problem: some prize car names include parentheses
		$sf = $1;
		if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
			$fullname = $2;
			$fullname =~ s/^[^\w\[]*//;
			$fullname =~ s/->\s.*//;
			$fullname =~ s/\s*$//;
			$fullname =~ s/^\s*//;
			if ($event ne "") {
				# Actually probably a non-race prize
				record_race_prize($event,$fullname);
			}
			elsif (defined($main::prize_event) && $main::prize_event ne "") {
				my ($e) = ($main::prize_event);
				# assert ($event eq "")
				$e = race_to_set($e);
				$fullname =~ s/$/ (prize,$e)/;
				# push event info here...
				record_race_prize($e,$fullname);
			}
			# Need a GOOD way for prize info to be passed
			getcar($sf,$fullname,$line);
			if ($main::showlist =~ /,buy,/i) {
				print "${main::maxtoday}:win $sf - $fullname.\n";
			}
		}
		else {
			# Need a way for prize info to be passed
			# I don't think we ever use this form?
			getcar($sf,$sf,$line);
		}
	}
	if ($event eq "") {
# Perhaps having $main::prize_event set for a win with event should be an error
		if (!defined($main::prize_event) || $main::prize_event eq "") {
			&warn("prize_event not set: $line\n");
		}
		$main::prize_event = "";
	}

}

sub
normalizeparts {
	my($car,$line) = @_;
	my($stuff, $dayno, $op);
	my ($tok);
	my ($mod);

# 208  mod car   CivicTypeR WR1 WR2 WR3  -805-780-755  Cr1000 Cr5000 Cr20,000
# 451  buy parts whiteCelica'70 (Tom's) Rmuff Cr4600 Rbr Bctlr  Cr4600 Cr10,300
# 451  mod car   whiteCelica'70   pol+bal  Cr5250  Cr11,000
# 451  mod car   whiteCelica'70   WR1 WR2 WR3 Cr1100 Cr5300 Cr21,000
	$stuff = $line;
	$stuff =~ s/\n//g;
	$stuff =~ s/^\s*//;  # Had had obscure bug ctrl\ instead of "^\"
	$stuff =~ s/^\s*$//;   # Can't hurt
	$dayno = $stuff;
	$dayno =~ s/\s+.*$//;
	$stuff =~ s/^\S+\s*//;
	$op = $stuff;
	if ($op =~ /^\+\d/) {
		# In GT4, this actually implies wheels
		$stuff =~ s/^\S+\s*//;
		$op = $stuff;
	}
	$op =~ s/\s.*$//;  #  s.b. "buy" or "mod"
			# Will later make into "parts" or "mod"
	$stuff =~ s/^\S+\s*//;
	$tok = "";
	for ( ; ; ) {
		last if ($stuff eq "");
		$tok = $stuff;
		$tok =~ s/\s+.*$//;
		$op = $tok if ($tok eq "parts");
		$stuff =~ s/^\S+\s*//;
		last if ($tok eq $car);
	}
	if ($tok ne $car) {
		# Perhaps this will be redundant noise given "select"
		&warn("Could not find $car: $line\n");
	}
	while ($stuff =~ /,\s*Cr/i ) {
		# Ensure prices are separated by spaces, not commas
		$stuff =~ s/,\s*Cr/ Cr/ig;
	}
	while ($stuff =~ /Cr\d+,\d/i ) {
		# Reomve optional commas from Cr10,000
		$stuff =~ s/(Cr\d+),(\d)/$1$2/;
	}
	while ($stuff =~ /Cr\d+[.]\d/i ) {
		&warn("Period instead of comma: $line\n");
		$stuff =~ s/(Cr\d+)[.](\d)/$1$2/;
	}
	# Now for things like
        # 117 mod car   Silvia'88K  WR1  Cr1000  ->1071kg
        # 120 buy parts Silvia'88K  Rmuff  ->257hp
        # 706  mod car  March  WR1 WR2 WR3 -805-780-755  Cr1000 Cr5000 Cr20,000
	# Appears we only did 805 -> 780 in comments
	# Recently we usually use only "-" with no spaces
	# We cannot safely remove spaces before "-".
	$stuff =~ s/(\d)to(\d)/$1-$2/g;  # probably should've just changed log
	my($p) = $stuff;
	$mod = "";
	while ( $stuff =~ m/(\d*-[\d\-\>]+(hp|kg){0,1})/ ) {
		$mod .= $1;
		$stuff =~ s/\d*-[\d\-\>]+(hp|kg){0,1}//;
		 # remove anything with digits and "->"
		# avoid T-S3 changing to TS3
	}
# Maybe later we can use such mod information somehow
	if ($main::showlist =~ /,mod,/ && $p ne $stuff) {
		print " B:",$p,"\n A:",$stuff,"\n";
		print " mod:$mod\n";
	}

	# Back in gt3-game1 I tended to put prices in parentheses
	#  But they do not seem semantically significant
	while ($stuff =~ /\((Cr\d+[^()]*)\)/ ) {
		#  72   buy parts Trueno SpSusp (Cr3,000)
		#  72   buy parts Trueno SpSusp (Cr3000)
		# Add space in case parenthesis was used as token separator
		$stuff =~ s/\((Cr\d+[^()]*)\)/ $1/;
		#  72   buy parts Trueno SpSusp  Cr3000
	}
	$stuff =~ s/\(\?\)//g;  # FWIW
	$stuff =~ s/,/ /g;  # Any remaining commas could be spaces
	$stuff =~ s/\+/ /g; # I use "pol+bal" a lot; also "cage+refresh"
	$stuff =~ s/\s+/ /g;   # Multiple spaces not semantically significant
	$stuff =~ s/\s*$//;  # just to be sure
	$stuff =~ s/^\s*//;  # just to be sure
	#  Note in GT3 you bought tire combinations e.g. T-R3/T-R3
  	#  66   buy parts Trueno T2/T2 (Cr10,000)

	#return ($op, $tok. $stuff);  # Sure I assigned funcs to arrays before
	return $op . " " . $tok . " " . $stuff;
}

sub
doparts {
	my($car,$line) = @_;


	my($buf);
	my($stuff, $op);
	my ($tok);

	# Not sure why we didn't break out $rest for this case
	print " ${main::maxtoday} Parts: $line\n" if ($main::showlist =~ /,trace,/ );
# later do better; keep track of max expenses and max gains since known
	$main::minaudit = 0;  # should be able to refine this later
	$main::maxaudit = $main::maxaudit - 1;

	#($op, $tok, $stuff) = normalizeparts($car,$line);
	$buf = normalizeparts($car,$line);
# A question becomes, what should be left after normalize ?
#  For now we leave anything left in parentheses, and also NNNkg and NNNhp
#	print "$buf\n"  if ($main::showlist =~ /,rawpart,/ );
	($op, $tok, $stuff) = split(/\s/,$buf,3);
# N.B. if you don't specify ",3" you get only the first solitted element
	print "$op $tok :$stuff\n"  if ($main::showlist =~ /,rawpart,/ );

# Mostly gt3-game1 use of parentheses...
# Old "alias" throwback
#   (alias [R]FalconXR8)
# Tuner names
#   (Trial)
#   (HKS)
#   (Mine's)
#   (Amuse)
#   (from Blitz)
# "Daily wheels"
#   (daily)
# Colours (for wings and wheels)
#   (silver)
#   (Black)
#   (black)
#   (yellow)
#   (red)
#   (red 4x2 spokes)
# Asides
#   (don't fit)
# Alternate GT3 tire designations
#   (SSl/SSl)
#   (M/M)
#
# Also brief attempt in gt4-game2 to track the "codenames"
# I will simply remove those, however.
# buy Cougar :Rtrans("FC") 3clu("TR") Cr10000 Cr4600

# So...
#  buy Crossfire :NA1 NA2 Cr4700 Cr12000 chip N2O Cr1250 Cr5000
#  becomes $parts{"Crossfire:NA1"} = "Cr4700";
#  becomes $parts{"Crossfire:NA2"} = "Cr12000";
#  becomes $parts{"Crossfire:chip"} = "Cr4700";
#  becomes $parts{"Crossfire:N2O"} = "Cr5000";
#
# Assume Cr0 applies to all everything before it, i.e.
# buy redSkyline'67 :T-N1 T-N2 T-N3 Cr0 T-S1 T-S3 Cr4100 Cr5600
# becomes $parts{"redSkyline'67:T-N1"} = "Cr0";
# becomes $parts{"redSkyline'67:T-N2"} = "Cr0";
# becomes $parts{"redSkyline'67:T-N3"} = "Cr0";
# becomes $parts{"redSkyline'67:T-S1"} = "Cr4100";
# becomes $parts{"redSkyline'67:T-S3"} = "Cr5600";
#
# Except we want to use   car2495 redSkyline'67 Nissan Skyline 2000GT-B ...
# So...  $parts{"car2495:T-N1"} = "Cr0";
# etc...
#
	my($id);
	my(@prices);
	my(@parts);
	my(@tokens);
	my($t,$p);

	@prices = ();
	@parts = ();
	$id = findcarid($tok,$line);
	if (!defined($id)) {  # probably can't happen
		&warn("Cannot find carid for $tok, $line\n");
		return;
	}
	if ($stuff =~ /\bwheel/ || $stuff =~ /\bwing/ ) {
		# This test is very data dependent
		$t = "Cr0";
		if ( $stuff =~ /\b(Cr\d+)\b/ ) {
			$t = $1;
			$stuff =~ s/\bCr\d+\b//;
			$stuff =~ s/\s+/ /g;
		}
		$p = $id.":".$stuff;
		$main::carparts{$p} = $t;
		return;
	}
	$stuff =~ s/\s+\([^\)]*\)\s+/ /g;  # till we figure out how to process
	$stuff =~ s/\s+\([^\)]*\)/ /g;  # till we figure out how to process
	$stuff =~ s/\([^\)]*\)\s+/ /g;  # till we figure out how to process
	# Any remaining parentheses must be embedded in a "token"...
	$stuff =~ s/\([^\)]*\)//g;  # till we figure out how to process
	$stuff =~ s/\s+/ /g;
	$stuff =~ s/^\s+//g;  # sigh.  split will return empty tokens...
	$stuff =~ s/\s+$//g;
	@tokens = split(/\s+/,$stuff);
	for $t (@tokens) {
		if ($t =~ /^\d+hp$/i || $t =~ /\d+kg/i ||
			$t =~ /^\(/ || $t =~ /\)$/ ) {
			; # skip these "comments"
			# problem: we handle "(this comment)"
			#            but not "(this is a comment)"
			# Except that we removed them earlier...
		}
		elsif ($t eq "Cr0") {
			while (defined($p = shift(@parts)) ) {
				$p = $id.":".$p;
				$main::carparts{$p} = $t;
			}
		}
		elsif ($t =~ /^Cr\d/) {
			if (!defined($p = shift(@parts)) ) {
				if ($main::var{'checkparts'}) {
					&warn("No part for $t, $line\n");
				}
			}
			else {
				$p = $id.":".$p;
				$main::carparts{$p} = $t;
			}
		}
		else {
			$t =~ s/\s*\(.*\)\s*//;
			push @parts, $t;
		}
	}
	while (defined($p = shift(@parts)) ) {
		$p = $id.":".$p;
		if ($main::showlist =~ /,carpart,/ ||
			  $main::showlist =~ /,warn,/ ) {
			if ($main::var{'checkparts'}) {
				&warn("No price for $p, $line\n");
			}
			# currently a problem with "wheels" purchases
		}
		$main::carparts{$p} = "Cr0";
	}
}

sub
dobuy {
	my($line,$rest,$r1,$r2,$stuff) = @_;
	my($day,$sf,$fullname);

	print " ${main::maxtoday} Buy: $rest\n" if ($main::showlist =~ /,trace,/ );
	$main::minaudit = 0;
	$main::maxaudit = $main::maxaudit - 1;
	if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
		$sf = $1;
		if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
			$fullname = $2;
			$fullname =~ s/^[^\w\[]*//;
			$fullname =~ s/->\s.*//;
			$fullname =~ s/\s*$//;
			$fullname =~ s/^\s*//;

			my ($prize,$rest);
			$rest = $fullname;
			if ($rest =~ /\(prize.*\)/i) {
				# This lets us expand prize names of purchases
				$prize = $rest;
				$rest =~ s/^.*(\(prize)/$1/i; # )) for vi
				$prize =~ s/\(prize.*$//i;
				if (defined($main::fullprizenames{$prize}) ) {
					$fullname = $main::fullprizenames{$prize};
					$fullname .= $rest

				}
			}

			&getcar($sf,$fullname,$line);
			if ($main::showlist =~ /,buy,/i) {
				print "${main::maxtoday}:buy $sf - $fullname.\n";
			}
		}
		else {
			&getcar($sf,$sf,$line);
		}
	}
	elsif ($stuff =~ /^\s*parts\s+(\S+) /) {
		checkcar($1,$line);
		addcarlog($1,"",$line);
		doparts($1,$line);
	}
	elsif ($stuff =~ /^\s*wheels\s+/) {
		# In gt4, wheels are really a part
		;
	}
	else {
		&warn("Bad purchase: $line\n");
	}
}

sub
dodaynote {
	my($line,$rest,$r1,$r2) = @_;
	my($day,$stuff,$sf,$fullname);

	print " ${main::maxtoday} Daynote: $rest\n" if ($main::showlist =~ /,trace,/ );
	if (!&daycheck($r1) ) {
		&warn("Bad single day note(not ${main::maxtoday}): $_\n");
	}
	# grr... seems difficult to undef $1 ...
	if ($rest =~ /^buy\s+(.*)/ && defined($1)) {
		$stuff = $1;
		dobuy($line,$rest,$r1,$r2,$stuff);
	}
	if ($rest =~ /^win\s+(.*)/ && defined($1)) {
		dowin($line,$rest,$r1,$r2);
	}
	if ($rest =~ /^(change|wash)\s+(.*)/ && defined($1)) {
		my ($what) = ($1);
		my ($stuff) = ($2);
		$stuff =~ s/^\s*oil\s*//;
		$stuff =~ s/^\s*car\s*//;
		$main::minaudit -=
			$main::pragmas =~ /,gt3,/ ? 250 : 50;
#print "stuff:$stuff\n";
# this was cheating; eventually identifier will be checked
		if ($stuff =~ /^(\S+)/ && defined($1) ) {
			checkcar($1,$line);
			addcarlog($1,"",$line);
		}
		else {
			&warn("Bad $what: $line\n");
		}
	}
#print "rest:$rest\n";
	if ($rest =~ /^(perm\s+|){0,1}mod\s+(.*)/ && defined($2)) {
		# In gt3 we used "perm mod"
  		# 72   perm mod Trueno WR1 (Cr1,000)
		$stuff = $2;
#print "stuff:$stuff\n";
# this was cheating; eventually identifier will be checked
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
			# 117 mod car   Silvia'88K  WR1  Cr1000  ->1071kg
			checkcar($1,$line);
			addcarlog($1,"",$line);
			# Should we route this through buy?
			doparts($1,$line);
		}
		# try next token as car identifier
		elsif ($stuff =~ /^\s*(\S+)/ && defined($1) ) {
			checkcar($1,$line);
			addcarlog($1,"",$line);
			# Should we route this through buy?
			doparts($1,$line);
		}
		else {
			&warn("Bad mod: $line\n");
		}
	}
	if ($rest =~ /^sell\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "sell stuff:$stuff\n";
		print " ${main::maxtoday} Sell: $rest\n" if ($main::showlist =~ /,trace,/ );
		&sell($stuff);
	}
	# Unrecognized lines are effectively comments
	# Basic problem is a daynote is not in general logged to carlog.
	# But most instances are.
	# But, for instance, skip never is.
	if ( $main::pragmas =~ /,gt4,/ &&
		$rest =~ /skip.*Mission/ ) {
		# Missions might win some Cr
		$main::maxaudit = $main::MAXAUDIT;
	}
	# So, log skip...
	if ($rest =~ /^skip/ ) {
		if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
			# Some skips might relate to selected car (not "game")
			addcarlog($main::mentioned,$main::mentionedid,$line);		
		}
	}
	# Remaining oddity "buy" goes to carlog for bought car
	# game: carlog can end up with successive status lines.
	$main::mintoday = $r2;
	$main::maxtoday = $r2;
}

sub
donote {
	my($line) = @_;

	print " ${main::maxtoday} Note: $line\n" if ($main::showlist =~ /,trace,/ );
	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		addcarlog($main::mentioned,$main::mentionedid,$line);		
	}
}

$main::saveline = "";   # Kludge to support autoinclude
sub
getlog {  # get lines, closing includes
	no strict 'refs';
	#my($line) = @_;
	my($line);
	my($n);


	for (;;) {
		$line = <$main::fid>;
		if (!defined($line)) {
			close($main::fid);
			$n = $main::fid;
			$n =~ s/LOG//;
			if ( $n == 0 ) {
				return $line;
			}
			--$n;
			$main::fid = 'LOG' . "$n";
			if ($main::saveline ne "" ) {
				$line = $main::saveline;
				$main::saveline = "";
				return $line;
			}
		}
		else {
			return $line;
		}
	}
}

my($log,$daylimit);

$main::lastdateline = "";
%main::carlogs = ();
%main::carlogsi = ();   # Our future "proper" carlogs, by carid
%main::carcredits = ();
%main::cardebits = ();
%main::caraspecs = ();
%main::carbspecs = ();
%main::carbmachines = ();
%main::carbcourses = ();
%main::carbbattles = ();
sub
addcarlog {
	my($car,$id,$line) = @_;
	# if ($car eq "" || $car eq "no car selected") {
	#	return;
	#}
	# Arguably should use carid of $car...

	# Migrate towards providing both arguments explicitly...
	if (!defined($car) || $car eq "") {
		if (!defined($id) || $id eq "") {
			# This probably cannot happen
			&warn("Must define car or id: ".$line."\n");
			return;
		}
		$car = $main::carids{$id};  # optimized findcarid()
	}
	elsif ($car eq "none") {  # this happens in old games
		$car = "game";   # assume game log is correct
		$id = "";
	}
	if (!defined($id) || $id eq "") {
		$id = findcarid($car,$line);
	}
	if (!defined($main::carlogs{$car})) {
		$main::carlogs{$car} = "";
		if ($main::showlist =~ /,verbose,/) {
			$main::carlogs{$car} = $main::lastdateline;
		}
	}
	#$id = findcarid($car,$line);
	# Turns out we try to verbose log lots of lines to non-existent car
	if (defined($id) && !defined($main::carlogsi{$id})) {
		$main::carlogsi{$id} = "";
		if ($main::showlist =~ /,verbose,/) {
			$main::carlogsi{$id} = $main::lastdateline;
		}
	}
	if ($line !~ /^\s*$/) {
		$main::carlogs{$car} .= $line."\n";
		$main::carlogsi{$id} .= $line."\n" if defined($id);
	}
}
	

while ( defined($ARGV[0]) ) {
	my($temp);
	if ( $ARGV[0] =~ /^show=/i ) {
		$temp = $ARGV[0];
		$temp =~ s/^show=//i;	
		$temp = ",$temp,";
		$temp =~ s/,+/,/g;
		# Note $temp can have several options in it
		# Eventually we decided "s" can be added to all options
		$temp =~ s/s,/,/g;
		# Expand a few lazy alternatives we allow
		$temp =~ s/,partstotal,/,carpartstotal,/;
		$temp =~ s/,part,/,carpart,/;
		$temp =~ s/,price,/,carprice,/;
		$temp =~ s/,audit,/,audita,auditb,auditc,/;
		# Would be nice to make plurals optional
		$main::showlist .= ",$temp,";
	}
	elsif (!defined($log)) {
		$log = $ARGV[0];
	}
	elsif (!defined($daylimit)) {
		if ($ARGV[0] =~ /^\d+$/) {
			$daylimit = $ARGV[0];
		}
		else {
			$temp = $ARGV[0];
			# change something like "Jan 10"
			#   into a pattern, like...
			# /^Jan[^0-9]*10/
			$temp =~ s/,/ /g;
			$temp =~ s/ +/[^0-9]*/;
			$temp =~ s/$/\\b/;
			$temp =~ s/^/^/;
			$main::enddate = $temp;
			
		}
	}
	shift @ARGV;
}
if (!defined($log)) {
	$log = "/dev/stdin";
}
if (!defined($daylimit)) {
	$daylimit = -1;
}
if (!defined($main::showlist)) {
	$main::showlist = ",garage,";
}
$main::showlist =~ s/,all,/pragma,buy,sell,sale,sold,carid,garage,/;

$main::showvalid =
	",all" . ",audit" . ",audita" . ",auditb" . ",auditc" .
	",buy" . ",carid" . ",carlog" . ",caridlog" .
	",carpart" . ",carpartstotal" . ",carprice" .
	",diffa" .  ",diffan" .  ",diffai" .
	",diffb" .  ",diffbn" .  ",diffbi" .
	",diffc" .  ",diffcn" .  ",diffci" .
	",echo" .  ",event" .  ",garage" .  ",heuristic" .
	",licence" . ",license" .
	",mod" . ",model" .
	",origin" . ",pragma" .
	",price" . ",prize" .  ",rawevent" . ",rawpart" .
	",sale" . ",sell" . ",sold" .
	",trace" . ",var" . ",verbose" . ",warn" .
	",";

my ($opt, $c);
$c = 0;
for $opt (split(/,/, $main::showlist)) {
#print "opt=$opt\n";
	next if ($opt eq "");
	if ($main::showvalid !~ /,$opt,/) {
		&warn("Invalid show= option: $opt\n");
		++$c
	}
}
exit 2 if ($c > 0);


{
	no strict 'refs';
	if (!open($main::fid,"<$log") ) {
		die "Cannot open log $log.\n";
	}
}


# emulate initial "select car game"
$main::mentioned = "game";
$main::selected = "game";
if (!defined(findcarid("game","")) || 
	findcarid("game","") eq "" ) {
	&newautocarid("game","");
}
$main::mentionedid = findcarid("game","");
$main::selectedid = findcarid("game","");
#while ($main::mintoday <= $daylimit && <LOG>) {
while (defined($_ = &getlog())) {
	my($line) = $_;
	my($license,$r1,$r2,$rest);
	my($sp);

	print "$line" if ($main::showlist =~ /,trace,/ ||
			$main::showlist =~ /,echo,/ );

	last if ($main::done);
	last if ($daylimit > 0 && $main::mintoday > $daylimit);
	$line =~ s/\n//g;
	$license = $line;
	$license =~ s/^.{10}//;
	$license =~ s/(\S+)\s.*/$1/;
	# It is not clear $r1 and $r2 should default to empty
	$r1 = "";
	$r2 = "";
	$rest = $line;
	if ( $line =~ /^[A-Z]/) {
		# Assume a date line; process later
		;
	}
	elsif ( $line =~ /^ {9,9}/ ) {
		# line beginning with 9 spaces assumed to be comment
		;
	}
#	elsif ( $line =~ /^([ \d]{3,3}\d)\-(\d[ \d]{3,3})\s*(.*)/ ) {
#		# Stupid way to try to match pattern...
#		# day range (numbers max 4 digits)
	elsif ( $line =~ /^\s*(\d+)\-(\d+)\b\s*(.*)/ ) {
		$r1 = $1;
		$r2 = $2;    # n.b. must grab all $N before doing other subs
		$rest = $3;
		$r1 =~ s/\s//g;
		$r2 =~ s/\s//g;
	}
	elsif ( $line =~ /^\s*(\d+)\s*\+(\d+)(.*)/ ) {
		# new range indication by +increment
		$r1 = $1;
		$r2 = $2;    # n.b. must grab all $N before doing other subs
		$rest = $3;
		$r2 += $r1;
	}
	elsif ( $line =~ /^\s*(\d+)\s+(.*)/ ) {
		# single day
		$r1 = $1;
		$rest = $2;
		$r2 = $r1;
	}
	elsif ( $line =~ /^\s*(\d+)\s*(.*)/ ) {
		# single day, likely empty, also matches "22Why no space there?"
		$r1 = $1;
		$rest = $2;
		$r2 = $r1;
	}
	$rest =~ s/^\s*//;

	if ($r2 ne "" && $main::var{'includesdone'} == 0) {
		&heuristicinclude($log,$line);
		$main::var{'includesdone'} = 1;
		next;
	}

	# Second parse
	$sp = $main::var{'commentspacecount'};
	if ( $line !~ /^\s*\d+\s/ && $line =~ /^[\s]{$sp,$sp}/ ) {
		# For old log compatibility, $sp can be < 9
		# But assume a leading number indicates an entry
		&donote($line);
	}
	elsif ( $line =~ /^\s*note/i ) {
		&donote($line);
	}
	elsif ( $line =~ /^\s*pragma\b/i ) {
		&dopragma($line);
	}
	elsif ( $line =~ /^\s*include\b/i ) {
		&doinclude($line);
	}
	elsif ( $line =~ /^\s*define\b/i ) {
		&dodefine($line);
	}
	elsif ( $line =~ /^[A-Z]/) {
		&dodateline($line);
	}
	elsif ( $line =~ /^\s*cardef\b/i ) {
		&docardef($line);
	}
	elsif ( $line =~ /^\s*uncardef\b/i ) {
		&douncardef($line);
	}
	elsif ( $line =~ /^\s*setvar\b/i ) {
		&dosetvar($line);
	}
	elsif ( $line =~ /^ {9,9}/ ) {
		# line beginning with 9 spaces assumed to be comment
		# ORLY?
		;
	}
	elsif ( $rest =~ /^rem/i ) {
		# I had used this as "day note comments"...
		&donote($line);
	}
	elsif ( $rest =~ /^[\(]* *Cr[0-9]/ || 
		$rest =~ /^\s*->/ ) {  # ) for vi
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^power\b/i ) {
		$rest =~ s/^power\s*//i;  # process stats on power off lines
		$rest =~ s/^off\s*//i;
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^reset\b/ ) {
		$rest =~ s/^reset\s*//;  # process stats on reset lines
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^save\b/ ) {
		$rest =~ s/^save\s*//;  # process stats on save lines
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^select\b/ ) {
		&doselect($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^buy\b/ ||
		$rest =~ /^change\b/ ||
		$rest =~ /^fit\b/ ||
		$rest =~ /^mod\b/ ||
		$rest =~ /^perm\b/ ||
		$rest =~ /^sell\b/ ||
		$rest =~ /^skip\b/ ||
		$rest =~ /^wash\b/ ||
		$rest =~ /^finito\b/ ||
		$rest =~ /^win\b/ ) {
		&dodaynote($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $rest =~ /^licen[sc]e/ ) {
		# Would be nice to recognize  "8-9    B8 br"
		# B8 should be defined by "racedefs"
		if ($line =~ /^\s*\d+\s+\+\d+/ ) {
			# for historical reasons, use $r2-1
			&dolicenseline($line,$rest,$r1,$r2-1);
			# at least until we reason it out
		}
		else {
			&dolicenseline($line,$rest,$r1,$r2);
		}
	}
	elsif ( $main::var{'licensepatterns'} ne "" &&
		$rest =~ /^$main::var{'licensepatterns'}/ ) {
		&dolicenseline($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\-\d+\s+/ ) {
		# 104-107  R32Skyline'89GT-R Sunday sw27to18      Demio(dup)
		&doseriesline($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\s+\+\d+/ ) {
		# for historical reasons, use $r2-1
                # 231 +5  greyEtype   P/WC   2nd46to(34),19,16,10,5   none
		&doseriesline($line,$rest,$r1,$r2-1);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\s+/ ) {
		# Assume anything else with a day number is a seriesline ?
		if ( $main::var{'noincserieslines'} ) {
			&doseriesline($line,$rest,$r1,$r2);
		}
		else {
			&dodaynote($line,$rest,$r1,$r2);
		}
	}
	elsif ( $line =~ /^\s{0,5}(\d+)\s*$/ ) {
		# We had used lines with just a single day before
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $line =~ /^\s{0,20}\d/ ) {
		&warn("Unrecognized line: $line\n");
	}
	else {
		# Surprisingly, lines beginning "#' will fall through to here
		&donote($line);
	}
#print $main::maxtoday," AFTER: ",$rest,"\n";
}
close ($main::fid);

sub
expand {
	my($s) = @_;

	$s;
}

if ($main::showlist =~ /,pragma,/ ) {
	printf("%s\n", $main::pragmas);
}
if ($main::showlist =~ /,rawevent,/ ) {
	my($i);
	for ($i = 0; $i <= $#main::events; ++$i) {
		printf("%s\n", &expand($main::events[$i]) );
	}
}
if ($main::showlist =~ /,event,/ ) {
	my($i,$prev,@sorted);
	@sorted = sort @main::events;
	$prev = "";
	for ($i = 0; $i <= $#sorted; ++$i) {
		if ($sorted[$i] ne $prev) {
			printf("%s\n", &expand($sorted[$i]) );
			$prev = $sorted[$i];
		}
	}
}
if ($main::showlist =~ /,prize,/ ) {
	my($i,$prev,@sorted);
	@sorted = sort @main::prizes;
	$prev = "";
	for ($i = 0; $i <= $#sorted; ++$i) {
		if ($sorted[$i] ne $prev) {
			printf("%s\n", &expand($sorted[$i]) );
			$prev = $sorted[$i];
		}
	}
}
if ($main::showlist =~ /,carid,/ ) {
# Would really like to see what $main::carid{$k} is...
# Sigh.  Might really like ,carid, versus ,carids,
	my($k);
	foreach $k (sort caridsub keys %main::carids) {
		printf("%s %s %s (%s)\n", $k, $main::carids{$k},
			$main::carnames{$k}, $main::carstates{$k});
	}
}
if ($main::showlist =~ /,price,/ || $main::showlist =~ /,carprice,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carprices) {
		printf("%s %s %s\n", $k, $main::carids{$k},
			$main::carprices{$k});
	}
}

sub
tocredits {  # N.B. money, not attributions/accolades
	my ($num) = @_;
	my ($portion,$remain);
	my ($sign,$s);

	$sign = "";
	$remain = $num;
	if ($remain < 0) {
		$sign = "-";
		$remain = 0 - $remain;
	}
	$s = "";
	for ( ;; ) {
		$portion = $remain;
		$remain = int ( $remain / 1000);
		$portion -= $remain * 1000;
		if ($remain > 0) {
			$s = sprintf(",%3.3d", $portion) . $s;
		}
		else {
			$s = sprintf("Cr%d", $portion) . $s;
		}
		last if ($remain <= 0);
	}
	return $sign . $s;
}
sub
fromcredits {  # N.B. money, not attributions/accolades
	my ($s) = @_;
	my ($num);

	$s =~ s/^Cr//i;
	$s =~ s/,//g;
	$s =~ s/\D+//;   # tolerate Cr12,673,210  (?)
	$num = 0 + $s;
	return $num;
}
	
if ( $main::showlist =~ /,carpart,/ ||
		$main::showlist =~ /,carpartstotal,/ ) {
	my($k,$cark,$car);
	my($prevk,$total,$prevcar);
	$prevk = "";
	$prevcar = "";
	$total = 0;
	foreach $k (sort caridcolonsub keys %main::carparts) {
		$cark = $k;
		$cark =~ s/:.*//;
		$car = $main::carids{$cark};
		$car = "WHAT?" if (!defined($car));
		if ( $cark ne $prevk ) {
			if ($prevk ne "" &&
				   $main::showlist =~ /,carpartstotal,/ ) {
				printf("%s %s:Total %s\n", $prevcar, $prevk,
					&tocredits($total) );
			}
			$prevk = $cark;
			$prevcar = $car;
			$total = 0;
		}
		if ( $main::showlist =~ /,carpart,/ ) {
			printf("%s %s %s\n", $car, $k, $main::carparts{$k});
		}
		$total += &fromcredits($main::carparts{$k});
	}
	if ($prevk ne "" && $main::showlist =~ /,carpartstotal,/ ) {
		printf("%s %s:Total %s\n", $prevcar, $prevk,
			&tocredits($total) );
	}
	
}
if ($main::showlist =~ /,garage,/ ) {
	my($k,$i);
	$i = 0;
	foreach $k (sort caridsub keys %main::carids) {
		# Perhaps we should use eq "got"
		if ($main::carstates{$k} ne "sold" &&
			$main::carstates{$k} ne "alias") {
			printf("%3d %s\n", $i+1, $main::carnames{$k});
			++$i;
		}
	}
}
if ($main::showlist =~ /,licen[sc]e,/ ) {
	my($i,@sorted);
	@sorted = sort lidsub keys %main::lresults;
	for ($i = 0; $i <= $#sorted; ++$i) {
		printf("%s: %s\n", $sorted[$i], $main::lresults{$sorted[$i]} );
	}

	
}
if ($main::showlist =~ /,origin,/ ) {
	# Shows origins based on carid
	my($i,@sorted);
	@sorted = sort caridsub keys %main::origin;
	for ($i = 0; $i <= $#sorted; ++$i) {
		printf("%s - %s\n", $sorted[$i], $main::origin{$sorted[$i]} );
	}
}
if ($main::showlist =~ /,model,/ ) {
	# Shows models based on carid
	my($i,@sorted);
	@sorted = sort caridsub keys %main::carmodels;
	for ($i = 0; $i <= $#sorted; ++$i) {
	      printf("%s - %s\n", $sorted[$i], $main::carmodels{$sorted[$i]} );
	}
}
# %main::carbspecs = ();
# %main::carbmachines = ();
# %main::carbcourses = ();
# %main::carbbattles = ();
sub
bspecstring {
	my ($car) = @_;
	my ($t, $m, $c, $b) = ("", 0, 0, 0);
	$t = $main::carbspecs{$car} if (defined($main::carbspecs{$car}));
	$m = $main::carbmachines{$car} if (defined($main::carbmachines{$car}));
	$c = $main::carbcourses{$car} if (defined($main::carbcourses{$car}));
	$b = $main::carbbattles{$car} if (defined($main::carbbattles{$car}));
	if ($t ne "") {
		return $t."/".$m."/".$c."/".$b ;
	}
	return "";
}
if ($main::showlist =~ /,carlog,/ && $main::showlist !~ /,caridlog,/ ) {
	my($i,@sorted);
	@sorted = sort keys %main::carlogs;
	# Eventually carlogs should be looked up by actual carid
	for ($i = 0; $i <= $#sorted; ++$i) {
		my($sf,$ci,$org,$price);
		$sf = $sorted[$i];
		next if ($sf eq "");  # Ignore logs to empty car name
		#$ci = $main::carid{$sf};
		$ci = findcarid($sf,"");  # Using "" instead of $line?
		if (defined($ci) && defined($main::origin{$ci}) ) {
			# This can be the wrong origin
			# (if a cardef matches a shortname?)
			# That will be fixed if carlog is by carids...
			$org = $main::origin{$ci}."\n";
			$price = 0;
#			if (defined($main::carprices{$ci})) {
#				# Duh.  Why does prices have Cr?
#				$price = $main::carprices{$ci};
#				$price =~ s/,//g;
#				$price =~ s/Cr//;
#			}
		}
		else {
			$ci = "";
			$org = "";
			$price = 0;
		}
# %main::caraspecs = ();
		my ($c, $d, $a, $b) = ("","","","");
		if (defined($main::carcredits{$sorted[$i]} ) ) {
			$c = " " . tocredits($main::carcredits{$sorted[$i]});
			# Assert cardebits entry must have been defined
			$d = " (".tocredits($price +
					$main::cardebits{$sorted[$i]}).")";
		}
		if (defined($main::caraspecs{$sorted[$i]} ) ) {
			$a = " A:" . $main::caraspecs{$sorted[$i]};
		}
		$b = bspecstring($sorted[$i]);
		$b = " B:".$b if ($b ne "");
		$ci = " ".$ci if ($ci ne "");
		printf("%s:%s%s%s%s%s\n", $sf, $ci, $c, $d, $a, $b );
		printf("%s", $org );
		printf("%s\n", $main::carlogs{$sorted[$i]} );
	}
}
if ($main::showlist =~ /,caridlog,/ ) {
	my($i,@sorted);
	# Sorted by carid, i.e. acquisition order (not quite?)
	@sorted = sort caridsub keys %main::carlogsi;
	# Eventually carlogs should be looked up by actual carid
	for ($i = 0; $i <= $#sorted; ++$i) {
		my($sf,$id,$org,$price);
		$id = $sorted[$i];
		$sf = $main::carids{$id};  # should be defined?
		if (!defined($sf) || $sf eq "") {
			&warn("No carlist entry for ".$id."\n");
			next;
		}
		$org = "";
		$org = $main::origin{$id}."\n" if(defined($main::origin{$id}));
# %main::caraspecs = ();
		$price = 0;
#		if (defined($main::carprices{$id})) {
#			# Duh.  Why does prices have Cr?
#			$price = $main::carprices{$id};
#			$price =~ s/,//g;
#			$price =~ s/Cr//;
#		}
		my ($c, $d, $a, $b) = ("","","","");
		if (defined($main::carcredits{$id} ) ) {
			$c = " " . tocredits($main::carcredits{$sorted[$i]});
			# Assert cardebits entry must have been defined
			$d = " (". tocredits($price+$main::cardebits{$id}).")";
		}
		if (defined($main::caraspecs{$id} ) ) {
			$a = " A:" . $main::caraspecs{$id};
		}
		$b = bspecstring($id);
		$b = " B:".$b if ($b ne "");
		#printf("%s:%s%s%s%s\n", $sf, $c, $d, $a, $b );
		printf("%s: %s%s%s%s%s\n", $sf, $id, $c, $d, $a, $b );
		printf("%s", $org );
		printf("%s\n", $main::carlogsi{$id} );
	}
}

if ($main::showlist =~ /,var,/ ) {
	my($i,@sorted);
	@sorted = sort keys %main::var;
	for ($i = 0; $i <= $#sorted; ++$i) {
	      printf("%s - %s\n", $sorted[$i], $main::var{$sorted[$i]} );
	}
}
