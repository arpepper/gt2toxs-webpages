head	1.102;
access;
symbols;
locks
	arpepper:1.102; strict;
comment	@# @;


1.102
date	2021.07.02.11.01.51;	author arpepper;	state Exp;
branches;
next	1.101;

1.101
date	2021.07.01.13.54.46;	author arpepper;	state Exp;
branches;
next	1.100;

1.100
date	2021.07.01.01.49.59;	author arpepper;	state Exp;
branches;
next	1.99;

1.99
date	2021.06.30.23.16.59;	author arpepper;	state Exp;
branches;
next	1.98;

1.98
date	2021.06.30.22.31.58;	author arpepper;	state Exp;
branches;
next	1.97;

1.97
date	2021.06.30.22.05.44;	author arpepper;	state Exp;
branches;
next	1.96;

1.96
date	2021.06.30.20.32.00;	author arpepper;	state Exp;
branches;
next	1.95;

1.95
date	2021.06.30.20.01.34;	author arpepper;	state Exp;
branches;
next	1.94;

1.94
date	2021.06.30.19.24.54;	author arpepper;	state Exp;
branches;
next	1.93;

1.93
date	2021.06.30.02.25.36;	author arpepper;	state Exp;
branches;
next	1.92;

1.92
date	2021.06.29.22.58.32;	author arpepper;	state Exp;
branches;
next	1.91;

1.91
date	2021.06.29.22.36.00;	author arpepper;	state Exp;
branches;
next	1.90;

1.90
date	2021.06.29.20.23.59;	author arpepper;	state Exp;
branches;
next	1.89;

1.89
date	2021.06.29.17.05.16;	author arpepper;	state Exp;
branches;
next	1.88;

1.88
date	2021.06.29.15.21.40;	author arpepper;	state Exp;
branches;
next	1.87;

1.87
date	2021.06.29.11.37.27;	author arpepper;	state Exp;
branches;
next	1.86;

1.86
date	2021.06.29.02.56.51;	author arpepper;	state Exp;
branches;
next	1.85;

1.85
date	2021.06.29.02.37.58;	author arpepper;	state Exp;
branches;
next	1.84;

1.84
date	2021.06.29.01.36.19;	author arpepper;	state Exp;
branches;
next	1.83;

1.83
date	2021.06.28.22.00.46;	author arpepper;	state Exp;
branches;
next	1.82;

1.82
date	2021.06.28.21.18.54;	author arpepper;	state Exp;
branches;
next	1.81;

1.81
date	2021.06.28.20.27.22;	author arpepper;	state Exp;
branches;
next	1.80;

1.80
date	2021.06.28.00.52.30;	author arpepper;	state Exp;
branches;
next	1.79;

1.79
date	2021.06.27.21.56.10;	author arpepper;	state Exp;
branches;
next	1.78;

1.78
date	2021.06.26.01.35.27;	author arpepper;	state Exp;
branches;
next	1.77;

1.77
date	2021.06.25.21.44.45;	author arpepper;	state Exp;
branches;
next	1.76;

1.76
date	2021.06.25.20.32.26;	author arpepper;	state Exp;
branches;
next	1.75;

1.75
date	2021.06.24.12.38.48;	author arpepper;	state Exp;
branches;
next	1.74;

1.74
date	2021.06.23.14.06.07;	author arpepper;	state Exp;
branches;
next	1.73;

1.73
date	2021.06.23.02.08.10;	author arpepper;	state Exp;
branches;
next	1.72;

1.72
date	2021.06.22.02.15.42;	author arpepper;	state Exp;
branches;
next	1.71;

1.71
date	2021.06.22.02.04.08;	author arpepper;	state Exp;
branches;
next	1.70;

1.70
date	2021.06.22.01.36.00;	author arpepper;	state Exp;
branches;
next	1.69;

1.69
date	2021.06.21.23.09.54;	author arpepper;	state Exp;
branches;
next	1.68;

1.68
date	2021.06.21.20.46.35;	author arpepper;	state Exp;
branches;
next	1.67;

1.67
date	2021.06.21.18.45.20;	author arpepper;	state Exp;
branches;
next	1.66;

1.66
date	2021.06.21.12.44.01;	author arpepper;	state Exp;
branches;
next	1.65;

1.65
date	2021.06.21.02.14.00;	author arpepper;	state Exp;
branches;
next	1.64;

1.64
date	2021.06.21.01.28.05;	author arpepper;	state Exp;
branches;
next	1.63;

1.63
date	2021.06.21.00.53.27;	author arpepper;	state Exp;
branches;
next	1.62;

1.62
date	2021.06.20.23.34.36;	author arpepper;	state Exp;
branches;
next	1.61;

1.61
date	2021.06.20.23.09.45;	author arpepper;	state Exp;
branches;
next	1.60;

1.60
date	2021.06.20.22.35.50;	author arpepper;	state Exp;
branches;
next	1.59;

1.59
date	2021.06.20.22.18.22;	author arpepper;	state Exp;
branches;
next	1.58;

1.58
date	2021.06.18.13.04.40;	author arpepper;	state Exp;
branches;
next	1.57;

1.57
date	2021.06.11.22.42.31;	author arpepper;	state Exp;
branches;
next	1.56;

1.56
date	2021.05.25.22.21.54;	author arpepper;	state Exp;
branches;
next	1.55;

1.55
date	2021.05.22.01.52.18;	author arpepper;	state Exp;
branches;
next	1.54;

1.54
date	2021.05.22.01.30.39;	author arpepper;	state Exp;
branches;
next	1.53;

1.53
date	2021.05.22.00.51.13;	author arpepper;	state Exp;
branches;
next	1.52;

1.52
date	2021.05.21.23.08.33;	author arpepper;	state Exp;
branches;
next	1.51;

1.51
date	2021.05.21.22.27.28;	author arpepper;	state Exp;
branches;
next	1.50;

1.50
date	2021.05.21.21.17.42;	author arpepper;	state Exp;
branches;
next	1.49;

1.49
date	2021.05.21.19.22.20;	author arpepper;	state Exp;
branches;
next	1.48;

1.48
date	2021.05.21.19.05.10;	author arpepper;	state Exp;
branches;
next	1.47;

1.47
date	2021.04.14.22.01.01;	author arpepper;	state Exp;
branches;
next	1.46;

1.46
date	2021.04.14.21.53.01;	author arpepper;	state Exp;
branches;
next	1.45;

1.45
date	2021.04.14.20.57.52;	author arpepper;	state Exp;
branches;
next	1.44;

1.44
date	2021.04.14.19.54.09;	author arpepper;	state Exp;
branches;
next	1.43;

1.43
date	2021.04.07.20.52.43;	author arpepper;	state Exp;
branches;
next	1.42;

1.42
date	2021.04.06.04.10.38;	author arpepper;	state Exp;
branches;
next	1.41;

1.41
date	2021.04.06.02.50.36;	author arpepper;	state Exp;
branches;
next	1.40;

1.40
date	2021.04.06.02.27.06;	author arpepper;	state Exp;
branches;
next	1.39;

1.39
date	2021.04.05.23.00.57;	author arpepper;	state Exp;
branches;
next	1.38;

1.38
date	2021.04.05.22.27.26;	author arpepper;	state Exp;
branches;
next	1.37;

1.37
date	2021.04.05.21.27.50;	author arpepper;	state Exp;
branches;
next	1.36;

1.36
date	2021.04.03.20.28.27;	author arpepper;	state Exp;
branches;
next	1.35;

1.35
date	2021.03.30.01.22.56;	author arpepper;	state Exp;
branches;
next	1.34;

1.34
date	2021.03.17.17.15.48;	author arpepper;	state Exp;
branches;
next	1.33;

1.33
date	2021.03.16.01.57.43;	author arpepper;	state Exp;
branches;
next	1.32;

1.32
date	2021.03.16.01.30.08;	author arpepper;	state Exp;
branches;
next	1.31;

1.31
date	2021.03.15.20.42.40;	author arpepper;	state Exp;
branches;
next	1.30;

1.30
date	2021.03.15.00.55.41;	author arpepper;	state Exp;
branches;
next	1.29;

1.29
date	2021.03.10.02.24.37;	author arpepper;	state Exp;
branches;
next	1.28;

1.28
date	2021.03.10.02.09.31;	author arpepper;	state Exp;
branches;
next	1.27;

1.27
date	2021.03.10.00.02.05;	author arpepper;	state Exp;
branches;
next	1.26;

1.26
date	2021.03.09.20.23.32;	author arpepper;	state Exp;
branches;
next	1.25;

1.25
date	2019.07.15.17.36.14;	author arpepper;	state Exp;
branches;
next	1.24;

1.24
date	2011.02.20.03.03.35;	author arpepper;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.24.18.44.40;	author arpepper;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.17.21.05.43;	author arpepper;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.17.19.50.01;	author arpepper;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.17.05.08.29;	author arpepper;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.16.06.44.46;	author arpepper;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.16.06.09.44;	author arpepper;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.16.05.51.16;	author arpepper;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.16.04.24.35;	author arpepper;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.15.02.19.21;	author arpepper;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.15.01.50.42;	author arpepper;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.15.01.36.48;	author arpepper;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.15.01.21.02;	author arpepper;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.15.01.04.43;	author arpepper;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.14.02.25.37;	author arpepper;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.14.01.35.29;	author arpepper;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.14.01.08.29;	author arpepper;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.14.00.51.34;	author arpepper;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.12.02.39.33;	author arpepper;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.12.02.26.07;	author arpepper;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.12.02.15.49;	author arpepper;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.12.01.32.46;	author arpepper;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.12.01.11.19;	author arpepper;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.12.00.24.33;	author arpepper;	state Exp;
branches;
next	;


desc
@Started with gt3garage.

Note: this should be changed (and RCS'd) under ~arpepper, with tested
updates copied to ~gt2toxs and eventually to gt2toxs-webpages.git
@


1.102
log
@Create $main::mentioned as a hack to make carlog,verbose work even
when "select" is not being used in the game.
@
text
@#!/usr/bin/perl -w

#
# gt4garage [show=<options>] logname [simday]
#
# gt4garage produces a garage listing for the given simday (default last day)
#   But see also show=
#
# By using suitable gt1-racedefs and gt2-racedefs (and for a long time
#   gt3-racedefs), gt1 and gt2 (and gt3) logs can be processed too.
#   A heuristic autoinclude means an explicit include is not required.
#   A new define of "fullprizename" allows some prize checking, and
#     "prettier" garage entries.
#   Various "setvar" values handle differences in game day counter behaviour
#     and also changes in logging style.
#   Logs for ARRI (Alfa Romeo Racing Italiano) can even be processed.
#     (Most garage entries in that case are actually clothing).
#
# Audits:
#   Crudely checks the real "date lines"
#   lists resultant garage entries (obtained via buy,win,sell)
#                              win was implied in "old-style" event entries
#       shows "prize origin" of garage entries
#       verifies car counts given in status lines
#   day counter
#   license test medals (G/S/B)  (requires interpreting license lines)
#   car selection for events (a biggie for catching mistakes caused by copying)
#   Events must match definitions listed, usually in included gtN-racedefs
#       (which then become prize indicators via "next" and "win")
#   Verifies that "buy parts" and "mod car" have balanced items and Cr entries.
#
# Also:
#   "show=carlog" (optional "show=verbose,carlog")
#     produces output listed for each recognized car
#   "show=licen[sc]e" tracks license progress
#   "show=rawevents"
#   "show=events"
#   "show=prizes"
#       dump stored tables of event/prizes; seem redundant
#   "show=sold" "show=sell" "show=sales" "show=buy"
#     somewhat haphazardly attempt to track those car transactions
#         E.g. "show=sold,sell,sales,buy"
#         Not so haphazard?
#         sell => show intended sell lines  e.g.  sell excess DB7 excess Demio
#         sales => show parsed portions of those lines  e.g. sell -1 DB7
#         sold => track actual transitions (sold!)
#   "show=origin" shows origins based on carid table (i.e. shows creating line)
#   "show=carids" dumps internal table of carids; useful when you need them
#
#   "show=trace"  debugging print of all lines, and partial walkthrough of many
#   "show=rawparts" dumps processed version of all "buy parts" and "mod" lines
#   "show=mods" really debugging; shows extracted power and weight mod notes
#   "show=carprices" dumps carprices table (also "show=prices")
#   "show=carparts" dumps carparts table (also "show=parts")
#   "show=carpartstotals" gives per-car parts cost (also "show=partstotals")
#
#   "show=vars" dumps the "setvar" variable values (debugging)
#   "show=warn" tries to add extra warnings
#   "show=pragmas"  FWIW - some "pragma" evaluation will in future
#                              be replaced by use of "setvar"
#   "show=garage" is the default
#
# Now also:
#   setvar variable = value
#      - just numbers for now?
#   Primarily to allow "gt4garage ARRI-game2" to work
#       setvar minlicenseinc = 0
#       setvar maxlicenseinc = 1
#
# Future possibilities (getting few)
#   Validate, fix if necessary, autoinclude wrt nested includes
#   Credit sanity (increased or decreased as appropriate).
#   Percentage sanity; should never decrease.
#   A: and B:  should only ever increase, but they are gt4-specific
#      Patterns could possibly be specified by setvar
#      Difficult for %
#   Parts availability for particular cars?  (Would seem to be difficult)
#   Prize legitimacy could conceivably be defined in gtN-racedefs
#   Prize origin should be indicated for a "carlog" entry.
#


require 5.002;
use strict;

sub
warn {
	print @@_;
}

%main::var = ();	# variables to set along with racedefs
$main::var{'includesdone'} = 0;   # allow us to do autoinclude

# This set arguably relates to the day counter behaviour for different games
$main::var{'minlicenseinc'} = 1;
$main::var{'maxlicenseinc'} = 1;
$main::var{'minseriesinc'} = 1;
$main::var{'maxseriesinc'} = 1;

$main::var{'maxunknownracedays'} = 0;  # set to 1 for GT1

# This set allow flexibility in data
# But in some cases could be argued to reflect chosen log style
$main::var{'allowanyprize'} = 0;
$main::var{'seriesdelim'} = "/";    # If this is e.g. "(" bad things happen
$main::var{'trackdelim'} = "/";    # If this is e.g. "(" bad things happen

# The following set really just reflect changes in logging style
$main::var{'autocarids'} = 0;
$main::var{'autoselectcarids'} = 0;
# We would like to use 9 for the following, 
#   but we need smaller for some old GT1 and GT2 logs. 
$main::var{'commentspacecount'} = 4;  # was used in older logs; 9 for newer
# "noincserieslines = 1"  interprets lines with no increment as series lines
$main::var{'noincserieslines'} = 1;  # 0 for GT1 (had many single day notes)
# We want to process old GT1/2 logs where license was implied...
$main::var{'licensepatterns'} = "";  # kludgish for GT1/2 (add patterns)
$main::var{'seriescarcruft'} = "";  # kludge for GT1/2 (add patterns)
$main::var{'checkparts'} = 1;   # 0 for GT1, but could set in individual logs

$main::seriescarcruft = "";
@@main::seriescarcrufts = ();

$main::done = 0;
$main::enddate = "";
$main::mintoday = 0;
$main::maxtoday = 1;
$main::selected = "";    # track current car, explicitly set using "select"
$main::mentioned = "";   # allow carlog,verbose to work even if select not used
$main::pragmas = ",";

@@main::cardata = ();   # now we initialize all data via "buy" or "win" in log
@@main::prizes = ();
@@main::events = ();
$main::prize_event = ""; # pending event from "next", for "win"

%main::fullprizenames = ();   # Mostly to generate pretty GT1 garages

%main::league = ();
%main::series = ();
%main::seriesmindays = ();
%main::seriesmaxdays = ();
$main::maxserieslen = 6;
%main::track = ();

%main::carlist = ();  # now carlist is just an error suppressor
%main::origin = ();  # map carid to line which created it
%main::carid = ();  # map usual shortform to a carid (can conflict?)
$main::ncarsnow = 0;  # set to count when changes

# Discovered following defined only by use
%main::carids = ();  # see findcarid
%main::carnames = ();
%main::cardefs = ();  # special names created via "cardef" command
%main::carstates = ();
%main::carlist = (); # shortforms
%main::carprices = ();

%main::carmodels = ();  # Devoid of colour, price, etc

#
# proposed new scheme would just mark things as sold, not shuffle arrays
#
#@@main::newgarage = ();
#@@main::desc = ();
#@@main::parts = ();
#@@main::fitted = ();
#@@main::sold = ();
#$main::lastid = 0;
#%main::aliases = ();     # returns "carid", index into above arrays

		
my($name);
while (@@main::cardata) {
# This (i.e. cardata) is empty for later games
	$name = shift @@main::cardata;
	$main::carlist{$name} = $name;
};

sub
lidsub() {  # sort license test names B1..A1..IB1..IA1..S1..S16
	my($n1, $n2, );

	$n1 = $a;
	$n1 =~ s/^\D+//;
	$n1 =~ s/\n//g;
	$n1 = 0 if ($n1 eq "");  # ?  probably got coffee results?
	$n1 += 0;
	$n1 += 100 if ($a =~ /B/);   # Allow for C or IC licenses
	$n1 += 200 if ($a =~ /A/);
	$n1 += 1000 if ($a =~ /I/);
	$n1 += 10000 if ($a =~ /S/);

	$n2 = $b;
	$n2 =~ s/^\D+//;
	$n2 =~ s/\n//g;
	$n2 = 0 if ($n2 eq "");  # ?
	$n2 += 0;
	$n2 += 100 if ($b =~ /B/);   # Allow for C or IC licenses
	$n2 += 200 if ($b =~ /A/);
	$n2 += 1000 if ($b =~ /I/);
	$n2 += 10000 if ($b =~ /S/);

	return $n1 <=> $n2;
}

sub
caridcolonsub() { # Compare  car123:T-R2  car234-2:T-R5
	my($n1,$m1, $n2, $m2);
	my($suf1, $suf2);

	$suf1 = $a;
	if ($suf1 =~ /:/ ) {
		$suf1 =~ s/^[^:]*://;
	}
	else {
		$suf1 = "";
	}
	$n1 = $a;
	$n1 =~ s/:.*//;
	$n1 =~ s/^car//;
	$n1 =~ s/ .*$//;  # allow more on the line
	$m1 = $a;
	$m1 =~ s/:.*//;
	$m1 =~ s/ .*$//;  # allow more on the line
	if ($m1 !~ /-/) {
		$m1 = 1;
	}
	else {
		$m1 =~ s/.*-//;
		$n1 =~ s/-.*//;
	}

	$suf2 = $b;
	if ($suf2 =~ /:/ ) {
		$suf2 =~ s/^[^:]*://;
	}
	else {
		$suf2 = "";
	}
	$n2 = $b;
	$n2 =~ s/:.*//;
	$n2 =~ s/^car//;
	$n2 =~ s/ .*$//;  # allow more on the line
	$m2 = $b;
	$m2 =~ s/:.*//;
	$m2 =~ s/ .*$//;  # allow more on the line
	if ($m2 !~ /-/) {
		$m2 = 1;
	}
	else {
		$m2 =~ s/.*-//;
		$n2 =~ s/-.*//;
	}
	if ( $n1 == $n2 ) {
		if ( $m1 == $m2 ) {
			return $suf1 cmp $suf2;
		}
		return $m1 <=> $m2;
	}
	else {
		return $n1 <=> $n2;
	}
}

sub
caridsub() {  # sort carid1, carid10-2, carid100 ...
	my($n1,$m1, $n2, $m2);

	$n1 = $a;
	$n1 =~ s/^car//;
	$n1 =~ s/ .*$//;  # allow more on the line
	$m1 = $a;
	$m1 =~ s/ .*$//;  # allow more on the line
	if ($m1 !~ /-/) {
		$m1 = 1;
	}
	else {
		$m1 =~ s/.*-//;
		$n1 =~ s/-.*//;
	}

	$n2 = $b;
	$n2 =~ s/^car//;
	$n2 =~ s/ .*$//;  # allow more on the line
	$m2 = $b;
	$m2 =~ s/ .*$//;  # allow more on the line
	if ($m2 !~ /-/) {
		$m2 = 1;
	}
	else {
		$m2 =~ s/.*-//;
		$n2 =~ s/-.*//;
	}
	if ( $n1 == $n2 ) {
		return $m1 <=> $m2;
	}
	else {
		return $n1 <=> $n2;
	}
}
	
#
# checkcar - just check car matches selection
#
sub
checkcar {
	my($car,$line) = @@_;

	if ($main::selected eq "" || $main::selected eq "no car selected") {
		if (findcarid($car,$line)) {
			$main::mentioned = $car;
			return 1;
		}
		return 0;
	}
	return 1 if ($car eq $main::selected);
	&warn("Not using selection ${main::selected}: $line\n");
	return 0;
}

$main::lastcarday = -1;
$main::cardaycount = 1;
sub
gencarid { # every cars unequivocable ID is carNNN-N where NNN is gameday
	my($string);

	if ($main::mintoday != $main::lastcarday) {
		$main::cardaycount = 0;
	}
	$main::lastcarday = $main::mintoday;
	++$main::cardaycount;
	$string = "car$main::lastcarday";
	if ($main::cardaycount != 1) {
		$string = $string . "-" . "$main::cardaycount";
	}
	$string;
}

sub
getcarprice {
	my($id,$line) = @@_;
	my($price);

	$price = "Cr0";
	if ($line =~ m/\(Cr[0-9][0-9,]*/ ) {
		$line =~ s/,([^0-9])/, $1/;
		while ($line =~ m/Cr[0-9][0-9]*,/ ) {
			$line =~ s/(Cr[0-9][0-9]*),/$1/;
		}
		if ( $line =~ m/\((Cr[0-9][0-9]*)/ ) {
			$price = $1;
		}
	}
	$price;
}

sub
carsnow {  # expensive count of cars today
# try to call this only when we expect it to have changed
# $main::ncarsnow = carsnow();
	my($k,$i);
	$i = 0;
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold" &&
			$main::carstates{$k} ne "alias" ) {
			#printf("%3d %s\n", $i+1, $main::carnames{$k});
			++$i;
		}
	}
	$i;
}

sub
getcar {
	my($shortform,$fullname,$line) = @@_;
	my($newid);

# shortform could be from old GT1, i.e. greenSilviaLM
# Should we lookup a fullname table here, or should caller?
#  102-103  [R]FCRX7         All-nightI   q1st1st       greenSilviaLM(1/2)

	$newid = &gencarid();
	$main::carids{$newid} = $shortform;  # actually see findcarid
	$main::carnames{$newid} = $fullname;
	$main::carstates{$newid} = "got";   # s.b. "won" or "new" or "used"?
	$main::carlist{$shortform} = $shortform;
	$main::origin{$newid} = $line;
	$main::carprices{$newid} = getcarprice($newid,$line);
	$main::carid{$shortform} = $newid;  # stupid names carids vs carid
	$main::ncarsnow = carsnow();   # expensive?
	my($model) = ($fullname);
	if ($model =~ /['][0-9][0-9]\b/) {
		$model =~ s/(['][0-9][0-9]\b).*$/$1/;
	}
	else {
		while ($model =~ /[(].*[)]\s*$/) {
			# (prize)  (dup) (Cr10.000,new)  (colour)
			if ( $model =~ /[)]\s*[)]\s*$/ ) {
				# (Malachit (green))
				$model =~ s/\s*[(][^)]*[)]\s*[)]\s*$/)/;
			}
			$model =~ s/\s*[(][^()]*[)]\s*$//;
		}
	}
	$main::carmodels{$newid} = $model;
		
}

sub
carvariants {  # obtain variants of a token in a "sell" line
	# E.g.  sell DB7 => (redDB7, whiteDB7, purpleDB7)
	my($car) = @@_;

# Somewhere along the line, carnames table became the verbose name
# Really we can say that "sell" (not "sell car") should take only shortforms
# Note the current peculiar case of "sell excess red.delSol"
# Basically, "sell" (not "sell car") is only intended to work with prizes

	# Hope matching works; only count prizes
	my($i,$count);
	my($car1,$car2);
	my(%hash,@@list);

	$count = 0;
	$car1 = $car;
	$car1 =~ s/es$//;
	$car2 = $car1;
	$car1 =~ s/s$//;
	@@list = (reverse sort caridsub keys %main::carids);
	foreach $i (@@list) {
		if ($main::carstates{$i} ne "sold" &&
				$main::carnames{$i} =~ /\(prize/ ) {
# 2021/Jun/29 - removed match against carnames
#printf("Maybe got %s /$car/\n", $main::carnames{$i});
			#  this is a little atrocious
			if ( $main::carids{$i} =~ /$car/i ||
					$main::carids{$i} =~ /$car1/i ||
					$main::carids{$i} =~ /$car2/i ) {
#printf("Got %s\n", $main::carnames{$i});
####				$hash{$main::carnames{$i}} = 1;
				$hash{$main::carids{$i}} = 1;
			}
		}
	}
	@@list = keys %hash;
	undef(%hash);
	return @@list;

}

sub
carcount {
	my($car,$exact) = @@_;

	# Hope matching works; only count prizes
	my($i,$count);
	my($car1,$car2);
	my(@@list);

# Probably we want to do this only on carids, not carnames at all
	$count = 0;
	if ($exact) {
		# suitable for results of carvariants
		#  avoids blueSilEighty matching dkBlueSileighty -- sheesh
		# Probably here we should match carids table only...
		@@list = (reverse sort caridsub keys %main::carids);
		foreach $i (@@list) {
			if ($main::carstates{$i} ne "sold" &&
			    $main::carstates{$i} ne "alias" &&
				( $main::carids{$i} eq $car ||
				  $main::carnames{$i} eq $car ) ) {
				++$count;
			}
		}
	}
	else {
		$car =~ s/[()]/\\$&/g;
		$car1 = $car;
		$car1 =~ s/es$//;
		$car2 = $car1;
		$car1 =~ s/s$//;
		@@list = (reverse sort caridsub keys %main::carids);
		foreach $i (@@list) {
			if ($main::carstates{$i} ne "sold" &&
			    $main::carstates{$i} ne "alias" &&
				$main::carnames{$i} =~ /\(prize/ ) {
				#  this is a little atrocious
				if ( $main::carnames{$i} =~ /$car/i ||
					$main::carnames{$i} =~ /$car1/i ||
					$main::carnames{$i} =~ /$car2/i ||
					$main::carids{$i} =~ /$car/i ||
					$main::carids{$i} =~ /$car1/i ||
					$main::carids{$i} =~ /$car2/i ) {
					++$count;
				}
			}
		}
	}
#print "carcount:$count $car\n";
	return $count;

}

sub
sellcarid {
	my($carid,$match) = @@_;
	my($what);

	if (!defined($main::carstates{$carid})) {
		&warn("Attempt to sell bad carid: $carid $match\n");
		return;
	}
	if ($main::carstates{$carid} eq "sold") {
		&warn("Carid already sold: $carid $match\n");
		return;
	}
	if ($main::carstates{$carid} eq "alias") {
		# Could use $line
		&warn("Carid is alias: $carid $match\n");
		return;
	}
	$what = $main::carnames{$carid};
	$match =~ s/\s*->.*$//;
	$match =~ s/$/.*/;
	if ($what !~ /$match/) {
		&warn("Carid $carid ($what) does not match /$match/\n");
		return;
	}
	$main::carstates{$carid} = "sold";
	if ($main::showlist =~ /,sold,/i ) {
		print "${main::maxtoday}:$carid ($what) sold!\n";
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
sellentry {  # sell the given $num garage slot, if it matches $car
	my($num,$car) = @@_;
	my($i,$k,$what,$temp,$temp2);

# This was from GT1, and actually seems to still work!
	$i = 0;
	$what = "";
	$temp = "";
	$temp2 = "";
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold" &&
		    $main::carstates{$k} ne "alias") {
			if (++$i == $num) {
				$temp = $main::carnames{$k};
				if ($temp =~ /$car/ ) {
					$what = $temp;
					$main::carstates{$k} = "sold";
					last;
				}
				$temp2 = $main::carids{$k};
				if ($temp2 =~ /$car/ ) {
					# Match temp2 but show the fullname
					$what = $temp;
					$main::carstates{$k} = "sold";
					last;
				}
			}
		}
	}
	if ($what) {
		if ($main::showlist =~ /,sold,/i ) {
			print "${main::maxtoday}:$car ($what) sold!\n";
		}
	}
	else {
		print "${main::maxtoday}:Entry $num ($temp) doesn't match \/$car\/\n";
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
marksold {
	# I do not think we use this; see sellcarid
	my($id) = @@_;

	$main::carstates{$id} = "sold";   # I think that's all we need, now
}

sub
sellcar {
	my($car,$oldest) = @@_;
	my($i,$what,$temp,$temp2,$temp3,$temp4);
	my($ix,@@list);

	# if ($oldest) we want to remove oldest car, else most recent

	$car =~ s/^\s*//;
	$car =~ s/\s*$//;
	@@list = (sort caridsub keys %main::carids);
	@@list = reverse @@list if not ($oldest);
	foreach $ix (@@list) {
		# Sell the first exact match of $car against fullname
		$temp = $main::carnames{$ix};
		$temp =~ s/^\s*//;
		$temp =~ s/\s*$//;
		$temp2 = $temp;
		# (prize,B/Sunday) is now an unexpected suffix
		$temp2 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		$temp3 = $main::carids{$ix};   # short form
		$temp4 = $temp3;
		$temp4 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		if ( ($temp eq "$car" || $temp2 eq "$car" ||
		      $temp3 eq "$car" || $temp4 eq "$car")
			&& $main::carstates{$ix} ne "sold" &&
			   $main::carstates{$ix} ne "alias") {
			$what = $temp;
			# Could use &sellcarid()
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	foreach $ix (@@list) {
		# Sell the first exact match of $car against fullname
		$temp = $main::carnames{$ix};
		# this is sort of dumb...
		# prize annotation should not be part of car name?
		$temp =~ s/\(prize.*\)$//i;
		$temp4 = $main::carids{$ix};   # short form
		$temp4 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		if (  ($temp eq "$car" || $temp4 eq "$car")  &&
			   $main::carstates{$ix} ne "sold" &&
			   $main::carstates{$ix} ne "alias") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	foreach $ix (@@list) {
		# Sell the first pattern match of $car against fullname
		# But ONLY if the car is a prize
		$temp = $main::carnames{$ix};
		$temp4 = $main::carids{$ix};   # short form
		$temp4 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		if ($temp =~ /\(prize/i &&   # ) for vi
			($temp =~ /$car/i || $temp4 =~ /$car/i) &&
				$main::carstates{$ix} ne "sold" &&
				$main::carstates{$ix} ne "alias") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	# Remove plurals and try for removing prizes again
	while ($car =~ /es$/) {
		$car =~ s/es$//;
	}
	while ($car =~ /s$/) {
		$car =~ s/s$//;
	}
	foreach $ix (@@list) {
		# Sell the first pattern match of $car against fullname
		# But ONLY if the car is a prize
		$temp = $main::carnames{$ix};
		$temp4 = $main::carids{$ix};   # short form
		$temp4 =~ s/\s*\(prize[^\)]*\)\s*$//i;
		if ($temp =~ /\(prize/i &&  # ) for vi
			($temp =~ /$car/i || $temp4 =~ /$car/i) &&
				$main::carstates{$ix} ne "sold" &&
				$main::carstates{$ix} ne "alias") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	# We need to try $car against $carid{} (sic!)
#print "Could not find $car.\n";
	return "";
}

sub
sell {
	my($stuff) = @@_;
	my(@@count,@@name);
	my(@@variants);
	my($i,$n,$tname,$oldest,$sold,$var);
	
	$oldest = 0; #default always sell youngest
	@@count = ();
	@@name = ();

	
	if ($main::showlist =~ /,sell,/ ) {
		print "${main::maxtoday}:sell: $stuff\n";
	}
	$stuff =~ s/^\s*car //i;
	$oldest = $stuff =~ /^\s*oldest\b/i;
	$stuff =~ s/^\s*oldest\b//i;
	$stuff =~ s/^\s*//;
	$stuff =~ s/\s*->.*//;
	# Either need to make sellcar handle optional (prize,...)
	# Or repeat the attempt here
	# Actually problem is garage says "(prize" but sell line doesn't
	if ($sold = &sellcar($stuff, $oldest) ) {
		# literal sale, usually of purchased car...
		if ($main::showlist =~ /,sold,/i ) {
			print "${main::maxtoday}:$stuff ($sold) sold!\n";
		}
		return;
	}
	$stuff =~ s/\bCr[1-9][0-9,]*//g;
	$stuff =~ s/\s*$//;
	if ($stuff =~ /^entry\s+(\d+)\s+(.*)/ && defined($2)) {
#print "sell entry:$1 $2\n";
		&sellentry($1,$2);
		return;
	}
	if ($stuff =~ /^carid\s+([\-\w]+)\s+(.*)/ && defined($2)) {
#print "sell entry:$1 $2\n";
		&sellcarid($1,$2);
		return;
	}
	$stuff =~ s/,/ /g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}cars{0,1}//g;
	$stuff =~ s/\bday {0,1}[1-9][0-9]*//g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}day//g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}day//g;
	$stuff =~ s/\ba\b/1/gi;
	$stuff =~ s/\(\d+\)//g;
	$stuff =~ s/\band\b//gi;
	$stuff =~ s/\bold\b//gi;
	$stuff =~ s/\balso\b//gi;
	$stuff =~ s/\bmost\b//gi;
	$stuff =~ s/\brecent\b//gi;
	while ($stuff =~ /[\w\[\]\-]/ ) {
		$stuff =~ s/^[^\w\[\]\-]//;
#print "stuff:$stuff\n";
		if ($stuff =~ /^(\d+)/ && defined($1) ) {
#print "number:$1\n";
			push @@count,$1;
			$stuff =~ s/^\d+\s*//;
		}
		else {
			if ($stuff =~ /^excess */) {
				push @@count,-1;
				$stuff =~ s/^excess *//;
			}
			else {
				push @@count,1;
			}
		}
		$stuff =~ s/^[^\w\[\]\-]+//;
		if ($stuff =~ /^([\w'\/\[\]\-#.]+)/ && defined($1) ) {
			push @@name,$1;
			$stuff =~ s/^[\w'\/\[\]\-#.]+\s*//;
		}
		else {
			last;
		}
	}
	for ($i = 0; defined($name[$i]); ++$i) {
		if ($main::showlist =~ /,sales,/ ) {
			print "${main::maxtoday}:Sell $count[$i] $name[$i].\n";
		}
		$tname = $name[$i];
		$n = $count[$i];
		for ($n = $count[$i]; $n > 0; --$n) {
			if ($sold = &sellcar($tname, $oldest)) {
				if ($main::showlist =~ /,sold,/i ) {
					print "${main::maxtoday}:$tname ($sold) sold!\n";
				}
			}
			else {
				print "${main::maxtoday}:Could not sell $tname.\n";
				last;
			}
		}
		if ($n < 0) {
			$n = -$n;
			@@variants = &carvariants($tname);
			foreach $var (@@variants) {
#printf("Sell  - $n $var, (%d).\n", &carcount($var,1));
				while (&carcount($var,1) > $n) {
#print "Sell $var.\n";
					if ($sold = &sellcar($var, $oldest)) {
						if ($main::showlist =~ /,sold,/i ) {
							print "${main::maxtoday}:$var ($sold) sold!\n";
						}
					}
					else {
						print "${main::maxtoday}:Could not sell $var.\n";
						last;
					}
				}
			}
		}
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
daycheck {
	my($day) = @@_;

	return 0 if ($day =~ /\D/);
	return 0 if ($day !~ /\d/);
	if ($day < $main::mintoday || $main::maxtoday < $day) {
		return 0;
	}
	return 1;
}

sub
dodateline {
	my($line) = @@_;

	print " Date: $line\n" if ($main::showlist =~ /,trace,/ );
	if ($line !~ /1999$/ && $line !~ /20[012][0-9]$/) {
		&warn("Bad date line: $_\n");
	}
	if ($main::enddate ne "") {
		$main::done = $line =~ /$main::enddate/i;
	}
	$main::lastdateline = $line."\n";
	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		# Problem is we really want this in the log not selected yet
		addcarlog($main::mentioned,$line);		
	}
}

sub
dopragma {
	my($line) = @@_;
	my($what,$value,$league,$length);

	$line =~ /^\s*pragma\s+(\w+)/;
	$what = $1;

	print " Pragma: $line\n" if ($main::showlist =~ /,trace,/ );
	if ($what =~ /^no/) {
		$what =~ s/^no//;
		$main::pragmas =~ s/,$what,/,/;
	}
	else {
		if ($main::pragmas !~ /,$what,/) {
			$main::pragmas .= "$what,";
		}
	}

}

sub
doselect{
	my($line,$rest,$r1,$r2) = @@_;
	my($car);

	print " ${main::maxtoday} Select: $rest\n" if ($main::showlist =~ /,trace,/ );
	if ($rest =~ /^select\s*car\s+(\S+)/ && defined($1)) {
		$car = $1;
		if ($car eq "none") {
# Wed Apr 14, 2021
# Empty selection turns off selection checking
# We never used this, so change it to be something which cannot match
# Actually we used it in gt1-mazda
			$main::mentioned = "";
			$main::selected = "no car selected";
# This will be useful to allow "verbose carlog" to include comments and status
			return;
		}
		if ( findcarid($car,$line) ) {
			$main::selected = $car;
			$main::mentioned = $car;
			addcarlog($car,$line);		
			return;
		}
	}
	if ($main::var{'autoselectcarids'} && defined($car) && $car ne "" ) {
		&newautocarid($car,$line);
		$main::selected = $car;
		$main::mentioned = $car;
		addcarlog($car,$line);		
		return;
	}
	&warn("Bad select: $line\n");
}

sub
getgsb { # get Gold, Silver, Bronze (counts)
	my %h = @@_;
	my ($i, @@sorted, %m);

	%m = ();
	@@sorted = sort lidsub keys %h;
	for ($i = 0; $i <= $#sorted; ++$i) {
		++$m{$h{$sorted[$i]}};  # create $m{"G"}, $m{"S"}, $m{"B"}
	}

	return %m;
}
	

%main::lresults = ();
sub
updatemedal {
	my($lid,$medal) = @@_;
	my($oldr);

#printf "updatemedal %s %s\n", $lid, $medal;
	$medal = "F" if !defined($medal);
	return if ($medal eq "F");
	if (!defined($main::lresults{$lid})) {
		$main::lresults{$lid} = $medal;   # know $medal is not F
	}
	else {
		$oldr = $main::lresults{$lid};
		if ($medal eq "G") {
			$main::lresults{$lid} = $medal;
		}
		elsif ($medal eq "S") {
			$main::lresults{$lid} = $medal if ($oldr ne "G");
		}
		# $medal must be B, and $lresults is defined
	}
} 

sub
dolicenseline {
	my($line,$rest,$start,$end) = @@_;
	my($diff);
	my($lid,$medal);

	print " ${main::maxtoday} License: $rest\n" if ($main::showlist =~ /,trace,/ );
#&warn("Good license line: $line\n");
	if (!&daycheck($start) ) {
		&warn("Bad license start day(not ${main::maxtoday}): $_\n");
	}
	$diff = $end - $start;
	if ( $diff < 0 ) {
		&warn("Bad license end day: $_\n");
	}
	$main::mintoday = $end + $main::var{'minlicenseinc'};
	$main::maxtoday = $end + $main::var{'maxlicenseinc'};
	# Almost need completely different routine for GT3, but maybe not?
	return if $main::pragmas !~ /,gt4,/;

	$lid = $rest;   # Note, line includes the day number
	#$lid =~ s/\s*\d+\s+//;  # Remove day number
	$lid =~ s/^licen[^ ]*\s+//;   # Must be a license line
	$lid =~ s/^\s+//;
	$lid =~ s/\s+.*$//;
	$lid =~ s/\n//g;
	$lid =~ s/\(.*//;  # Allow a parenthetical (!) or something
	if ($lid =~ /coffee/) {
		; # handle coffee later
	}
	# Note Gran Turismo actually uses hyphens in test names, e.g. S-16
	elsif ($lid !~ /^[I]{0,1}[BAS][\-]{0,1}[\d]{1,2}$/ || $lid =~ /IS/) {
		&warn("Bad license line (result first?): $line\n");
	}
	else {
		$lid =~ s/[\-]//;  # allow B-1, but use B1 internally
		$medal = $rest;
		#$medal =~ s/\s*\d+\s+//;  # Remove day number
		$medal =~ s/^licen[^ ]*\s+//;
		$medal =~ s/^\s+//;
		$medal =~ s/^I{0,1}[BAS]\d+[\-]{0,1}(\([^ ]*){0,1}\s+//;  # Remove $lid; we allow IS!
		if ( $medal =~ /^([FBSG])\b/ ) {
			$medal = $1;
		}
		else {
# Probably we should just complain in this case
			# Comments between $lid and $medal
#print "S14 medal=$medal\n" if ($lid eq "S14");
			&warn("License medal not first: $line\n")
				if ($main::showlist =~ /,licen[sc]e,/ );
			$medal =~ s/^[A-Za-z]+\s+//;
			$medal =~ s/[A-Za-z]{3,}//g;   # Seattle
			$medal =~ s/^[^ ]+\@@[^ ]+//;   # FordGT@@Seattle
			$medal =~ s/\bI{0,1}[BAS]\d+\b//g;  # lid can fool us
#			$medal =~ s/\b[\-\+][\:\.\d]{3,100}[BSG]\b//g;  # ignore +0.001G
# For some reason \b prevented matches
			$medal =~ s/[\-\+][\:\.\d]{3,}[BSG]{0,1}//g;  # ignore +0.001G
#print "S14 medal=$medal\n" if ($lid eq "S14");
			if ($medal =~ /[0-9\s]([BSG])\b/) { # 1st medal letter
				$medal = $1;
			}
			else {
				$medal =~ /([BSG])\b/;
				$medal = $1;
			}
		}
#print "S14 medal=$medal\n" if ($lid eq "S14");
		$medal = "F" if !defined($medal);
		updatemedal($lid,$medal);
	}

}

sub
otherprize {
	my($prize) = @@_;

	$prize =~ s/\s*\(.*//;
	$prize =~ s/^\s//;
	return 1 if ($prize eq "full");
	return 1 if ($prize eq "none");
	return 1 if ($prize eq "next");  # Hmm...
	return 1 if ($prize eq "1st");
	return 1 if ($prize =~ /^2nd/);
	return 1 if ($prize =~ /^3rd/);
	return 1 if ($prize =~ /^4th/);
	return 1 if ($prize =~ /^5th/);
	return 1 if ($prize =~ /^6th/);
	return 1 if ($prize =~ /^8-/);   #  8-(
	return 1 if ($prize =~ /\s8-/);   #  8-(
                              # but don't match Z28-30th
	#return 1 if ($prize =~ /credits/);
	return 0;
}

sub
event_mindays {
	my($event) = @@_;

	if (defined($main::seriesmindays{$event})) {
		return $main::seriesmindays{$event};
	}
	return 0;
}
sub
event_maxdays {
	my($event) = @@_;

	if (defined($main::seriesmaxdays{$event})) {
		return $main::seriesmaxdays{$event};
	}
	return $main::var{'maxunknownracedays'};  # +1 for GT1
}

sub
check_event {
	my($event) = @@_;
	my($league,$series,$track,$rest);

	return 0 if !defined($event);
	return 1 if defined($main::events{$event});

	my ($delim,$delim2);
	$delim = $main::var{'seriesdelim'};
	$delim2 = $main::var{'trackdelim'};
        # Now we need to handle "series/track"
	if ($delim  eq "") {
		$series = $event;
	}
	else {
		# This could be expensive each series line
		if ( $event =~ /([^${delim}]*)[${delim}](.*)/ ) {
			# Couldn't we assume event structure was checked by "define"
			($league,$series) = ($1,$2);
		}
		return 0 if !defined($league) || !defined($main::league{$league});
		return 0 if !defined($series);
	}
	if ($series =~ /[${delim2}]/) {   # handle a race in a series
		# In GT1 all series had an extra day for all qualifying
		# E.g. GV300 clocked 2 days, but UKvsUS clocked 6
		# Spot/DFRW etc were listed explicitly as 1 day => 2
		# In GT4 a length of 0 meant 1 day, and worked
		# Similarly in  GT2 a length of 0 meant 1 day, and worked
		$series =~ /([^${delim2}]*)[${delim2}](.*)/;
		($series,$track) = ($1,$2);
		# So we need to set a length for GT1
		my ($e);
		$e = $event;
		$e =~ s/[${delim2}][^${delim2}]*$//;
		return 0 if !defined($main::series{"$e"});
		return 0 if !defined($main::track{$track});
	}
	else {
		return 0 if !defined($main::series{"$event"});
		#return 0 if !defined($main::series{"$league/$series"});
	}
	return 1;
}

sub
record_race_prize {
	my ($r,$s) = @@_;  # race, prize
	my ($temp);

	return if ($s =~ /credits/ || &otherprize($s));
	$temp = $s;
	$temp =~ s/\s*\(sold\)\s*//;
	$temp =~ s/\s*\(dup\)\s*//;
	$temp =~ s/\s*$//;
	# Perhaps one of these should record some of the above?
	# Currently they are same info; presumably want to derive from them
	push @@main::prizes,"${r}: $temp";
	push @@main::events,"${r}: $temp";
}


sub
removeseriescarcruft {   # $rest = removeseriescarcruft($rest);
	my($r) = @@_;
	my($p);

#print "${main::maxtoday}:", $r,"\n" if ( $r =~ /tune/ || $r =~ m:RT/10:);
	foreach $p (@@main::seriescarcrufts) {
#print "${main::maxtoday}:". $r," ",$p,"\n" if $r =~ /tune/;
		if ($r =~ /^[^\s,]+\s*$p/ ) {
			$r =~ s/(^[^\s,]+)\s*$p/$1 /;
			# last ?
#print "${main::maxtoday}: $r\n";
#print "${main::maxtoday}: $r\n" if ($r =~ /DB7/i);
		}
	}
	$r;
}

sub
doseriesline {
	my($line,$rest,$start,$end) = @@_;
	my($diff);
	my($i,$none,$pat,$race,$event,$mindays,$maxdays,$suff,$prev,$after);
	my($car,$prize,$count,$status,$temp);

	if ($start eq "") {
		print " ${main::maxtoday} Series: $line (empty)\n" if ($main::showlist =~ /,trace,/ );
		return;		# assume a harmless comment?
	}
	print " ${main::maxtoday} Series: $rest\n" if ($main::showlist =~ /,trace,/ );
	if (!&daycheck($start) ) {
		&warn("Bad start day(not ${main::maxtoday}): $_\n");
	}
	# there's sort of an assumption every event takes at least one day
	#  so daycounter actually becomes $end+1 i.e. $start+$diff+1
	$diff = $end - $start;
	if ( $diff < 0 || $main::maxserieslen < $diff) {
		&warn("Bad end day: $_\n");
	}
	$main::mintoday = $end + $main::var{'minseriesinc'};
	$main::maxtoday = $end + $main::var{'maxseriesinc'};
	$none = 1;
	# Assumption is first token is car, next is event...
	#  Here there are no assumptions about event name format
	$rest = removeseriescarcruft($rest);
	if ($rest =~ /(\S+)\s+(\S+)\s+(.*)/ ) {
		($car,$event,$after) = ($1,$2,$3);
	}
	if ( !defined($event) ) {
		&warn("event not defined: $line\n");
		return;
	}
	if (&check_event($event) == 0) {
		&warn("Unrecognized event ($event): $line\n");
		$event = " ";
		return;
	}
	else {
		$mindays = &event_mindays($event);
		$maxdays = &event_maxdays($event);
		if ($diff < $mindays || $maxdays < $diff) {
			# It is amazing this check usually passes
			&warn("Bad end day for series \"$event\": $line\n");
		}
		$car =~ s/^\s*//;
		$car =~ s/[,\s].*//;
		checkcar($car,$line);
		addcarlog($car,$line);
		
	}
	$none = 0;
	if ( !defined($event) ) {
		&warn("event not defined: $line\n");
		return;
	}
	# Note: bad ${event} can break regex  E.g. "(perm"
	if ( $rest =~ m/(\S+.*\s+)(\S+[\/]${event})(\s.*)/ ) {
		$rest =~ /(\S+.*\s+)(\S+\/${event})(\s.*)/ ;
		($prev,$race,$after) = ($1,$2,$3);
	}
	else {
		$rest =~ /(\S+.*\s+)(${event})(\s.*)/ ;
		($prev,$race,$after) = ($1,$2,$3);
	}
	if ( !defined($after) ) {
		&warn("$rest has no after\n");
		return;
	}
	# Boy there's some old cruft here
	$status = "";
	$prize = $rest;
	$prize =~ s/red /red#/g;
	$prize =~ s/black /black#/g;
	$prize =~ s/ LM/#LM/g;
        $prize =~ s/^.* ([\w\[])/$1/;
        $prize =~ s/[!]//g;
	if ($prize =~ /([(].*)/ && defined($1)) {
		$status = $1;
		$prize =~ s/[(].*//;
	}
	if ($prize !~ /ConceptCar/ ) {
		$prize =~ s/Concept/ConceptCar/;
	}
	$prize =~ s/#/ /g;
	$prize =~ s/ *$//g;
#	if ( &otherprize($prize) == 0 &&
#			$main::raceprizes{$event} !~ /,${prize},/ ) {
#		&warn("Unrecognized prize ($prize) for $race: $line\n");
#	}
	if ($status =~ /([(][^)]*[)])(.*)/) {
		$count = $1;
		$status = $2;
		if ($status =~ /([(][^)]*[)])(.*)/) {
			$status = $1;
		}
	}
	if ($prize eq "next") {
		if (defined($main::prize_event) && $main::prize_event ne "") {
			 &warn("Next for $main::prize_event never claimed: $line\n");
		}
		$main::prize_event = $race;
	}
	record_race_prize($race,$prize);
	if ($status ne "(sold)" && $line !~ /[(]sold[)]/ ) {
# It really would be more pure to record the prize and then sell it
		if ($prize !~ /credits/ && &otherprize($prize) == 0) {
			my ($fullprize);
			$fullprize = $prize;
			if (defined($main::fullprizenames{$prize}) ) {
				$fullprize = $main::fullprizenames{$prize};
			}
			getcar($prize,"$fullprize(prize, $race)",$line);
		}
	}
}

sub
check_hash {
	my($old, $new) = @@_;

	if (defined($old) && $old ne "") {
		&warn("Duplicate definition: $new\n");
	}
	return $new;
}


sub
docardef {
	my($line) = @@_;
	my($what,$value,$carid);

	print " ${main::maxtoday} Cardef: $line\n" if ($main::showlist =~ /,trace,/ );

	$line =~ /^\s*cardef\s+(\S+)\s+([\S]+)/;
	$what = $1;
	$value = $2;

	if (!defined($what) || !defined($value)) {
		&warn("Bad cardef: $line\n");
		return;
	}
	if (defined($main::cardefs{$what})) {
		&warn("Already defined: $line\n");
		return;
	}
	$carid = findcarid($value,$line);
	if (!$carid) {
		&warn("Bad carid: $line\n");
		return;
	}
	if ($main::carstates{$carid} eq "sold") {
		&warn("Already sold car: $line\n");
		return;
	}
	$main::cardefs{$what} = $carid;
}

sub
douncardef {
	my($line) = @@_;
	my($what);

	print " ${main::maxtoday} Uncardef: $line\n" if ($main::showlist =~ /,trace,/ );
	$line =~ /^\s*uncardef\s+(\S+)/;
	$what = $1;

	if (!defined($main::cardefs{$what})) {
		&warn("No such cardef: $line");
		return;
	}
	delete($main::cardefs{$what});
 	# is following advisable?
	#if (defined($main::carlist{$what})) {
	#	delete($main::carlist{$what});
	#}
}

sub
setseriescarcruft {
	# This is really a bit much just to avoid editing old GT1 logs...
	my ($stuff,$chunk);
	# Note currently this can be repeated
	#  That mean's there is no way to empty @@$main::seriescarcrufts

	$stuff = $main::seriescarcruft;
	$stuff =~ s/\n//g;
	while ($stuff ne "") {
		$chunk = $stuff;
		$chunk =~ s/\#.*//;
		$stuff =~ s/^[^\#]*//;
		$stuff =~ s/^\#//;
		push @@main::seriescarcrufts, $chunk;
	}
#foreach $chunk (@@main::seriescarcrufts) {
#	print "$chunk\n";
#}
}


sub
dosetvar {
	my($line) = @@_;
	my($what,$value,$carid);

print " Setvar: $line\n" if ($main::showlist =~ /,trace,/ );
	if ( $line =~ /^\s*setvar\s+(\S+)\s*\=\s*\"([^"]*)\"/ ) {  # quoted
		# can of worms
		$what = $1;
		$value = $2;
	}
	elsif ( $line =~ /^\s*setvar\s+(\S+)\s*\=\s*([\S]+)/ ) {
		# Usually number...
		$what = $1;
		$value = $2;
	}
	else {
		&warn("Bad setvar: $line\n");
		return;
	}
	# assert defined($what) && defined($value)

	$main::var{$what} = $value;
	if ($what eq "seriescarcruft") {   # super-kludge
		$main::seriescarcruft = $main::var{$what};
		setseriescarcruft();
	}
}

$main::autocaridcount = 0;
sub
newautocarid {
	my($carname,$line) = @@_;
	my($newid);

	# Almost no reason we couldn't generate a real carid
	#  But it will be nice to be able to distinguish
	++$main::autocaridcount;
	$newid = "car0-"."$main::autocaridcount";
	# Following replicates a bit of getcar()
	$main::carids{$newid} = $carname;  # actually see findcarid
	$main::carnames{$newid} = $carname;
	$main::carstates{$newid} = "alias";   # s.b. "won" or "new" or "used"?
	$main::carlist{$carname} = $carname;
	$main::origin{$newid} = $line;
	$main::carprices{$newid} = "Cr0";   # Not sure what to do here
	$main::carid{$carname} = $newid;  # stupid names carids vs carid
	# $main::ncarsnow = carsnow();   # expensive?
	# Problem: this increases the car count
	return $newid;
}

sub
findcarid { # given explicit cardef or carid, or unique shortform, return carid
	    # warn (first time) about unresolvable names
	my($carname,$line) = @@_;
	my($k,$id);

	if (defined($main::carids{$carname})) {
		# We were given a carid; just return it (NOT carids{$carname})
		return $carname;
	}
# We have both %carids and %carid
	if (defined($main::carid{$carname})) {
		# quick map of short forms to carid
		return $main::carid{$carname};
	}
	if (defined($main::cardefs{$carname} )) {
		return $main::cardefs{$carname};
	}
	# Did not find via above; search all $carids{}
	$id = "";
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carids{$k} eq $carname &&
				$main::carstates{$k} ne "sold") {
			# N.B. In this case we must match aliases
			if ($id eq "") {
				$id = $k;
			}
			else {
				if ($line ne "") {
					# should we warn here?
				&warn("Ambiguous car ($carname): $line\n");
					# Use first if $line is not set
					return undef;
				}
			}
		}

	}
	if ( $id ne "" ) {
		return $id;
	}
	if (!defined($main::carlist{$carname})) {
		# Reduce diagnostics by defining here
		$main::carlist{$carname} = $carname;
		if ( $main::var{'autocarids'} == 0 ) {
			&warn("Unrecognized car ($carname): $line\n");
		}
		else {
			$id = &newautocarid($carname,$line);
		}
			
	}
	return undef;
}

sub
dofullprizename {
	my($argline) = @@_;
	my($line, $what,$value);

	print " Fullprizename: $argline\n" if ($main::showlist =~ /,trace,/ );
	$line = $argline;
	$line =~ s/^\s*define\b\s*//i;
	if ($line =~ /^\s*fullprizename\s+([\-\w\/\#]+)\s+(.+)$/ ) {
		# black/blueSupra
		# silverNismoGT-R LM
		$what = $1;
		$value = $2;
		$what =~ s/#/ /g;
		$value =~ s/\s+$//;
		$main::fullprizenames{$what} = $value;
	}
	else {
		&warn("Bad fullprizename: $argline\n");
	}
}


sub
dodefine {
	my($line) = @@_;
	my($what,$value,$league,$length);

	print " Define: $line\n" if ($main::showlist =~ /,trace,/ );
	$line =~ /^\s*define\s+(\w+)\s+([\S]+)/;
	# Should check for undefined...
	$what = $1;
	$value = $2;

	if ($what =~ /fullprizename/i) {
		dofullprizename($line);
		return;
	}
	if ($what =~ /league/i) {
	   $main::league{$value} = &check_hash($main::league{$value}, $value);
	}
	elsif ($what =~ /series/i) {
	   $league = "";
	   my($delim);
	   $delim = $main::var{'seriesdelim'};
#print "delim=|$delim|\n";
	   if ($delim ne "") {
	        if ($value !~ /^([^\s${delim}]+)${delim}([^\s${delim}]+)$/) {
		#Problems: A/S+S E/All-night
		    &warn("Bad series name: $value\n");
	        }
	        else {
		    $league = $1;
	        }
	        if (!defined($main::league{$league})) {
		    &warn("Undefined league in series name: $value\n");
	        }
	   }
	   # after this, $value can be an arbitrary string
	   # Goal here is to process old "Sunday" events from GT1 logs
#print "set series |${value}|\n";
	   $main::series{$value} = &check_hash($main::series{$value}, $value);
	   $length = 1;
	   if ( $line =~ /^\s*define\s+(\w+)\s+([\S]+)\s+(\d+)/ ) {
		$length = $3;
	   }
	   if ($length > $main::maxserieslen) {
		$main::maxserieslen = $length;
	   }
	   $main::seriesmindays{$value} = $length-1;   # Why -1 ?
	   $main::seriesmaxdays{$value} = $length-1;   # Why -1 ?
	}
	elsif ($what =~ /track/i) {
	   $main::track{$value} = &check_hash($main::track{$value}, $value);
	}
	else {
		&warn("Bad definition: $line");
	}
}


$main::fid = 'LOG0';
sub
doinclude {
	no strict 'refs';
	my($line) = @@_;
	my($filename, $oldfid, $n);

# I do not believe that includes can be nested...
	print " Include: $line\n" if ($main::showlist =~ /,trace,/ );
	$line =~ /^\s*include\s+(\S+)/;
	$filename = $1;
	$oldfid = $main::fid;
	$n = $main::fid;
	$n =~ s/LOG//;
	++$n;
#print "$main::fid $n\n";
	$main::fid = 'LOG' . "$n";
	if (!open($main::fid,"<$filename") ) {
		&warn("Cannot open include \"$filename.\"\n");
		$main::fid = $oldfid;
	}
}

sub
heuristicinclude {
	my ($logname, $line) = @@_;  # Current line to stash for later somehow
	my ($includefile);

	$main::saveline = $line;
	print "Attempt include for $logname\n" if ($main::showlist =~ /,heuristic,/ );
	$includefile = "gt1-racedefs";
	if ($logname =~ /^gt4/) {
		$includefile = "gt4-racedefs";
	}
	elsif ($logname =~ /^gt3/) {
		$includefile = "gt3-racedefs";
	}
	elsif ($logname =~ /^gt2/) {
		$includefile = "gt2-racedefs";
	}
	elsif ($logname =~ /^gt1/) {
		$includefile = "gt1-racedefs";
	}
	elsif ($logname =~ /^ARRI/) {
		$includefile = "ARRI-racedefs";
	}
	&doinclude("include $includefile");
}

sub
dostatusline {
	my($line,$rest,$r1,$r2) = @@_;
	#my($day,$stuff,$sf,$fullname);

	print " ${main::maxtoday} Status: $rest\n" if ($main::showlist =~ /,trace,/ );
	if (!&daycheck($r1) ) {
		&warn("Bad single day note(not ${main::maxtoday}): $line\n");
	}
	# Assert $rest =~ /^Cr[0-9]/
	# grr... seems difficult to undef $1 ...
	# If you need to, 'a' =~ /a/   will do it. I.e. a successful match.

	# Later check Ncars, medal counts perhaps license standing?

	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		addcarlog($main::mentioned,$line);		
	}
	if ( $main::pragmas =~ /,gt4,/ && $rest =~
	   m:([0-9]{1,2}[GB][ /]{1,3}[0-9]{1,2}[S][ /]{1,3}[0-9]{1,2}[GB]): ) {
		# Later perhaps license stats for GT3
		my $licstats = $1;
		my ($m, $s);
		my (%gsb);
		$s = "";
		%gsb = getgsb(%main::lresults);
		for $m ("G", "S", "B") {
			if (!defined($gsb{$m}) ) {
				$gsb{$m} = 0;
			}
			$s .= sprintf("%d%s ", $gsb{$m}, $m);
		}
		# Compare %gsb/$s with canonical version of $licstats
		my ($logresults) = ("");
		$licstats =~ /\b([0-9]+G)\b/;
		$logresults .= "$1 " if (defined($1));
		$licstats =~ /\b([0-9]+S)\b/;
		$logresults .= "$1 " if (defined($1));
		$licstats =~ /\b([0-9]+B)\b/;
		$logresults .= "$1 " if (defined($1));
		if ($main::showlist =~ /,licen[sc]e,/ ) {
			printf "%s %s %s - %s\n",
				$r1, $licstats, $logresults, $s;
		}
		if ( $logresults ne $s ) {
			&warn("$logresults ne $s: $line\n");
		}
	}
	if ( ( $main::showlist =~ /,warn,/i || $main::showlist !~ /,garage,/)
		 && $rest =~ m:\b([0-9]{1,4})[ ]{0,3}car[s]{0,1}\b:i ) {
		# commas?
		my ($logncars);
		$logncars = $1;
		if ($logncars != $main::ncarsnow) {
			&warn("Car count not ${main::ncarsnow}): $line\n");
		}
	}

	$main::mintoday = $r2;
	$main::maxtoday = $r2;
}


# $e = set_from_race($e);
sub
race_to_set {  # derive "set" (event) name from one of its races
	my($s) = @@_;
# E,g, GT4   B/Sunday/AMii  => B/Sunday
#   But  SC/Normal/AmalfiR => SC/Normal/Amalfi

	# A prize is for the set, not the race
	# Perhaps this depends on pragma
	# Or perhaps we need "prizeevent" defns
	if ($s !~ m:/(Easy|Normal|Hard)/: ) { # ugh!
		while ($s =~ m:/.*/: ) {
			$s =~ s:/[^/]*$:: ;
		}
	}
	else {  # and ugh!
		$s =~ s/R$//;
		$s =~ s/ii$//;
	}
	return $s;
}

sub
dowin {   # Handle  150 +1 win car  RSC'02  Toyota RSC Rally Raid Car '02
# Note: also   59 +1 win car Nike   Nike One 2022 (prize,IBlicenseB)
	my($line,$rest,$r1,$r2) = @@_;
	#my($day,$stuff,$sf,$fullname);
	my($stuff,$sf,$fullname);
	my($tstuff,$event);

	print " ${main::maxtoday} Win: $rest\n" if ($main::showlist =~ /,trace,/ );
	if ($rest !~ /^win\s+(.*)/ || !defined($1)) {
		return;
	}
	$stuff = $1;
#print "stuff:$stuff\n";
	if ($main::mentioned ne "") {
		addcarlog($main::mentioned,$line);
	}
	if ($stuff !~ /^\s*car\s+(\S+)/ || !defined($1) ) {
		if (!$main::var{'allowanyprize'} ) {
			&warn("Bad win: $line\n");
		}
		else {
			getcar($stuff,$stuff,$line);
			$main::prize_event = "";
		}
		return;
	}
	$event = "";
	$tstuff = $stuff;
	while ($tstuff =~ m:\s*\([^\)]*\)\s*$: ) {
#&warn("Eat parentheses: $line\n");
		if ($tstuff =~ m:(\(prize[^\)]*)\)\s*$: ) {
#&warn("Found prize: $line\n");
			$event = $1;
			$event =~ s/^\(prize,//;
			$event =~ s/\)\s*$//;
			last;
		}
# Good candidate for infinite loop here...
		$tstuff =~ s:\s*\([^\)]*\)\s*$:: ;
	}


	if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
#$main::prize_event = "";
# Problem: some prize car names include parentheses
		$sf = $1;
		if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
			$fullname = $2;
			$fullname =~ s/^[^\w\[]*//;
			$fullname =~ s/->\s.*//;
			$fullname =~ s/\s*$//;
			$fullname =~ s/^\s*//;
			if ($event ne "") {
				# Actually probably a non-race prize
				record_race_prize($event,$fullname);
			}
			elsif (defined($main::prize_event) && $main::prize_event ne "") {
				my ($e) = ($main::prize_event);
				# assert ($event eq "")
				$e = race_to_set($e);
				$fullname =~ s/$/ (prize,$e)/;
				# push event info here...
				record_race_prize($e,$fullname);
			}
			# Need a GOOD way for prize info to be passed
			getcar($sf,$fullname,$line);
			if ($main::showlist =~ /,buy,/i) {
				print "${main::maxtoday}:win $sf - $fullname.\n";
			}
		}
		else {
			# Need a way for prize info to be passed
			# I don't think we ever use this form?
			getcar($sf,$sf,$line);
		}
	}
	if ($event eq "") {
# Perhaps having $main::prize_event set for a win with event should be an error
		if (!defined($main::prize_event) || $main::prize_event eq "") {
			&warn("prize_event not set: $line\n");
		}
		$main::prize_event = "";
	}

}

sub
normalizeparts {
	my($car,$line) = @@_;
	my($stuff, $dayno, $op);
	my ($tok);
	my ($mod);

# 208  mod car   CivicTypeR WR1 WR2 WR3  -805-780-755  Cr1000 Cr5000 Cr20,000
# 451  buy parts whiteCelica'70 (Tom's) Rmuff Cr4600 Rbr Bctlr  Cr4600 Cr10,300
# 451  mod car   whiteCelica'70   pol+bal  Cr5250  Cr11,000
# 451  mod car   whiteCelica'70   WR1 WR2 WR3 Cr1100 Cr5300 Cr21,000
	$stuff = $line;
	$stuff =~ s/\n//g;
	$stuff =~ s/^\s*//;  # Had had obscure bug ctrl\ instead of "^\"
	$stuff =~ s/^\s*$//;   # Can't hurt
	$dayno = $stuff;
	$dayno =~ s/\s+.*$//;
	$stuff =~ s/^\S+\s*//;
	$op = $stuff;
	if ($op =~ /^\+\d/) {
		# In GT4, this actually implies wheels
		$stuff =~ s/^\S+\s*//;
		$op = $stuff;
	}
	$op =~ s/\s.*$//;  #  s.b. "buy" or "mod"
			# Will later make into "parts" or "mod"
	$stuff =~ s/^\S+\s*//;
	$tok = "";
	for ( ; ; ) {
		last if ($stuff eq "");
		$tok = $stuff;
		$tok =~ s/\s+.*$//;
		$op = $tok if ($tok eq "parts");
		$stuff =~ s/^\S+\s*//;
		last if ($tok eq $car);
	}
	if ($tok ne $car) {
		# Perhaps this will be redundant noise given "select"
		&warn("Could not find $car: $line\n");
	}
	while ($stuff =~ /,\s*Cr/i ) {
		# Ensure prices are separated by spaces, not commas
		$stuff =~ s/,\s*Cr/ Cr/ig;
	}
	while ($stuff =~ /Cr\d+,\d/i ) {
		# Reomve optional commas from Cr10,000
		$stuff =~ s/(Cr\d+),(\d)/$1$2/;
	}
	while ($stuff =~ /Cr\d+[.]\d/i ) {
		&warn("Period instead of comma: $line\n");
		$stuff =~ s/(Cr\d+)[.](\d)/$1$2/;
	}
	# Now for things like
        # 117 mod car   Silvia'88K  WR1  Cr1000  ->1071kg
        # 120 buy parts Silvia'88K  Rmuff  ->257hp
        # 706  mod car  March  WR1 WR2 WR3 -805-780-755  Cr1000 Cr5000 Cr20,000
	# Appears we only did 805 -> 780 in comments
	# Recently we usually use only "-" with no spaces
	# We cannot safely remove spaces before "-".
	$stuff =~ s/(\d)to(\d)/$1-$2/g;  # probably should've just changed log
	my($p) = $stuff;
	$mod = "";
	while ( $stuff =~ m/(\d*-[\d\-\>]+(hp|kg){0,1})/ ) {
		$mod .= $1;
		$stuff =~ s/\d*-[\d\-\>]+(hp|kg){0,1}//;
		 # remove anything with digits and "->"
		# avoid T-S3 changing to TS3
	}
# Maybe later we can use such mod information somehow
	if ($main::showlist =~ /,mods,/ && $p ne $stuff) {
		print " B:",$p,"\n A:",$stuff,"\n";
		print " mod:$mod\n";
	}

	# Back in gt3-game1 I tended to put prices in parentheses
	#  But they do not seem semantically significant
	while ($stuff =~ /\((Cr\d+[^()]*)\)/ ) {
		#  72   buy parts Trueno SpSusp (Cr3,000)
		#  72   buy parts Trueno SpSusp (Cr3000)
		# Add space in case parenthesis was used as token separator
		$stuff =~ s/\((Cr\d+[^()]*)\)/ $1/;
		#  72   buy parts Trueno SpSusp  Cr3000
	}
	$stuff =~ s/\(\?\)//g;  # FWIW
	$stuff =~ s/,/ /g;  # Any remaining commas could be spaces
	$stuff =~ s/\+/ /g; # I use "pol+bal" a lot; also "cage+refresh"
	$stuff =~ s/\s+/ /g;   # Multiple spaces not semantically significant
	$stuff =~ s/\s*$//;  # just to be sure
	$stuff =~ s/^\s*//;  # just to be sure
	#  Note in GT3 you bought tire combinations e.g. T-R3/T-R3
  	#  66   buy parts Trueno T2/T2 (Cr10,000)

	#return ($op, $tok. $stuff);  # Sure I assigned funcs to arrays before
	return $op . " " . $tok . " " . $stuff;
}

sub
doparts {
	my($car,$line) = @@_;


	my($buf);
	my($stuff, $op);
	my ($tok);

	# Not sure why we didn't break out $rest for this case
	print " ${main::maxtoday} Parts: $line\n" if ($main::showlist =~ /,trace,/ );
	#($op, $tok, $stuff) = normalizeparts($car,$line);
	$buf = normalizeparts($car,$line);
# A question becomes, what should be left after normalize ?
#  For now we leave anything left in parentheses, and also NNNkg and NNNhp
#	print "$buf\n"  if ($main::showlist =~ /,rawparts,/ );
	($op, $tok, $stuff) = split(/\s/,$buf,3);
# N.B. if you don't specify ",3" you get only the first solitted element
	print "$op $tok :$stuff\n"  if ($main::showlist =~ /,rawparts,/ );

# Mostly gt3-game1 use of parentheses...
# Old "alias" throwback
#   (alias [R]FalconXR8)
# Tuner names
#   (Trial)
#   (HKS)
#   (Mine's)
#   (Amuse)
#   (from Blitz)
# "Daily wheels"
#   (daily)
# Colours (for wings and wheels)
#   (silver)
#   (Black)
#   (black)
#   (yellow)
#   (red)
#   (red 4x2 spokes)
# Asides
#   (don't fit)
# Alternate GT3 tire designations
#   (SSl/SSl)
#   (M/M)
#
# Also brief attempt in gt4-game2 to track the "codenames"
# I will simply remove those, however.
# buy Cougar :Rtrans("FC") 3clu("TR") Cr10000 Cr4600

# So...
#  buy Crossfire :NA1 NA2 Cr4700 Cr12000 chip N2O Cr1250 Cr5000
#  becomes $parts{"Crossfire:NA1"} = "Cr4700";
#  becomes $parts{"Crossfire:NA2"} = "Cr12000";
#  becomes $parts{"Crossfire:chip"} = "Cr4700";
#  becomes $parts{"Crossfire:N2O"} = "Cr5000";
#
# Assume Cr0 applies to all everything before it, i.e.
# buy redSkyline'67 :T-N1 T-N2 T-N3 Cr0 T-S1 T-S3 Cr4100 Cr5600
# becomes $parts{"redSkyline'67:T-N1"} = "Cr0";
# becomes $parts{"redSkyline'67:T-N2"} = "Cr0";
# becomes $parts{"redSkyline'67:T-N3"} = "Cr0";
# becomes $parts{"redSkyline'67:T-S1"} = "Cr4100";
# becomes $parts{"redSkyline'67:T-S3"} = "Cr5600";
#
# Except we want to use   car2495 redSkyline'67 Nissan Skyline 2000GT-B ...
# So...  $parts{"car2495:T-N1"} = "Cr0";
# etc...
#
	my($id);
	my(@@prices);
	my(@@parts);
	my(@@tokens);
	my($t,$p);

	@@prices = ();
	@@parts = ();
	$id = findcarid($tok);
	if (!defined($id)) {  # probably can't happen
		&warn("Cannot find carid for $tok, $line\n");
		return;
	}
	if ($stuff =~ /\bwheel/ || $stuff =~ /\bwing/ ) {
		# This test is very data dependent
		$t = "Cr0";
		if ( $stuff =~ /\b(Cr\d+)\b/ ) {
			$t = $1;
			$stuff =~ s/\bCr\d+\b//;
			$stuff =~ s/\s+/ /g;
		}
		$p = $id.":".$stuff;
		$main::carparts{$p} = $t;
		return;
	}
	$stuff =~ s/\s+\([^\)]*\)\s+/ /g;  # till we figure out how to process
	$stuff =~ s/\s+\([^\)]*\)/ /g;  # till we figure out how to process
	$stuff =~ s/\([^\)]*\)\s+/ /g;  # till we figure out how to process
	# Any remaining parentheses must be embedded in a "token"...
	$stuff =~ s/\([^\)]*\)//g;  # till we figure out how to process
	$stuff =~ s/\s+/ /g;
	$stuff =~ s/^\s+//g;  # sigh.  split will return empty tokens...
	$stuff =~ s/\s+$//g;
	@@tokens = split(/\s+/,$stuff);
	for $t (@@tokens) {
		if ($t =~ /^\d+hp$/i || $t =~ /\d+kg/i ||
			$t =~ /^\(/ || $t =~ /\)$/ ) {
			; # skip these "comments"
			# problem: we handle "(this comment)"
			#            but not "(this is a comment)"
			# Except that we removed them earlier...
		}
		elsif ($t eq "Cr0") {
			while (defined($p = shift(@@parts)) ) {
				$p = $id.":".$p;
				$main::carparts{$p} = $t;
			}
		}
		elsif ($t =~ /^Cr\d/) {
			if (!defined($p = shift(@@parts)) ) {
				if ($main::var{'checkparts'}) {
					&warn("No part for $t, $line\n");
				}
			}
			else {
				$p = $id.":".$p;
				$main::carparts{$p} = $t;
			}
		}
		else {
			$t =~ s/\s*\(.*\)\s*//;
			push @@parts, $t;
		}
	}
	while (defined($p = shift(@@parts)) ) {
		$p = $id.":".$p;
		if ($main::showlist =~ /,carparts,/ ||
			  $main::showlist =~ /,warn,/ ) {
			if ($main::var{'checkparts'}) {
				&warn("No price for $p, $line\n");
			}
			# currently a problem with "wheels" purchases
		}
		$main::carparts{$p} = "Cr0";
	}
}

sub
dobuy {
	my($line,$rest,$r1,$r2,$stuff) = @@_;
	my($day,$sf,$fullname);

	print " ${main::maxtoday} Buy: $rest\n" if ($main::showlist =~ /,trace,/ );
	if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
		$sf = $1;
		if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
			$fullname = $2;
			$fullname =~ s/^[^\w\[]*//;
			$fullname =~ s/->\s.*//;
			$fullname =~ s/\s*$//;
			$fullname =~ s/^\s*//;

			my ($prize,$rest);
			$rest = $fullname;
			if ($rest =~ /\(prize.*\)/i) {
				# This lets us expand prize names of purchases
				$prize = $rest;
				$rest =~ s/^.*(\(prize)/$1/i; # )) for vi
				$prize =~ s/\(prize.*$//i;
				if (defined($main::fullprizenames{$prize}) ) {
					$fullname = $main::fullprizenames{$prize};
					$fullname .= $rest

				}
			}

			&getcar($sf,$fullname,$line);
			if ($main::showlist =~ /,buy,/i) {
				print "${main::maxtoday}:buy $sf - $fullname.\n";
			}
		}
		else {
			&getcar($sf,$sf,$line);
		}
	}
	elsif ($stuff =~ /^\s*parts\s+(\S+) /) {
		checkcar($1,$line);
		addcarlog($1,$line);
		doparts($1,$line);
	}
	elsif ($stuff =~ /^\s*wheels\s+/) {
		# In gt4, wheels are really a part
		;
	}
	else {
		&warn("Bad purchase: $line\n");
	}
}

sub
dodaynote {
	my($line,$rest,$r1,$r2) = @@_;
	my($day,$stuff,$sf,$fullname);

	print " ${main::maxtoday} Daynote: $rest\n" if ($main::showlist =~ /,trace,/ );
	if (!&daycheck($r1) ) {
		&warn("Bad single day note(not ${main::maxtoday}): $_\n");
	}
	# grr... seems difficult to undef $1 ...
	if ($rest =~ /^buy\s+(.*)/ && defined($1)) {
		$stuff = $1;
		dobuy($line,$rest,$r1,$r2,$stuff);
	}
	if ($rest =~ /^win\s+(.*)/ && defined($1)) {
		dowin($line,$rest,$r1,$r2);
	}
	if ($rest =~ /^change\s+(.*)/ && defined($1)) {
		my ($stuff) = ($1);
		$stuff =~ s/^\s*oil\s*//;
		$stuff =~ s/^\s*car\s*//;
#print "stuff:$stuff\n";
# this was cheating; eventually identifier will be checked
		if ($stuff =~ /^(\S+)/ && defined($1) ) {
			checkcar($1,$line);
			addcarlog($1,$line);
		}
		else {
			&warn("Bad change: $line\n");
		}
	}
	if ($rest =~ /^mod\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "stuff:$stuff\n";
# this was cheating; eventually identifier will be checked
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
			checkcar($1,$line);
			addcarlog($1,$line);
			doparts($1,$line);
		}
		else {
			&warn("Bad mod: $line\n");
		}
	}
	if ($rest =~ /^sell\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "sell stuff:$stuff\n";
		print " ${main::maxtoday} Sell: $rest\n" if ($main::showlist =~ /,trace,/ );
		&sell($stuff);
	}
	# Unrecognized lines are effectively comments

	$main::mintoday = $r2;
	$main::maxtoday = $r2;
}

sub
donote {
	my($line) = @@_;

	print " ${main::maxtoday} Note: $line\n" if ($main::showlist =~ /,trace,/ );
	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		addcarlog($main::mentioned,$line);		
	}
}

$main::saveline = "";   # Kludge to support autoinclude
sub
getlog {  # get lines, closing includes
	no strict 'refs';
	#my($line) = @@_;
	my($line);
	my($n);


	for (;;) {
		$line = <$main::fid>;
		if (!defined($line)) {
			close($main::fid);
			$n = $main::fid;
			$n =~ s/LOG//;
			if ( $n == 0 ) {
				return $line;
			}
			--$n;
			$main::fid = 'LOG' . "$n";
			if ($main::saveline ne "" ) {
				$line = $main::saveline;
				$main::saveline = "";
				return $line;
			}
		}
		else {
			return $line;
		}
	}
}

my($log,$daylimit);

$main::lastdateline = "";
%main::carlogs = ();
sub
addcarlog {
	my($car,$line) = @@_;

	if ($car eq "" || $car eq "no car selected") {
		return;
	}
	if (!defined($main::carlogs{$car})) {
		$main::carlogs{$car} = "";
		if ($main::showlist =~ /,verbose,/) {
			$main::carlogs{$car} = $main::lastdateline;
		}
	}
	if ($line !~ /^\s*$/) {
		$main::carlogs{$car} .= $line."\n";
	}
}
	

while ( defined($ARGV[0]) ) {
	my($temp);
	if ( $ARGV[0] =~ /^show=/i ) {
		$temp = $ARGV[0];
		$temp =~ s/^show=//i;	
		$temp = ",$temp,";
		$temp =~ s/,+/,/g;
		# Expand a few lazy alternatives we allow
		$temp =~ s/,partstotals,/,carpartstotals,/;
		$temp =~ s/,parts,/,carparts,/;
		$temp =~ s/,prices,/,carprices,/;
		# Would be nice to make plurals optional
		$main::showlist .= ",$temp,";
	}
	elsif (!defined($log)) {
		$log = $ARGV[0];
	}
	elsif (!defined($daylimit)) {
		if ($ARGV[0] =~ /^\d+$/) {
			$daylimit = $ARGV[0];
		}
		else {
			$temp = $ARGV[0];
			# change something like "Jan 10"
			#   into a pattern, like...
			# /^Jan[^0-9]*10/
			$temp =~ s/,/ /g;
			$temp =~ s/ +/[^0-9]*/;
			$temp =~ s/$/\\b/;
			$temp =~ s/^/^/;
			$main::enddate = $temp;
			
		}
	}
	shift @@ARGV;
}
if (!defined($log)) {
	$log = "log";
}
if (!defined($daylimit)) {
	$daylimit = -1;
}
if (!defined($main::showlist)) {
	$main::showlist = ",garage,";
}
$main::showlist =~ s/all/pragmas,buy,sell,sales,sold,carids,garage,/;

{
	no strict 'refs';
	if (!open($main::fid,"<$log") ) {
		die "Cannot open log $log.\n";
	}
}


#while ($main::mintoday <= $daylimit && <LOG>) {
while (defined($_ = &getlog())) {
	my($line) = $_;
	my($license,$r1,$r2,$rest);
	my($sp);

	print "$line" if ($main::showlist =~ /,trace,/ );

	last if ($main::done);
	last if ($daylimit > 0 && $main::mintoday > $daylimit);
	$line =~ s/\n//g;
	$license = $line;
	$license =~ s/^.{10}//;
	$license =~ s/(\S+)\s.*/$1/;
	# It is not clear $r1 and $r2 should default to empty
	$r1 = "";
	$r2 = "";
	$rest = $line;
	if ( $line =~ /^[A-Z]/) {
		# Assume a date line; process later
		;
	}
	elsif ( $line =~ /^ {9,9}/ ) {
		# line beginning with 9 spaces assumed to be comment
		;
	}
#	elsif ( $line =~ /^([ \d]{3,3}\d)\-(\d[ \d]{3,3})\s*(.*)/ ) {
#		# Stupid way to try to match pattern...
#		# day range (numbers max 4 digits)
	elsif ( $line =~ /^\s*(\d+)\-(\d+)\b\s*(.*)/ ) {
		$r1 = $1;
		$r2 = $2;    # n.b. must grab all $N before doing other subs
		$rest = $3;
		$r1 =~ s/\s//g;
		$r2 =~ s/\s//g;
	}
	elsif ( $line =~ /^\s*(\d+)\s*\+(\d+)(.*)/ ) {
		# new range indication by +increment
		$r1 = $1;
		$r2 = $2;    # n.b. must grab all $N before doing other subs
		$rest = $3;
		$r2 += $r1;
	}
	elsif ( $line =~ /^\s*(\d+)\s+(.*)/ ) {
		# single day
		$r1 = $1;
		$rest = $2;
		$r2 = $r1;
	}
	elsif ( $line =~ /^\s*(\d+)\s*(.*)/ ) {
		# single day, likely empty, also matches "22Why no space there?"
		$r1 = $1;
		$rest = $2;
		$r2 = $r1;
	}
	$rest =~ s/^\s*//;

	if ($r2 ne "" && $main::var{'includesdone'} == 0) {
		&heuristicinclude($log,$line);
		$main::var{'includesdone'} = 1;
		next;
	}

	# Second parse
	$sp = $main::var{'commentspacecount'};
	if ( $line !~ /^\s*\d+\s/ && $line =~ /^[\s]{$sp,$sp}/ ) {
		# For old log compatibility, $sp can be < 9
		# But assume a leading number indicates an entry
		&donote($line);
	}
	elsif ( $line =~ /^\s*note/i ) {
		&donote($line);
	}
	elsif ( $line =~ /^\s*pragma\b/i ) {
		&dopragma($line);
	}
	elsif ( $line =~ /^\s*include\b/i ) {
		&doinclude($line);
	}
	elsif ( $line =~ /^\s*define\b/i ) {
		&dodefine($line);
	}
	elsif ( $line =~ /^[A-Z]/) {
		&dodateline($line);
	}
	elsif ( $line =~ /^\s*cardef\b/i ) {
		&docardef($line);
	}
	elsif ( $line =~ /^\s*uncardef\b/i ) {
		&douncardef($line);
	}
	elsif ( $line =~ /^\s*setvar\b/i ) {
		&dosetvar($line);
	}
	elsif ( $line =~ /^ {9,9}/ ) {
		# line beginning with 9 spaces assumed to be comment
		# ORLY?
		;
	}
	elsif ( $rest =~ /^rem/i ) {
		# I had used this as "day note comments"...
		&donote($line);
	}
	elsif ( $rest =~ /^[\(]* *Cr[0-9]/ || 
		$rest =~ /^\s*->/ ) {  # ) for vi
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^power\b/i ) {
		$rest =~ s/^power\s*//i;  # process stats on power off lines
		$rest =~ s/^off\s*//i;
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^reset\b/ ) {
		$rest =~ s/^reset\s*//;  # process stats on reset lines
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^save\b/ ) {
		$rest =~ s/^save\s*//;  # process stats on save lines
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^select\b/ ) {
		&doselect($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^buy\b/ ||
		$rest =~ /^change\b/ ||
		$rest =~ /^fit\b/ ||
		$rest =~ /^mod\b/ ||
		$rest =~ /^perm\b/ ||
		$rest =~ /^sell\b/ ||
		$rest =~ /^skip\b/ ||
		$rest =~ /^wash\b/ ||
		$rest =~ /^finito\b/ ||
		$rest =~ /^win\b/ ) {
		&dodaynote($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $rest =~ /^licen[sc]e/ ) {
		# Would be nice to recognize  "8-9    B8 br"
		# B8 should be defined by "racedefs"
		if ($line =~ /^\s*\d+\s+\+\d+/ ) {
			# for historical reasons, use $r2-1
			&dolicenseline($line,$rest,$r1,$r2-1);
			# at least until we reason it out
		}
		else {
			&dolicenseline($line,$rest,$r1,$r2);
		}
	}
	elsif ( $main::var{'licensepatterns'} ne "" &&
		$rest =~ /^$main::var{'licensepatterns'}/ ) {
		&dolicenseline($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\-\d+\s+/ ) {
		# 104-107  R32Skyline'89GT-R Sunday sw27to18      Demio(dup)
		&doseriesline($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\s+\+\d+/ ) {
		# for historical reasons, use $r2-1
                # 231 +5  greyEtype   P/WC   2nd46to(34),19,16,10,5   none
		&doseriesline($line,$rest,$r1,$r2-1);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\s+/ ) {
		# Assume anything else with a day number is a seriesline ?
		if ( $main::var{'noincserieslines'} ) {
			&doseriesline($line,$rest,$r1,$r2);
		}
		else {
			&dodaynote($line,$rest,$r1,$r2);
		}
	}
	elsif ( $line =~ /^\s{0,5}(\d+)\s*$/ ) {
		# We had used lines with just a single day before
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $line =~ /^\s{0,20}\d/ ) {
		&warn("Unrecognized line: $line\n");
	}
	else {
		# Surprisingly, lines beginning "#' will fall through to here
		&donote($line);
	}
#print $main::maxtoday," AFTER: ",$rest,"\n";
}
close ($main::fid);

sub
expand {
	my($s) = @@_;

	$s;
}

if ($main::showlist =~ /,pragmas,/ ) {
	printf("%s\n", $main::pragmas);
}
if ($main::showlist =~ /,rawevents,/ ) {
	my($i);
	for ($i = 0; $i <= $#main::events; ++$i) {
		printf("%s\n", &expand($main::events[$i]) );
	}
}
if ($main::showlist =~ /,events,/ ) {
	my($i,$prev,@@sorted);
	@@sorted = sort @@main::events;
	$prev = "";
	for ($i = 0; $i <= $#sorted; ++$i) {
		if ($sorted[$i] ne $prev) {
			printf("%s\n", &expand($sorted[$i]) );
			$prev = $sorted[$i];
		}
	}
}
if ($main::showlist =~ /,prizes,/ ) {
	my($i,$prev,@@sorted);
	@@sorted = sort @@main::prizes;
	$prev = "";
	for ($i = 0; $i <= $#sorted; ++$i) {
		if ($sorted[$i] ne $prev) {
			printf("%s\n", &expand($sorted[$i]) );
			$prev = $sorted[$i];
		}
	}
}
if ($main::showlist =~ /,carids,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carids) {
		printf("%s %s %s (%s)\n", $k, $main::carids{$k},
			$main::carnames{$k}, $main::carstates{$k});
	}
}
if ($main::showlist =~ /,prices,/ || $main::showlist =~ /,carprices,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carprices) {
		printf("%s %s %s\n", $k, $main::carids{$k},
			$main::carprices{$k});
	}
}

sub
tocredits {  # N.B. money, not attributions/accolades
	my ($num) = @@_;
	my ($portion,$remain);
	my ($sign,$s);

	$sign = "";
	$remain = $num;
	if ($remain < 0) {
		$sign = "-";
		$remain = 0 - $remain;
	}
	$s = "";
	for ( ;; ) {
		$portion = $remain;
		$remain = int ( $remain / 1000);
		$portion -= $remain * 1000;
		if ($remain > 0) {
			$s = sprintf(",%3.3d", $portion) . $s;
		}
		else {
			$s = sprintf("Cr%d", $portion) . $s;
		}
		last if ($remain <= 0);
	}
	return $sign . $s;
}
sub
fromcredits {  # N.B. money, not attributions/accolades
	my ($s) = @@_;
	my ($num);

	$s =~ s/^Cr//i;
	$s =~ s/,//g;
	$num = 0 + $s;
	return $num;
}
	
if ( $main::showlist =~ /,carparts,/ ||
		$main::showlist =~ /,carpartstotals,/ ) {
	my($k,$cark,$car);
	my($prevk,$total,$prevcar);
	$prevk = "";
	$prevcar = "";
	$total = 0;
	foreach $k (sort caridcolonsub keys %main::carparts) {
		$cark = $k;
		$cark =~ s/:.*//;
		$car = $main::carids{$cark};
		$car = "WHAT?" if (!defined($car));
		if ( $cark ne $prevk ) {
			if ($prevk ne "" &&
				   $main::showlist =~ /,carpartstotals,/ ) {
				printf("%s %s:Total %s\n", $prevcar, $prevk,
					&tocredits($total) );
			}
			$prevk = $cark;
			$prevcar = $car;
			$total = 0;
		}
		if ( $main::showlist =~ /,carparts,/ ) {
			printf("%s %s %s\n", $car, $k, $main::carparts{$k});
		}
		$total += &fromcredits($main::carparts{$k});
	}
	if ($prevk ne "" && $main::showlist =~ /,carpartstotals,/ ) {
		printf("%s %s:Total %s\n", $prevcar, $prevk,
			&tocredits($total) );
	}
	
}
if ($main::showlist =~ /,garage,/ ) {
	my($k,$i);
	$i = 0;
	foreach $k (sort caridsub keys %main::carids) {
		# Perhaps we should use eq "got"
		if ($main::carstates{$k} ne "sold" &&
			$main::carstates{$k} ne "alias") {
			printf("%3d %s\n", $i+1, $main::carnames{$k});
			++$i;
		}
	}
}
if ($main::showlist =~ /,licen[sc]e,/ ) {
	my($i,@@sorted);
	@@sorted = sort lidsub keys %main::lresults;
	for ($i = 0; $i <= $#sorted; ++$i) {
		printf("%s: %s\n", $sorted[$i], $main::lresults{$sorted[$i]} );
	}

	
}
if ($main::showlist =~ /,origin,/ ) {
	# Shows origins based on carid
	my($i,@@sorted);
	@@sorted = sort caridsub keys %main::origin;
	for ($i = 0; $i <= $#sorted; ++$i) {
		printf("%s - %s\n", $sorted[$i], $main::origin{$sorted[$i]} );
	}
}
if ($main::showlist =~ /,models,/ ) {
	# Shows models based on carid
	my($i,@@sorted);
	@@sorted = sort caridsub keys %main::carmodels;
	for ($i = 0; $i <= $#sorted; ++$i) {
	      printf("%s - %s\n", $sorted[$i], $main::carmodels{$sorted[$i]} );
	}
}
if ($main::showlist =~ /,carlog,/ ) {
	my($i,@@sorted);
	@@sorted = sort keys %main::carlogs;
	for ($i = 0; $i <= $#sorted; ++$i) {
		my($sf,$ci,$org);
		$sf = $sorted[$i];
		#$ci = $main::carid{$sf};
		$ci = findcarid($sf,"");
		if (defined($ci) && defined($main::origin{$ci}) ) {
			$org = $main::origin{$ci}."\n";
		}
		else {
			$org = "";
		}
		printf("%s:\n", $sf );
		printf("%s", $org );
		printf("%s\n", $main::carlogs{$sorted[$i]} );
	}
}

if ($main::showlist =~ /,vars,/ ) {
	my($i,@@sorted);
	@@sorted = sort keys %main::var;
	for ($i = 0; $i <= $#sorted; ++$i) {
	      printf("%s - %s\n", $sorted[$i], $main::var{$sorted[$i]} );
	}
}
@


1.101
log
@Finally changed a "Stupid" pattern match to what it should have been.
gt1 and gt2 logs are no longer limited to day numbers below 10000, FWIW.
 
Rearranged the setvar variables to classify approximately by type.
I.e. primarily whether they reflect changes needed for different games,
or merely different habits of the person creating the logs for different
games.
 
Added usage/explanation comments indicating that gt1, gt2 and gt3
logs can now be handled (also ARRI).
(Documented recent show=trace)
@
text
@d128 2
a129 1
$main::selected = "";
d311 4
a314 1
		return 1 if (findcarid($car,$line));
d827 1
a827 1
		addcarlog($main::selected,$line);		
d865 1
d872 1
d880 1
d1576 1
a1576 1
		addcarlog($main::selected,$line);		
d1659 2
a1660 2
	if ($main::selected ne "") {
		addcarlog($main::selected,$line);
d2086 1
a2086 1
		addcarlog($main::selected,$line);		
@


1.100
log
@To allow the autoinclude to work (triggered by first real day note)
we need to change at least $main::var{'commentspacecount'} to be
a default suitable for older logs.
 
It seems sufficient, but it actually makes sense all defaults should
be for the older logs.  Sigh.

But we can assert that defaults which will never apply before the first
actual daynote do not need to have the older values.
@
text
@d6 1
a6 1
# gt4garage produces a garage listing for optional given simday
d9 10
d50 1
d71 1
a80 5
#   It would be nice, but likely not possible, to arrange that
#     gt1 and gt2 logs could be processed too, with suitable gtN-racedefs
#   define recognized cars before win/buy ?  (working towards gt1/gt2)
#  
#
d93 2
d99 1
d101 3
d107 2
d114 2
a115 4
$main::var{'noincserieslines'} = 1;  # 0 for GT1 (made many single day notes)
$main::var{'checkparts'} = 1;   # 0 for GT1, but could set in individual logs
$main::var{'seriescarcruft'} = "";  # kludge for GT1/2 (add patterns)

d118 2
d2067 1
d2219 4
a2222 3
	elsif ( $line =~ /^([ \d]{3,3}\d)\-(\d[ \d]{3,3})\s*(.*)/ ) {
		# Stupid way to try to match pattern...
		# day range (numbers max 4 digits)
@


1.99
log
@Actually implemented "autoinclude".
If $main::var{'includesdone'} has not been set, an auto include of
a hopefully appropriate racedefs file is done (works for test cases),
and the line which should have been processed is stashed for getlog()
to return later.
@
text
@d96 3
a98 1
$main::var{'commentspacecount'} = 9;  # Less was used in older logs
@


1.98
log
@WITH THIS REVISION all old gt1, gt2, gt3 and even ARRI logs would
generate the correct garage, with no spurious diagnostics (in fact
it prompted a few appropriate corrections), so long as an appropriate
racedefs include file is given.
@
text
@d85 1
d1494 1
d1511 26
d2065 1
d2069 2
a2070 1
	my($line) = @@_;
d2085 5
d2230 6
@


1.97
log
@A few dubious changes to match sort of quirky entries in gt2-tm30.
@
text
@@


1.96
log
@With this change, which expands prize names if a fullprizename hash
entry is found, I reduce the differences from ./garage (gt1garage)
output to things like...

-  6 passion red GTO'95MR
+  6 passion red GTO'95MR -> Cr9,880
@
text
@d2236 2
a2237 1
	elsif ( $rest =~ /^Cr[0-9]/ ) {
d2240 3
a2242 3
	elsif ( $rest =~ /^power\b/ ) {
		$rest =~ s/^power\s*//;  # process stats on power off lines
		$rest =~ s/^off\s*//;
d2264 1
@


1.95
log
@Worked a little bit hard to avoid diagnostics for GT1  events Spot/DFRW etc.
@
text
@d1921 52
d1984 1
a1984 31
#print "stuff:$stuff\n";
		print " ${main::maxtoday} Buy: $rest\n" if ($main::showlist =~ /,trace,/ );
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
			$sf = $1;
			if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
				$fullname = $2;
				$fullname =~ s/^[^\w\[]*//;
				$fullname =~ s/->\s.*//;
				$fullname =~ s/\s*$//;
				$fullname =~ s/^\s*//;
				&getcar($sf,$fullname,$line);
				if ($main::showlist =~ /,buy,/i) {
					print "${main::maxtoday}:buy $sf - $fullname.\n";
				}
			}
			else {
				&getcar($sf,$sf,$line);
			}
		}
		elsif ($stuff =~ /^\s*parts\s+(\S+) /) {
			checkcar($1,$line);
			addcarlog($1,$line);
			doparts($1,$line);
		}
		elsif ($stuff =~ /^\s*wheels\s+/) {
			# In gt4, wheels are really a part
			;
		}
		else {
			&warn("Bad purchase: $line\n");
		}
@


1.94
log
@Added "setvar trackdelim" for completeness, but have not
changed it in any logs yets.
Commented about problem with GT1 Spot/DFRW.
 
Added a crude "show=trace" which might have helped me before to
detect when a seriesline was being recognized as a license/timetrial.
@
text
@d89 1
d122 2
a123 1
%main::serieslen = ();
d997 1
a997 1
event_length {
d1000 2
a1001 2
	if (defined($main::serieslen{$event})) {
		return $main::serieslen{$event};
d1005 9
d1100 1
a1100 1
	my($i,$none,$pat,$race,$event,$length,$suff,$prev,$after);
d1136 3
a1138 2
		$length = &event_length($event);
		if ($diff != $length) {
d1474 2
a1475 1
	   $main::serieslen{$value} = $length-1;   # Why -1 ?
@


1.93
log
@Tweaked some matching, and added some potential debug statements.
But actually the bug I was chasing was in "setvar licensepatterns".
@
text
@d91 1
d793 1
d815 1
d833 1
d905 1
d1012 1
a1012 1
	my ($delim);
d1014 1
d1021 1
a1021 1
		if ( $event =~ /([^$delim}]*)\/(.*)/ ) {
d1028 7
a1034 3
	# Later add "trackdelim"
	if ($series =~ /[\/]/) {   # handle a race in a series
		$series =~ /([^\/]*)\/(.*)/;
d1036 1
d1039 1
a1039 1
		$e =~ s/[\/]([^\/]*)*$//;
d1093 1
d1096 1
d1218 2
d1249 1
d1291 1
d1398 1
d1421 1
d1480 1
d1500 1
d1588 1
d1772 2
d1912 1
d1920 1
d1984 1
d1996 1
d2110 2
@


1.92
log
@This, together with an appropriate "setvar licensepatterns"
makes several GT1 logs work silently.  (Other gt1-racedefs, too).
 
Also added useful show=,vars,
@
text
@d46 1
d1068 1
d2101 2
a2102 1
	elsif ( $line =~ /^([ \d]{3,3}\d)\-(\d[ \d]{3,3})(.*)/ ) {
d2246 1
@


1.91
log
@Implement "setvar seriescarcruft" -- actually seems to work.
Implement "setvar autoselectcarids".
 
For "setvar seriescarcruft" I needed to semi-properly process quoted strings.
@
text
@d95 4
a98 1
$main::var{'seriescarcruft'} = "";  # kludge for GT1 (add patterns)
d2210 4
d2427 7
@


1.90
log
@Support for day number alone on a line...
@
text
@d91 1
d95 4
d284 1
a284 1
	if ($main::selected eq "") {
d824 1
d827 2
a828 1
		if ($1 eq "none") {
d832 1
d837 3
a839 3
		if ( findcarid($1,$line) ) {
			$main::selected = $1;
			addcarlog($1,$line);		
d843 6
d1051 18
d1093 1
d1244 22
d1270 11
a1280 1
	if ( !($line =~ /^\s*setvar\s+(\S+)\s*\=\s*([\S]+)/) ) {
a1283 8
	$what = $1;
	$value = $2;
	if ($value =~ /^"/) {
		# can of worms
		$value =~ s/^"//;
		$value =~ s/"\s*$//;
		# currently we do not allow spaces in strings
	}
d1287 4
@


1.89
log
@Add '#' kludge to "define fullprizename"; supported by other worse kludges
Add "setvar checkparts" to allow suppression of parts audit warnings.
@
text
@d2023 1
d2056 6
d2163 4
@


1.88
log
@Some old "sell entry" lines did not work until I arranged to match
against either shortform or fullname.
@
text
@d93 1
d1139 1
d1317 3
a1319 1
	if ($line =~ /^\s*fullprizename\s+(\w+)\s+(.+)$/ ) {
d1322 1
d1790 3
a1792 1
				&warn("No part for $t, $line\n");
d1808 3
a1810 1
			&warn("No price for $p, $line\n");
@


1.87
log
@Might have "sell excess " working, if you know how to use it.
A lot of crucial \s* following token chomps so next test works properly.
Comments about probable historical evolution of the carnames table.
Etc.
 
Now seems to generate correct gt1 garages, modulo unrecognized stuff
in series lines.
@
text
@d505 1
a505 1
	my($i,$k,$what,$temp);
d511 1
d522 7
d545 1
a545 1
	# I do not think we use this
@


1.86
log
@Finally realized that at some point the values of carids{} became
what used to be carnames, so that's what GT1-style sell lines need
to match against.
 
We are now close, but two sales don't seem to work, and there are
extraneous diagnostics.
@
text
@d33 4
d376 2
a377 1
carvariants {
d380 5
d399 1
d402 1
a402 4
			if ( $main::carnames{$i} =~ /$car/i ||
					$main::carnames{$i} =~ /$car1/i ||
					$main::carnames{$i} =~ /$car2/i ||
					$main::carids{$i} =~ /$car/i ||
d406 1
a406 1
				$hash{$main::carnames{$i}} = 1;
d431 1
d680 1
d698 1
a698 1
			$stuff =~ s/^\d+//;
d712 1
a712 1
			$stuff =~ s/^[\w'\/\[\]\-#.]+//;
@


1.85
log
@Making progress towards sensible handling of old GT1-style "sell" lines.
It's working better, but not completely correctly.
@
text
@d393 4
a396 1
					$main::carnames{$i} =~ /$car2/i ) {
d399 1
d418 1
d427 2
a428 1
				$main::carnames{$i} eq $car ) {
d447 4
a450 1
					$main::carnames{$i} =~ /$car2/i ) {
@


1.84
log
@Add some //i to car selling function.
(In preparation for changing (prize,Sunday) to (Prize,Sunday) for
prizes on the series line).
Annote sellcar.
@
text
@d485 1
a485 1
sellentry {
d489 1
d528 1
a528 1
	my($i,$what,$temp,$temp2);
d545 5
a549 1
		if ( ($temp eq "$car" || $temp2 eq "$car")
d553 1
d565 4
a568 1
		if ($temp eq "$car" && $main::carstates{$ix} ne "sold" &&
d580 4
a583 1
		if ($temp =~ /\(prize/i && $temp =~ /$car/i &&
d603 4
a606 1
		if ($temp =~ /\(prize/i && $temp =~ /$car/i &&
d615 1
@


1.83
log
@Implement  setvar noincserieslines   for GT1
Name is confusing...
@
text
@d537 1
d543 1
a543 1
		$temp2 =~ s/\s*\(prize[^\)]*\)\s*$//;
d554 1
d558 1
a558 1
		$temp =~ s/\(prize.*\)$//;
d568 2
d571 1
a571 1
		if ($temp =~ /\(prize/ && $temp =~ /$car/i &&
d580 1
d588 2
d591 1
a591 1
		if ($temp =~ /\(prize/ && $temp =~ /$car/i &&
@


1.82
log
@Add a bunch of \b which probably should have been there.
I've seen \b break things before, however.
Also implement  define fullprizename
@
text
@d88 1
a2028 4
	elsif ( $line =~ /^\s*fullprizename\b/i ) {
		# Should not need this?
		&dofullprizename($line);
	}
d2034 4
d2091 6
a2096 1
		&doseriesline($line,$rest,$r1,$r2);
@


1.81
log
@Add "setvar commentspacecount" to make one less thing we need to
change in old GT1 logs.
 
Prepare for fullprizenames hash.
@
text
@d1024 1
d1051 1
d1258 19
d1282 1
d1286 4
d2007 1
a2007 1
	elsif ( $line =~ /^\s*pragma/i ) {
d2010 1
a2010 1
	elsif ( $line =~ /^\s*include/i ) {
d2013 1
a2013 1
	elsif ( $line =~ /^\s*define/i ) {
d2019 1
a2019 1
	elsif ( $line =~ /^\s*cardef/i ) {
d2022 1
a2022 1
	elsif ( $line =~ /^\s*uncardef/i ) {
d2025 1
a2025 1
	elsif ( $line =~ /^\s*setvar/i ) {
d2027 4
@


1.80
log
@Handle "servar autocarids = `"
Amazingly seems to allow processing almost all of gt2 logs.
Lots of warnings about sloppy parts lines.
But the basic garage is generated correctly.
@
text
@d87 1
d101 2
d339 4
d719 2
d1086 6
a1091 1
			getcar($prize,"$prize(prize, $race)",$line);
d1929 1
d1941 1
d1971 8
a1978 1
	if ( $line =~ /^\s*note/i ) {
@


1.79
log
@Surprisingly far towards allowing a gt1-racedefs to allow us to process
gt1 logs.  But still a long way from reasonably working.
@
text
@d85 2
a86 1
$main::var{'seriesdelim'} = "/";
d322 2
a323 1
		if ($main::carstates{$k} ne "sold") {
d413 1
d428 1
d457 5
d485 2
a486 1
		if ($main::carstates{$k} ne "sold") {
d536 2
a537 1
			&& $main::carstates{$ix} ne "sold") {
d549 2
a550 1
		if ($temp eq "$car" && $main::carstates{$ix} ne "sold") {
d560 2
a561 1
				$main::carstates{$ix} ne "sold") {
d577 2
a578 1
				$main::carstates{$ix} ne "sold") {
d1163 23
d1209 1
a1227 1
		&warn("Unrecognized car ($carname): $line\n");
d1230 7
d2177 3
a2179 1
		if ($main::carstates{$k} ne "sold") {
@


1.78
log
@Oops.  My handling of "prices", "parts" and "partstotals" options
did not work in cases where multiple options were used.
@
text
@d58 2
d85 1
d912 7
a918 2
	if ( $event =~ /([^\/]*)\/(.*)/ ) {
		($league,$series) = ($1,$2);
d920 11
a930 3
	return 0 if !defined($league) || !defined($main::league{$league});
	return 0 if !defined($series);
	if ($series =~ /[\/]/) {
d933 4
a936 1
		return 0 if !defined($main::series{"$league/$series"});
d940 2
a941 1
		return 0 if !defined($main::series{"$league/$series"});
d984 2
d1014 1
d1138 6
d1211 5
a1215 1
	   if ($value !~ /^([^\s\/]+)\/([^\s\/]+)$/) {
d1217 8
a1224 7
		&warn("Bad series name: $value\n");
	   }
	   else {
		   $league = $1;
	   }
	   if (!defined($main::league{$league})) {
		&warn("Undefined league in series name: $value\n");
d1226 3
d1237 1
a1237 1
	   $main::serieslen{$value} = $length-1;
d1952 4
d1971 2
d1983 1
d1988 1
d1992 1
@


1.77
log
@Arrange to produce output for show=carpartstotals only.

Also arrange for optional "car" on "carparts" and "carpartstotals" to be
handled by effectively changing the option when short form is given.
Also for "carprices".
This could cause us trouble later it we find new places to use the
options...
@
text
@d1780 7
a1786 9
		if ($temp eq "parts") {
			$temp = "car".$temp;
		}
		elsif ($temp eq "partstotals") {
			$temp = "car".$temp;
		}
		elsif ($temp eq "prices") {
			$temp = "car".$temp;
		}
@


1.76
log
@Add show=/,partstotals,/
Somewhat revealing.  GT4 tends to be a lot more costly than GT3.
@
text
@d20 1
d35 1
d37 1
d40 2
a41 1
#   "show=mods" really debugging; shows extracted power and weight mod notes
d43 2
a44 1
#   "show=pragmas"  FWIW
d47 1
a47 1
# Short-term thoughts...
a52 1
#   See diff gt4garage gt4garage-ARRIbeta
a58 1
#      But parts inventory, and perhaps expense, should be possible
d1627 1
a1627 2
		if ($main::showlist =~ /,parts,/ ||
			  $main::showlist =~ /,carparts,/ ||
d1780 9
d2052 2
a2053 1
if ($main::showlist =~ /,parts,/ || $main::showlist =~ /,carparts,/ ) {
d2066 1
a2066 1
					$main::showlist =~ /,partstotals,/ ) {
d2074 3
a2076 1
		printf("%s %s %s\n", $car, $k, $main::carparts{$k});
d2079 1
a2079 2
	if ($prevk ne "" &&
			$main::showlist =~ /,partstotals,/ ) {
@


1.75
log
@Tweaked handling of parentheses in "parts" lines.
@
text
@d2002 39
d2042 5
a2046 1
	my($k,$car);
d2048 3
a2050 3
		$car = $k;
		$car =~ s/:.*//;
		$car = $main::carids{$car};
d2052 10
d2063 6
d2070 1
@


1.74
log
@Improve(?) handling of parenthesized comments in parts lines.
Avoid cases where split returns empty tokens.
@
text
@d1585 4
d1591 2
a1592 2
	$stuff =~ s/^\s+//g;
	$stuff =~ s/\s+$//g;  # sigh.  split will return empty tokens...
@


1.73
log
@Implement "setvar" and use a few instances to ultimately allow
gt4garage to correctly process ARRI-game2
@
text
@d1506 2
d1587 2
d1591 8
a1598 1
		if ($t eq "Cr0") {
a1612 4
		elsif ($t =~ /^\(/ ) {
			# ignore for now
			;
		}
d1614 1
a1614 1
			$t =~ s/\(.*\)//;
@


1.72
log
@Use price for wing or wheels if it was given.
@
text
@d42 7
d61 1
d74 7
d810 2
a811 2
	$main::mintoday = $end + 1;
	$main::maxtoday = $end + 1;
d958 2
a959 2
	$main::mintoday = $end + 1;
	$main::maxtoday = $end + 1;
d1102 16
d1330 7
a1336 1
		&warn("Bad win: $line\n");
d1874 3
@


1.71
log
@Picking away at parts evaluation.
Look for "wheel" and "wing" and treat as a whole line.
But there are still problems.
@
text
@d1535 7
d1543 1
a1543 1
		$main::carparts{$p} = "Cr0";   # should find or choose price
@


1.70
log
@Added the counterpart to the too many prices check.
But it shows there is currently a problem understanding "wheels".
@
text
@d1525 2
a1528 3
	$stuff =~ s/\([^\)]*\)//g;  # till we figure out how to process
	$stuff =~ s/\s+/ /g;
	@@tokens = split(/\s+/,$stuff);
d1534 8
a1541 1
	my($t,$p);
@


1.69
log
@A crude implementation of "show=carparts".
Created caridcolonsub for sorting.
Should indicate parts or mod, and eventually perhaps things which wear.
 
Finds a few mistakes in old logs.
 
We should also indicate for each car the total spent.
Easyish to do.  Hard part is deciding how to format it.
@
text
@d1527 2
d1560 10
@


1.68
log
@Split normalizeparts from doparts.
Cannot remember how to return and assign arrays from functions.
@
text
@d36 1
d146 59
a1519 1
# findcarid is expensive however?
d1521 38
a1558 1

d1924 10
@


1.67
log
@Add and tidy some comments.
Add show=carprices
@
text
@d1303 1
a1303 1
doparts {
a1304 1

d1327 1
d1334 1
d1393 20
a1412 1
print "$op $tok :$stuff\n"  if ($main::showlist =~ /,rawparts,/ );
@


1.66
log
@Comments on "doparts" processing.
Change "+" to spaces.
Remove leading spaces, just in case any end up left.
@
text
@d28 1
a28 1
#     dump stored tables of event/prizes; seem redundant
d34 3
d47 1
d91 1
d94 1
d216 18
d259 1
d1801 7
@


1.65
log
@Finally figured out how we interpret a given carid as a valid car
identifier by looking it up.
Add shortform hash search to findcarid; maybe this is faster?
Document how carlist is an error suppressor.
But that there is no longer any initial "cardata".
@
text
@d1317 1
d1321 1
d1361 1
d1364 1
@


1.64
log
@***** Fix(?) confusion over $carids{} versus $carid{}
***** We should really compare results before and after this change
@
text
@d106 1
d1007 4
d1013 1
a1015 5
	if (defined($main::carids{$carname})) {
		# I think this is just plain wrong...
		# We were lucky we never got any matches?
		return $carname;
	}
d1019 1
d1043 1
@


1.63
log
@Add show=mods
(Really just conditional debugging)
Comment on how we will generate inventory from "buy parts" and "mod" lines.
Segue into discussion of %carids versus %carid
@
text
@d1007 3
d1011 2
@


1.62
log
@Comment about parts "codenames".
@
text
@d234 1
a234 1
	$main::carid{$shortform} = $newid;
d1006 1
d1275 1
d1318 22
d1385 20
@


1.61
log
@Show $op in rawparts
So removed "+1" if it occurred.
Listed observed use of parentheses.
@
text
@d1356 5
@


1.60
log
@Picking away at evaluation of raw parts line.
@
text
@d1287 5
d1325 1
d1331 25
a1355 1
print "$tok :$stuff\n"  if ($main::showlist =~ /,rawparts,/ );
@


1.59
log
@Adding preparation for analysis to turn "buy parts" into an "inventory".
@
text
@d1301 2
a1302 2
	while ($stuff =~ /,Cr/i ) {
		$stuff =~ s/,Cr/ Cr/ig;
d1311 11
d1323 2
@


1.58
log
@Add show=models
My idea is carmodels hash might later be used for parts checking.  Maybe.
@
text
@d68 1
a68 1
@@main::cardata = ();   # now we initialize all data via "mod car" in the log
d111 1
a111 1
lidsub() {  # sort B1..A1..IB1..IA1..S1..S16
d1269 48
d1348 1
d1351 1
d1382 1
@


1.57
log
@Crucial changes to allow log author to make "sell" work in cases
where the car name contains pattern characters (specifically "()")
@
text
@d84 8
d236 16
d1648 8
@


1.56
log
@Add comments indicating what this program does.
Also indicate its options.
And also suggest future possibilities for what this program might do,
although the marginal utility of new features is decreasing.
@
text
@d323 2
d331 1
a331 1
		print "${main::maxtoday}:$match ($what) sold!\n";
@


1.55
log
@Use record_race_prize.
@
text
@d3 50
@


1.54
log
@Modularize record_race_prize
Perhaps fix a bug, perhaps change a specification.
 
Modularize race_to_set which currently has a kludge for GT4 SC events.
@
text
@d748 1
a748 1
	my ($r,$s) = @@_;
d756 2
d1158 5
a1162 1
			if (defined($main::prize_event) && $main::prize_event ne "") {
d1164 5
a1168 5
				if ($event eq "") {
					$e = race_to_set($e);
					$fullname =~ s/$/ (prize,$e)/;
					# push event info here...
				}
d1178 1
@


1.53
log
@Make the kludge perhaps a little more justifiably general.
@
text
@d747 14
d855 1
a855 12
	if ($prize !~ /credits/ && &otherprize($prize) == 0) {
		$temp = $prize;
		$temp =~ s/\(sold\)//;
		$temp =~ s/\(dup\)//;
		push @@main::prizes,"${race}: $prize";
	}
	$temp = $prize;
	$temp =~ s/\(sold\)//;
	$temp =~ s/\(dup\)//;
	if ($prize !~ /credits/ && &otherprize($temp) == 0) {
		push @@main::events,"${race}: $temp";
	}
d1087 23
d1159 1
a1159 13
					# A prize is for the set, not the race
					# Perhaps this depends on pragma
					# Or perhaps we need "prizeevent" defns
					if ($e !~ m:/(Easy|Normal|Hard)/: ) { # ugh!
						while ($e =~ m:/.*/: ) {
							$e =~ s:/[^/]*$:: ;
						}
					}
					else {  # and ugh!
						$e =~ s/R$//;
						$e =~ s/ii$//;
					}
					# Is space in the following correct?
d1161 1
@


1.52
log
@Kludge, at least for now, to avoid saying only "SC/Easy" set for
GT4 SC (special conditions) events.
@
text
@d1135 2
a1136 1
					if ($e !~ m:^SC/: ) { # ugh!
@


1.51
log
@Try to sell both literal garage entry, and entry without (prize,P/Sunday)
Actually seemed to work.

Raises the question of whether our sales methods are reasonable.
@
text
@d1135 8
a1142 2
					while ($e =~ m:/.*/: ) {
						$e =~ s:/[^/]*$:: ;
@


1.50
log
@*** BAd version*** half-implemented garage prize annotation.
Seems to have broken lots of old "sell" and then "select".
@
text
@d326 1
a326 1
	my($i,$what,$temp);
d339 5
a343 1
		if ($temp eq "$car" && $main::carstates{$ix} ne "sold") {
d412 3
@


1.49
log
@Move the growing "win" processing into a subroutine for modularity.
@
text
@d1083 1
d1085 4
a1088 2
	if ($rest =~ /^win\s+(.*)/ && defined($1)) {
		$stuff = $1;
d1090 17
a1106 2
		if ($main::selected ne "") {
			addcarlog($main::selected,$line);
d1108 25
a1132 12
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
$main::prize_event = "";
			$sf = $1;
			if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
				$fullname = $2;
				$fullname =~ s/^[^\w\[]*//;
				$fullname =~ s/->\s.*//;
				$fullname =~ s/\s*$//;
				$fullname =~ s/^\s*//;
				getcar($sf,$fullname,$line);
				if ($main::showlist =~ /,buy,/i) {
					print "${main::maxtoday}:win $sf - $fullname.\n";
d1135 4
a1138 2
			else {
				getcar($sf,$sf,$line);
d1142 8
a1149 1
			&warn("Bad win: $line\n");
d1151 1
@


1.48
log
@Half-implemented recognition of "next" followed by +1 win prizes.
@
text
@d1078 38
d1156 1
a1156 26
		$stuff = $1;
#print "stuff:$stuff\n";
		if ($main::selected ne "") {
			addcarlog($main::selected,$line);
		}
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
$main::prize_event = "";
			$sf = $1;
			if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
				$fullname = $2;
				$fullname =~ s/^[^\w\[]*//;
				$fullname =~ s/->\s.*//;
				$fullname =~ s/\s*$//;
				$fullname =~ s/^\s*//;
				getcar($sf,$fullname,$line);
				if ($main::showlist =~ /,buy,/i) {
					print "${main::maxtoday}:win $sf - $fullname.\n";
				}
			}
			else {
				getcar($sf,$sf,$line);
			}
		}
		else {
			&warn("Bad win: $line\n");
		}
@


1.47
log
@Last change also added oil changes to carlog,verbose,
But it included a spurious removal of newlines, which I have undone.
@
text
@d21 1
d688 2
d692 1
a692 1
	return 1 if ($prize eq "next");
d769 1
a769 1
		&warn("Unrecognized race: $event\n");
d828 6
d843 3
a845 1
	push @@main::events,"${race}: $prize";
d1124 1
@


1.46
log
@Add datelines to carlog.
@
text
@d1188 3
a1190 1
			close($main::fid); $n = $main::fid; $n =~ s/LOG//;
@


1.45
log
@Add verbose carlog to include comments (notes) and status lines.
Tweak the handling of "select car none" to allow us to avoid logging
things to a particular carlog.
@
text
@d523 5
d1133 14
d1188 1
a1188 3
			close($main::fid);
			$n = $main::fid;
			$n =~ s/LOG//;
d1203 1
d1214 3
@


1.44
log
@Note that '#' lines work, semi-accidentally.
@
text
@d551 5
a555 1
			$main::selected = "";
d1014 3
d1154 3
d1191 3
d1197 3
a1199 1
	$main::carlogs{$car} .= $line."\n";
@


1.43
log
@Throwing gt1 and gt2 logs against this found a few failed assertions
of sorts.
@
text
@d1356 1
@


1.42
log
@Usually use the first applicable cardef.
There is a problem when an explicit cardef occurs after the
appropriate one for acquisition.

Log prizes won to the currently selected car.
A problem is that we leave selection selected when doing missions.
@
text
@d31 1
d150 15
d176 1
d280 1
d290 1
d311 1
d316 1
d341 1
d353 1
d363 1
d379 1
d500 1
d709 6
a714 3
	$event =~ /([^\/]*)\/(.*)/;
	($league,$series) = ($1,$2);
	return 0 if !defined($main::league{$league});
d749 7
a755 2
	$rest =~ /(\S+)\s+(\S+)\s+(.*)/;
	($car,$event,$after) = ($1,$2,$3);
d1040 9
d1452 1
@


1.41
log
@Discovered I already had findcarid routine.
But there is a problem that really you want to evaluate each
carid at the game day it is selected, not afterwards.
That is not very easy.
 
But, for instance, if you do
./gt4garage show=carlog gt4-game1 500
by limiting days evaluated to 500, you avoid some ambiguities.
@
text
@d878 2
a879 1
				# should we warn here?
d881 3
a883 1
				return undef;
d1054 3
@


1.40
log
@Arranged to indicate origin of most cars, but a few don't get any.
Also I seem to have a bad habit of re-using the shortform, thereby
overwriting and earlier one with a later one.  E.g. the result
shows car obtained after being used.
@
text
@d154 1
a154 1
	$main::carids{$newid} = $shortform;
d1390 2
a1391 1
		$ci = $main::carid{$sf};
@


1.39
log
@Working towards showing the car origin in carlog.
Can now show the log line which is the origin of each carid.
@
text
@d29 2
d159 1
d1388 12
a1399 1
		printf("%s:\n%s\n", $sorted[$i], $main::carlogs{$sorted[$i]} );
@


1.38
log
@Add short form to "buy" (actually acquisition) output.
@
text
@d76 1
a76 1
caridsub() {
d81 1
d83 1
d94 1
d96 1
d148 1
a148 1
	my($shortform,$fullname) = @@_;
d156 1
d791 1
a791 1
			getcar($prize,"$prize(prize, $race)");
d1025 1
a1025 1
				&getcar($sf,$fullname);
d1031 1
a1031 1
				&getcar($sf,$sf);
d1056 1
a1056 1
				getcar($sf,$fullname);
d1062 1
a1062 1
				getcar($sf,$sf);
d1372 8
@


1.37
log
@Sudden inspiration to add show=carlog
Works well except it doesn't show the origins of the car.
Seems to suggest I only used at most 162 of my 538 cars.

Works for GT3, too.  (51 of 149 were used)
@
text
@d1022 1
a1022 1
					print "${main::maxtoday}:buy $fullname.\n";
d1053 1
a1053 1
					print "${main::maxtoday}:win $fullname.\n";
@


1.36
log
@Changes to hopefully allow lines like...
 135 power off Cr429,209   1.0%   1015A 0B   Slicense  0G 3S 77B  28cars
Also changes to allow
 2547     license S-16 S Nurb   7:20.233S  (many tries)  +12.533G
I.e. hyphens in license test names.
@
text
@d522 1
d727 1
a727 1
	
d1031 1
d1070 1
d1119 12
d1367 7
@


1.35
log
@Added indicator of how to reset $1
@
text
@d569 1
a569 1
	my($line,$start,$end) = @@_;
d586 2
a587 2
	$lid = $line;   # Note, line includes the day number
	$lid =~ s/\s*\d+\s+//;  # Remove day number
d589 1
d596 2
a597 1
	elsif ($lid !~ /^[I]{0,1}[BAS][\d]{1,2}$/ || $lid =~ /IS/) {
d601 3
a603 2
		$medal = $line;
		$medal =~ s/\s*\d+\s+//;  # Remove day number
d605 2
a606 1
		$medal =~ s/^I{0,1}[BAS]\d+(\([^ ]*){0,1}\s+//;  # Remove $lid; we allow IS!
d1237 9
a1253 2
		$rest =~ /^power\b/ ||
		$rest =~ /^reset\b/ ||
d1263 1
a1263 1
			&dolicenseline($line,$r1,$r2-1);
d1267 1
a1267 1
			&dolicenseline($line,$r1,$r2);
@


1.34
log
@Added some use of "pragmas" to make this still work
(i.e. not complain incorrectly, but do less checking) for GT3.
In gt3-game1 we did lots of "   power off  CrNNN ..."
@
text
@d956 1
@


1.33
log
@Did a crude comparison of log license results to compiled license results.
@
text
@d581 5
a631 2
	$main::mintoday = $end + 1;
	$main::maxtoday = $end + 1;
d959 3
a961 1
	if ( $rest =~ m:([0-9]{1,2}[GB][ /]{1,3}[0-9]{1,2}[S][ /]{1,3}[0-9]{1,2}[GB]): ) {
@


1.32
log
@Flag "license G B1" as an error; don't interpret as "test G<null>".
Indicate "handle coffee later".
Fix status line day error message.
 
Indicate what's needed to flag errors in license medal totals.
Not sure best way to do it.
@
text
@d969 7
d977 5
a981 1
			printf "%s %s - %s\n", $r1, $licstats, $s;
@


1.31
log
@Trying to audit license results.
@
text
@d54 2
d64 2
d587 7
a593 1
	if ($lid !~ /coffee/) {
d949 1
a949 1
		&warn("Bad single day note(not ${main::maxtoday}): $_\n");
d968 1
@


1.30
log
@Switch "Cr" lines from no-op "dodaynote" to future "dostatusline".
In particular, we want to check 3G 19S 68ÂB.  Perhaps car count also.
@
text
@d524 15
d945 17
@


1.29
log
@Detailed improvement(?) to allow e.g. IA15(!)
@
text
@d919 17
d1167 1
d1171 1
a1171 1
		&dodaynote($line,$rest,$r1,$r2);
@


1.28
log
@Remove debugging statements.
Add warning about hard-to-parse license results if in license mode.
@
text
@d572 1
a572 1
		$medal =~ s/^I{0,1}[BAS]\d+\s+//;  # Remove $lid; we allow IS!
@


1.27
log
@Added ,license, show keyword
Wasted/used lots of time discovering limitations on use of \b
in pattern matching.  But finally I think I'm at the point where
I should change my old log to clarify a couple of ambiguities
or data errors.
@
text
@d577 1
d579 3
a581 1
print "S14 medal=$medal\n" if ($lid eq "S14");
d589 1
a589 1
print "S14 medal=$medal\n" if ($lid eq "S14");
d598 1
a598 1
print "S14 medal=$medal\n" if ($lid eq "S14");
@


1.26
log
@I think we are tracking medal results.
@
text
@d49 23
d530 1
d554 1
a554 1
#&warn("Good license line:$_\n");
d562 3
a564 2
	$lid = $line;
	$lid =~ s/^licen[^ ]*\s+//;
d567 1
d570 1
d572 24
a595 4
		$medal =~ s/^[^ ]+\s+//;
		$medal =~ s/^[^ ]+@@[^ ]+//;   # FordGT@@Seattle
		$medal =~ /^[0-9\s]([FBSG])/; # 1st medal letter
		$medal = $1;
a597 1

d1253 7
@


1.25
log
@/xhbin/perl5 => /usr/bin/perl
@
text
@d501 22
d528 1
d538 15
d1205 2
@


1.24
log
@Changed embarrassing date assumptions.
@
text
@d1 1
a1 1
#!/xhbin/perl5 -w
@


1.23
log
@Fix uncardef so that it actually works.
Needed to add omitted anchors for keyword matches.
@
text
@d456 1
a456 1
	if ($line !~ /1999$/ && $line !~ /200[0-9]$/) {
@


1.22
log
@Implement select (at least partially).
@
text
@d716 1
a716 1
	$line =~ /^\s*uncardef\s+(\w+)/;
d724 4
a727 3
	if (!defined($main::carlist{$what})) {
		delete($main::carlist{$what});
	}
d1040 1
a1040 1
	if ( $line =~ /\s*note/i ) {
d1043 1
a1043 1
	elsif ( $line =~ /\s*pragma/i ) {
d1046 1
a1046 1
	elsif ( $line =~ /\s*include/i ) {
d1049 1
a1049 1
	elsif ( $line =~ /\s*define/i ) {
d1055 1
a1055 1
	elsif ( $line =~ /\s*cardef/i ) {
d1058 1
a1058 1
	elsif ( $line =~ /\s*uncardef/i ) {
@


1.21
log
@Don't refuse a carname because of sold versions.
@
text
@d15 1
d81 15
d485 18
d606 1
a606 1
		findcarid($car,$line);
d859 2
a860 2
		elsif ($stuff =~ /^\s*parts\s+/) {
			;
d898 1
a898 1
			findcarid($1,$line);
d1066 3
@


1.20
log
@Implemented cardef and uncardef, and arranged to use carid concept.
@
text
@d709 2
a710 1
		if ($main::carids{$k} eq $carname) {
@


1.19
log
@Rearranged verbose (optional) output a bit.
Implemented "sell carid".
@
text
@d27 2
a556 7
	#$rest = $line;
	#if ($rest =~ /^\s*(\d+)-(\d+)\s*/ ) {
	#	$rest =~ s/^\s*(\d+)-(\d+)\s*//;
	#}
	#else {
	#	$rest =~ s/^\s*(\d+)\s*//;
	#}
a557 1
# print "$rest\n";
d572 2
a573 4
		if (!defined($main::carlist{$car}) ) {
			&warn("Unrecognized car ($car): $line\n");
			$main::carlist{$car} = $car;
		}
d649 83
d863 1
a863 1
			$main::carlist{$1} = $1;
d1018 6
@


1.18
log
@Rewrote sellentry routine.
And that allowed me to remove $main::garage entirely!
Should be much simpler now, although I could do with some routines
(e.g. marksold, etc.)
@
text
@d189 24
d233 1
a233 1
			print "${main::maxtoday}:$car ($temp) sold!\n";
d243 1
a243 3
	# this does not work
	my($car,$oldest) = @@_;
	my($ix,@@list);
d245 1
a245 11
	@@list = sort caridsub keys %main::carids;
	if ($oldest) {
		@@list = reverse @@list;
	}
	foreach $ix (@@list) {
		if ($main::carids{$ix} eq $car) {
			if (!defined($main::carstates{$ix}) ) {
				$main::carstates{$ix} = "sold";
			}
		}
	}
d343 5
d875 1
a875 1
$main::showlist =~ s/all/,buy,sell,sales,sold,garage,/;
d1000 3
d1031 7
a1046 10
}
if ($main::showlist =~ /,carids,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carids) {
		printf("%s %s %s (%s)\n", $k, $main::carids{$k},
			$main::carnames{$k}, $main::carstates{$k});
	}
}
if ($main::showlist =~ /,pragmas,/ ) {
	printf("%s\n", $main::pragmas);
@


1.17
log
@I think the "sell excess" stuff is working, although it's too finicky to
be useful.
@
text
@a17 1
@@main::garage = ();
d191 1
a191 1
	my($i,$what,$temp);
d193 1
a193 1
	$i = $num - 1;
d195 11
a205 3
	$temp = $main::garage[$i];
	if ($temp =~ /$car/ ) {
		($what) = splice @@main::garage,$i,1;
a622 1
			push @@main::garage,"$prize(prize, $race)";
a726 1
				push @@main::garage,$fullname;
a756 1
				push @@main::garage,$fullname;
@


1.16
log
@Reimplements garage as evaluation of carnames and carstates, working
for at least simple sale cases, anyway.
carvariants, etc. need rewriting now.
@
text
@d124 5
a128 2
	for ($i = $#main::garage; $i >= 0; --$i) {
		if ($main::garage[$i] =~ /\(prize\)/ ) {
d130 5
a134 4
			if ( $main::garage[$i] =~ /$car/i ||
					$main::garage[$i] =~ /$car1/i ||
					$main::garage[$i] =~ /$car2/i ) {
				$hash{$main::garage[$i]} = 1;
d151 1
d157 4
a160 2
		for ($i = $#main::garage; $i >= 0; --$i) {
			if ($main::garage[$i] eq $car ) {
d171 4
a174 2
		for ($i = $#main::garage; $i >= 0; --$i) {
			if ($main::garage[$i] =~ /\(prize\)/ ) {
d176 3
a178 3
				if ( $main::garage[$i] =~ /$car/i ||
						$main::garage[$i] =~ /$car1/i ||
						$main::garage[$i] =~ /$car2/i ) {
d382 1
a382 1
#print "Sell  - $n $var.\n";
d466 1
d724 1
a724 1
				&getcar($sf,"");
d755 1
a755 1
				getcar($sf,"");
@


1.15
log
@Kludges to handle the fact that series and license lines used to
default to increment of one (still do) but you want to be able to say
+N where N is the number of races in a series.
Perhaps we will want to use a pragme.
@
text
@d224 1
a224 1
	my($ix);
d230 4
a233 3
	for ($i = $#main::garage; $i >= 0; --$i) {
		$ix = $oldest ? ($#main::garage - $i) : $i;
		$temp = $main::garage[$ix];
d236 3
a238 2
		if ($temp eq "$car") {
			($what) = splice @@main::garage,$ix,1;
d242 2
a243 1
	for ($i = $#main::garage; $i >= 0; --$i) {
a245 2
		$ix = $oldest ? ($#main::garage - $i) : $i;
		$temp = $main::garage[$ix];
d247 3
a249 2
		if ($temp eq "$car") {
			($what) = splice @@main::garage,$ix,1;
d253 6
a258 5
	for ($i = $#main::garage; $i >= 0; --$i) {
		$ix = $oldest ? ($#main::garage - $i) : $i;
		if ($main::garage[$ix] =~ /\(prize/ &&
					$main::garage[$ix] =~ /$car/i ) {
			($what) = splice @@main::garage,$ix,1;
d268 6
a273 5
	for ($i = $#main::garage; $i >= 0; --$i) {
		$ix = $oldest ? ($#main::garage - $i) : $i;
		if ($main::garage[$ix] =~ /\(prize/ &&
					$main::garage[$ix] =~ /$car/i ) {
			($what) = splice @@main::garage,$ix,1;
d607 1
a607 1
			getcar($prize,$prize);
d998 7
a1004 3
	my($i);
	for ($i = 0; $i <= $#main::garage; ++$i) {
		printf("%3d %s\n", $i+1, $main::garage[$i]);
@


1.14
log
@Changed needed to actually make NNN +N type lines work.
@
text
@a912 3
	elsif ( $r1 ne "" && $rest =~ /^licen[sc]e/ ) {
		&dolicenseline($line,$r1,$r2);
	}
d929 11
a939 1
	elsif ( $r1 ne "" && $line =~ /\s+\d+\-\d+\s+/ ) {
d942 5
a946 1
	elsif ( $r1 ne "" && $line =~ /\s+\d+\s+/ ) {
@


1.13
log
@Simplify(?) dodaynote, adding capability for a day range.
Add "skip" keyword which will be useful for gradually creating logs.
@
text
@d498 1
a498 1
	my($line,$start,$end) = @@_;
d500 1
a500 1
	my($rest,$i,$none,$pat,$race,$event,$length,$suff,$prev,$after);
d517 7
a523 7
	$rest = $line;
	if ($rest =~ /^\s*(\d+)-(\d+)\s*/ ) {
		$rest =~ s/^\s*(\d+)-(\d+)\s*//;
	}
	else {
		$rest =~ s/^\s*(\d+)\s*//;
	}
d933 1
a933 1
		&doseriesline($line,$r1,$r2);
d936 1
a936 1
		&doseriesline($line,$r1,$r2);
@


1.12
log
@Added support for "pragmas".
@
text
@d685 1
a685 1
	my($line) = @@_;
d688 1
a688 6
	$line =~ /^\s*(\d+)/;
if ( !defined($1) ) {
print $line,"\n";
}
	$day = $1;
	if (!&daycheck($day) ) {
a690 2
	$main::mintoday = $day;
	$main::maxtoday = $day;
d692 2
a693 2
	if ($line =~ /^\s*(\d+)\s+buy\s+(.*)/ && defined($2)) {
		$stuff = $2;
d723 2
a724 2
	if ($line =~ /^\s*(\d+)\s+win\s+(.*)/ && defined($2)) {
		$stuff = $2;
d748 2
a749 2
	if ($line =~ /^\s*(\d+)\s+mod\s+(.*)/ && defined($2)) {
		$stuff = $2;
d759 2
a760 2
	if ($line =~ /^\s*(\d+)\s+sell\s+(.*)/ && defined($2)) {
		$stuff = $2;
d764 3
d917 1
a917 1
		&dodaynote($line);
d927 1
d930 1
a930 1
		&dodaynote($line);
@


1.11
log
@Minor tweaks.
Corrected pattern for series/event check.
Attempted to add selling via carids hash, but haven't got yet.
Old "selling" was just too kludgey.
@
text
@d15 1
d410 20
d901 3
d997 3
@


1.10
log
@New syntax for "define series" requires a League to be specified.
Options series length is now processed.
With a different set of event definitions, this still works for GT3.
@
text
@d201 19
d612 1
a612 1
	   if ($value !~ /(\w+)\/(\w+)/) {
d970 2
a971 1
		printf("%s %s %s\n", $k, $main::carids{$k}, $main::carnames{$k});
@


1.9
log
@Allow definable series length.
@
text
@d447 1
a447 1
		return 0 if !defined($main::series{$series});
d451 1
a451 1
		return 0 if !defined($main::series{$series});
d582 1
a582 1
	my($what,$value,$length);
d592 11
@


1.8
log
@Still compatible with GT3.
Recognizes daynotes before series lines.
(Specific keywords must not match carnames).
Do more flexible processing of serieslines.
Will this allow
   609 +1 buy wing Cien'02 3DtypeDS
Do we need to check for erroneous day increments?
Probably not, running day check should catch it.
@
text
@d23 2
d427 10
d469 2
d472 1
a472 1
	if ( $diff < 0 || 6 < $diff) {
a484 1
	$length = 0;
d494 1
d582 1
a582 1
	my($what,$value);
d593 8
a600 1
		# would be nice to record # of days for other games (GT1)
@


1.7
log
@Comments.
Prepare to recognize new "increment" series line.
Remove old "do1dayline" call.
@
text
@a554 12
do1dayline {
	my($line,$day) = @@_;

	&warn("Unknown single day event: $_\n");
	if (!&daycheck($day) ) {
		&warn("Bad single day event(not ${main::maxtoday}): $_\n");
	}
	$main::mintoday = $day;
	$main::maxtoday = $day + 1;
}

sub
d818 2
a819 2
	elsif ( $line =~ /^([ \d]{3,3}\d)[ ]{6,6}(.*)/ ) {
		# single day (numbers max 4 digits)
a821 1
		$r1 =~ s/\s//g;
d848 13
a860 1
	elsif ( $line =~ /^[ \d]{3,3}\d-\d[ \d]{3,3}/ ) {
d863 1
a863 2
	elsif ( $line =~ /^[ \d]{3,3}\d[ ]{5,5}/ ) {
		# series used to be indicated by extra spaces
a864 3
	}
	elsif ( $line =~ /^[ ]{0,3}\d{1,5}/ ) {
		&dodaynote($line);
@


1.6
log
@Maintain and print fullnames by carids.
@
text
@d811 4
d816 1
d823 7
d831 1
d852 1
a860 4
	elsif ( $r1 ne "" &&
		( $license =~ /^[AB][1-8]/ || $license =~ /^IA[1-8]/ ) ) {
		&dolicenseline($line,$r1,$r2);
	}
d865 1
a866 4
	}
	elsif ( $line =~ /^[ \d]{4,4}\d[ ]{6,6}/ ) {
		# this should not occur any more;  all licenses
		&do1dayline($line,$r1,$r2);
@


1.5
log
@Now computes carids, and can sort by them.
============== Still works for GT3 ==========================
(Does not diverge yet).
@
text
@d97 1
a97 1
	my($fullname) = @@_;
d101 2
a102 1
	$main::carids{$newid} = $fullname;
d104 1
a104 1
	$main::carlist{$fullname} = $fullname;
d549 1
a549 1
			getcar($prize);
d626 1
a626 1
	my($day,$stuff,$fullname);
d643 1
a643 1
			&getcar($1);
d650 1
d656 3
d674 1
a674 1
			getcar($1);
d681 1
d687 3
d917 1
a917 1
		printf("%s %s\n", $k, $main::carids{$k});
@


1.4
log
@Define "getcar" routine, and just about got "carid" notion into the log.
@
text
@d43 34
@


1.3
log
@Tweaked "include" to syntax check and work.
Tested 13 deep (simple).
@
text
@d43 29
d514 1
a514 1
			$main::carlist{$prize} = $prize;
d608 1
a608 1
			$main::carlist{$1} = $1;
d635 1
a635 1
			$main::carlist{$1} = $1;
d655 1
d677 1
a677 1
getlog {
d869 6
@


1.2
log
@Includes probably working?
@
text
@d541 1
d545 2
a546 1
	$line =~ /^\s*include\s+([\/\w+])/;
d551 2
a552 1
	$main::fid = 'LOG' . $n;
d554 1
a554 1
		&warn("Cannot open include $filename.\n");
d663 1
a663 1
			$main::fid = 'LOG' . $n;
@


1.1
log
@Initial revision
@
text
@d537 19
d643 25
d710 5
a714 2
if (!open(LOG,"<$log")) {
	die "Cannot open log $log.\n";
d719 1
a719 1
while (<LOG>) {
d753 3
d795 1
a795 1
close (LOG);
@
