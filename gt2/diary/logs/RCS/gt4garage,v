head	1.78;
access;
symbols;
locks
	arpepper:1.78; strict;
comment	@# @;


1.78
date	2021.06.26.01.35.27;	author arpepper;	state Exp;
branches;
next	1.77;

1.77
date	2021.06.25.21.44.45;	author arpepper;	state Exp;
branches;
next	1.76;

1.76
date	2021.06.25.20.32.26;	author arpepper;	state Exp;
branches;
next	1.75;

1.75
date	2021.06.24.12.38.48;	author arpepper;	state Exp;
branches;
next	1.74;

1.74
date	2021.06.23.14.06.07;	author arpepper;	state Exp;
branches;
next	1.73;

1.73
date	2021.06.23.02.08.10;	author arpepper;	state Exp;
branches;
next	1.72;

1.72
date	2021.06.22.02.15.42;	author arpepper;	state Exp;
branches;
next	1.71;

1.71
date	2021.06.22.02.04.08;	author arpepper;	state Exp;
branches;
next	1.70;

1.70
date	2021.06.22.01.36.00;	author arpepper;	state Exp;
branches;
next	1.69;

1.69
date	2021.06.21.23.09.54;	author arpepper;	state Exp;
branches;
next	1.68;

1.68
date	2021.06.21.20.46.35;	author arpepper;	state Exp;
branches;
next	1.67;

1.67
date	2021.06.21.18.45.20;	author arpepper;	state Exp;
branches;
next	1.66;

1.66
date	2021.06.21.12.44.01;	author arpepper;	state Exp;
branches;
next	1.65;

1.65
date	2021.06.21.02.14.00;	author arpepper;	state Exp;
branches;
next	1.64;

1.64
date	2021.06.21.01.28.05;	author arpepper;	state Exp;
branches;
next	1.63;

1.63
date	2021.06.21.00.53.27;	author arpepper;	state Exp;
branches;
next	1.62;

1.62
date	2021.06.20.23.34.36;	author arpepper;	state Exp;
branches;
next	1.61;

1.61
date	2021.06.20.23.09.45;	author arpepper;	state Exp;
branches;
next	1.60;

1.60
date	2021.06.20.22.35.50;	author arpepper;	state Exp;
branches;
next	1.59;

1.59
date	2021.06.20.22.18.22;	author arpepper;	state Exp;
branches;
next	1.58;

1.58
date	2021.06.18.13.04.40;	author arpepper;	state Exp;
branches;
next	1.57;

1.57
date	2021.06.11.22.42.31;	author arpepper;	state Exp;
branches;
next	1.56;

1.56
date	2021.05.25.22.21.54;	author arpepper;	state Exp;
branches;
next	1.55;

1.55
date	2021.05.22.01.52.18;	author arpepper;	state Exp;
branches;
next	1.54;

1.54
date	2021.05.22.01.30.39;	author arpepper;	state Exp;
branches;
next	1.53;

1.53
date	2021.05.22.00.51.13;	author arpepper;	state Exp;
branches;
next	1.52;

1.52
date	2021.05.21.23.08.33;	author arpepper;	state Exp;
branches;
next	1.51;

1.51
date	2021.05.21.22.27.28;	author arpepper;	state Exp;
branches;
next	1.50;

1.50
date	2021.05.21.21.17.42;	author arpepper;	state Exp;
branches;
next	1.49;

1.49
date	2021.05.21.19.22.20;	author arpepper;	state Exp;
branches;
next	1.48;

1.48
date	2021.05.21.19.05.10;	author arpepper;	state Exp;
branches;
next	1.47;

1.47
date	2021.04.14.22.01.01;	author arpepper;	state Exp;
branches;
next	1.46;

1.46
date	2021.04.14.21.53.01;	author arpepper;	state Exp;
branches;
next	1.45;

1.45
date	2021.04.14.20.57.52;	author arpepper;	state Exp;
branches;
next	1.44;

1.44
date	2021.04.14.19.54.09;	author arpepper;	state Exp;
branches;
next	1.43;

1.43
date	2021.04.07.20.52.43;	author arpepper;	state Exp;
branches;
next	1.42;

1.42
date	2021.04.06.04.10.38;	author arpepper;	state Exp;
branches;
next	1.41;

1.41
date	2021.04.06.02.50.36;	author arpepper;	state Exp;
branches;
next	1.40;

1.40
date	2021.04.06.02.27.06;	author arpepper;	state Exp;
branches;
next	1.39;

1.39
date	2021.04.05.23.00.57;	author arpepper;	state Exp;
branches;
next	1.38;

1.38
date	2021.04.05.22.27.26;	author arpepper;	state Exp;
branches;
next	1.37;

1.37
date	2021.04.05.21.27.50;	author arpepper;	state Exp;
branches;
next	1.36;

1.36
date	2021.04.03.20.28.27;	author arpepper;	state Exp;
branches;
next	1.35;

1.35
date	2021.03.30.01.22.56;	author arpepper;	state Exp;
branches;
next	1.34;

1.34
date	2021.03.17.17.15.48;	author arpepper;	state Exp;
branches;
next	1.33;

1.33
date	2021.03.16.01.57.43;	author arpepper;	state Exp;
branches;
next	1.32;

1.32
date	2021.03.16.01.30.08;	author arpepper;	state Exp;
branches;
next	1.31;

1.31
date	2021.03.15.20.42.40;	author arpepper;	state Exp;
branches;
next	1.30;

1.30
date	2021.03.15.00.55.41;	author arpepper;	state Exp;
branches;
next	1.29;

1.29
date	2021.03.10.02.24.37;	author arpepper;	state Exp;
branches;
next	1.28;

1.28
date	2021.03.10.02.09.31;	author arpepper;	state Exp;
branches;
next	1.27;

1.27
date	2021.03.10.00.02.05;	author arpepper;	state Exp;
branches;
next	1.26;

1.26
date	2021.03.09.20.23.32;	author arpepper;	state Exp;
branches;
next	1.25;

1.25
date	2019.07.15.17.36.14;	author arpepper;	state Exp;
branches;
next	1.24;

1.24
date	2011.02.20.03.03.35;	author arpepper;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.24.18.44.40;	author arpepper;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.17.21.05.43;	author arpepper;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.17.19.50.01;	author arpepper;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.17.05.08.29;	author arpepper;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.16.06.44.46;	author arpepper;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.16.06.09.44;	author arpepper;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.16.05.51.16;	author arpepper;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.16.04.24.35;	author arpepper;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.15.02.19.21;	author arpepper;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.15.01.50.42;	author arpepper;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.15.01.36.48;	author arpepper;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.15.01.21.02;	author arpepper;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.15.01.04.43;	author arpepper;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.14.02.25.37;	author arpepper;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.14.01.35.29;	author arpepper;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.14.01.08.29;	author arpepper;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.14.00.51.34;	author arpepper;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.12.02.39.33;	author arpepper;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.12.02.26.07;	author arpepper;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.12.02.15.49;	author arpepper;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.12.01.32.46;	author arpepper;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.12.01.11.19;	author arpepper;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.12.00.24.33;	author arpepper;	state Exp;
branches;
next	;


desc
@Started with gt3garage.

Note: this should be changed (and RCS'd) under ~arpepper, with tested
updates copied to ~gt2toxs and eventually to gt2toxs-webpages.git
@


1.78
log
@Oops.  My handling of "prices", "parts" and "partstotals" options
did not work in cases where multiple options were used.
@
text
@#!/usr/bin/perl -w

#
# gt4garage [show=<options>] logname [simday]
#
# gt4garage produces a garage listing for optional given simday
#   But see also show=
#
# Audits:
#   Crudely checks the real "date lines"
#   lists resultant garage entries (obtained via buy,win,sell)
#                              win was implied in "old-style" event entries
#       shows "prize origin" of garage entries
#       verifies car counts given in status lines
#   day counter
#   license test medals (G/S/B)  (requires interpreting license lines)
#   car selection for events (a biggie for catching mistakes caused by copying)
#   Events must match definitions listed, usually in included gtN-racedefs
#       (which then become prize indicators via "next" and "win")
#   Verifies that "buy parts" and "mod car" have balanced items and Cr entries.
#
# Also:
#   "show=carlog" (optional "show=verbose,carlog")
#     produces output listed for each recognized car
#   "show=licen[sc]e" tracks license progress
#   "show=rawevents"
#   "show=events"
#   "show=prizes"
#       dump stored tables of event/prizes; seem redundant
#   "show=sold" "show=sell" "show=sales" "show=buy"
#     somewhat haphazardly attempt to track those car transactions
#         E.g. "show=sold,sell,sales,buy"
#   "show=origin" shows origins based on carid table (i.e. shows creating line)
#   "show=carids" dumps internal table of carids; useful when you need them
#
#   "show=rawparts" dumps processed version of all "buy parts" and "mod" lines
#   "show=mods" really debugging; shows extracted power and weight mod notes
#   "show=carprices" dumps carprices table (also "show=prices")
#   "show=carparts" dumps carparts table (also "show=parts")
#   "show=carpartstotals" gives per-car parts cost (also "show=partstotals")
#
#   "show=warn" tries to add extra warnings
#   "show=pragmas"  FWIW - some "pragma" evaluation will in future
#                              be replaced by use of "setvar"
#   "show=garage" is the default
#
# Now also:
#   setvar variable = value
#      - just numbers for now?
#   Primarily to allow "gt4garage ARRI-game2" to work
#       setvar minlicenseinc = 0
#       setvar maxlicenseinc = 1
#
# Future possibilities (getting few)
#   Credit sanity (increased or decreased as appropriate).
#   Percentage sanity; should never decrease.
#   A: and B:  should only ever increase, but they are gt4-specific
#   Parts availability for particular cars?  (Would seem to be difficult)
#   Prize legitimacy could conceivably be defined in gtN-racedefs
#   Prize origin should be indicated for a "carlog" entry.
#
#   It would be nice, but likely not possible, to arrange that
#     gt1 and gt2 logs could be processed too, with suitable gtN-racedefs
#   define recognized cars before win/buy ?  (working towards gt1/gt2)
#  
#


require 5.002;
use strict;

sub
warn {
	print @@_;
}

%main::var = ();	# variables to set along with racedefs
$main::var{'minlicenseinc'} = 1;
$main::var{'maxlicenseinc'} = 1;
$main::var{'minseriesinc'} = 1;
$main::var{'maxseriesinc'} = 1;
$main::var{'allowanyprize'} = 0;

$main::done = 0;
$main::enddate = "";
$main::mintoday = 0;
$main::maxtoday = 1;
$main::selected = "";
$main::pragmas = ",";

@@main::cardata = ();   # now we initialize all data via "buy" or "win" in log
@@main::prizes = ();
@@main::events = ();
$main::prize_event = ""; # pending event from "next", for "win"

%main::league = ();
%main::series = ();
%main::serieslen = ();
$main::maxserieslen = 6;
%main::track = ();

%main::carlist = ();  # now carlist is just an error suppressor
%main::origin = ();  # map carid to line which created it
%main::carid = ();  # map usual shortform to a carid (can conflict?)
$main::ncarsnow = 0;  # set to count when changes

# Discovered following defined only by use
%main::carids = ();  # see findcarid
%main::carnames = ();
%main::cardefs = ();  # special names created via "cardef" command
%main::carstates = ();
%main::carlist = (); # shortforms
%main::carprices = ();

%main::carmodels = ();  # Devoid of colour, price, etc

#
# proposed new scheme would just mark things as sold, not shuffle arrays
#
#@@main::newgarage = ();
#@@main::desc = ();
#@@main::parts = ();
#@@main::fitted = ();
#@@main::sold = ();
#$main::lastid = 0;
#%main::aliases = ();     # returns "carid", index into above arrays

		
my($name);
while (@@main::cardata) {
# This (i.e. cardata) is empty for later games
	$name = shift @@main::cardata;
	$main::carlist{$name} = $name;
};

sub
lidsub() {  # sort license test names B1..A1..IB1..IA1..S1..S16
	my($n1, $n2, );

	$n1 = $a;
	$n1 =~ s/^\D+//;
	$n1 =~ s/\n//g;
	$n1 = 0 if ($n1 eq "");  # ?  probably got coffee results?
	$n1 += 0;
	$n1 += 100 if ($a =~ /B/);   # Allow for C or IC licenses
	$n1 += 200 if ($a =~ /A/);
	$n1 += 1000 if ($a =~ /I/);
	$n1 += 10000 if ($a =~ /S/);

	$n2 = $b;
	$n2 =~ s/^\D+//;
	$n2 =~ s/\n//g;
	$n2 = 0 if ($n2 eq "");  # ?
	$n2 += 0;
	$n2 += 100 if ($b =~ /B/);   # Allow for C or IC licenses
	$n2 += 200 if ($b =~ /A/);
	$n2 += 1000 if ($b =~ /I/);
	$n2 += 10000 if ($b =~ /S/);

	return $n1 <=> $n2;
}

sub
caridcolonsub() { # Compare  car123:T-R2  car234-2:T-R5
	my($n1,$m1, $n2, $m2);
	my($suf1, $suf2);

	$suf1 = $a;
	if ($suf1 =~ /:/ ) {
		$suf1 =~ s/^[^:]*://;
	}
	else {
		$suf1 = "";
	}
	$n1 = $a;
	$n1 =~ s/:.*//;
	$n1 =~ s/^car//;
	$n1 =~ s/ .*$//;  # allow more on the line
	$m1 = $a;
	$m1 =~ s/:.*//;
	$m1 =~ s/ .*$//;  # allow more on the line
	if ($m1 !~ /-/) {
		$m1 = 1;
	}
	else {
		$m1 =~ s/.*-//;
		$n1 =~ s/-.*//;
	}

	$suf2 = $b;
	if ($suf2 =~ /:/ ) {
		$suf2 =~ s/^[^:]*://;
	}
	else {
		$suf2 = "";
	}
	$n2 = $b;
	$n2 =~ s/:.*//;
	$n2 =~ s/^car//;
	$n2 =~ s/ .*$//;  # allow more on the line
	$m2 = $b;
	$m2 =~ s/:.*//;
	$m2 =~ s/ .*$//;  # allow more on the line
	if ($m2 !~ /-/) {
		$m2 = 1;
	}
	else {
		$m2 =~ s/.*-//;
		$n2 =~ s/-.*//;
	}
	if ( $n1 == $n2 ) {
		if ( $m1 == $m2 ) {
			return $suf1 cmp $suf2;
		}
		return $m1 <=> $m2;
	}
	else {
		return $n1 <=> $n2;
	}
}

sub
caridsub() {  # sort carid1, carid10-2, carid100 ...
	my($n1,$m1, $n2, $m2);

	$n1 = $a;
	$n1 =~ s/^car//;
	$n1 =~ s/ .*$//;  # allow more on the line
	$m1 = $a;
	$m1 =~ s/ .*$//;  # allow more on the line
	if ($m1 !~ /-/) {
		$m1 = 1;
	}
	else {
		$m1 =~ s/.*-//;
		$n1 =~ s/-.*//;
	}

	$n2 = $b;
	$n2 =~ s/^car//;
	$n2 =~ s/ .*$//;  # allow more on the line
	$m2 = $b;
	$m2 =~ s/ .*$//;  # allow more on the line
	if ($m2 !~ /-/) {
		$m2 = 1;
	}
	else {
		$m2 =~ s/.*-//;
		$n2 =~ s/-.*//;
	}
	if ( $n1 == $n2 ) {
		return $m1 <=> $m2;
	}
	else {
		return $n1 <=> $n2;
	}
}
	
#
# checkcar - just check car matches selection
#
sub
checkcar {
	my($car,$line) = @@_;

	if ($main::selected eq "") {
		return 1 if (findcarid($car,$line));
		return 0;
	}
	return 1 if ($car eq $main::selected);
	&warn("Not using selection ${main::selected}: $line\n");
	return 0;
}

$main::lastcarday = -1;
$main::cardaycount = 1;
sub
gencarid { # every cars unequivocable ID is carNNN-N where NNN is gameday
	my($string);

	if ($main::mintoday != $main::lastcarday) {
		$main::cardaycount = 0;
	}
	$main::lastcarday = $main::mintoday;
	++$main::cardaycount;
	$string = "car$main::lastcarday";
	if ($main::cardaycount != 1) {
		$string = $string . "-" . "$main::cardaycount";
	}
	$string;
}

sub
getcarprice {
	my($id,$line) = @@_;
	my($price);

	$price = "Cr0";
	if ($line =~ m/\(Cr[0-9][0-9,]*/ ) {
		$line =~ s/,([^0-9])/, $1/;
		while ($line =~ m/Cr[0-9][0-9]*,/ ) {
			$line =~ s/(Cr[0-9][0-9]*),/$1/;
		}
		if ( $line =~ m/\((Cr[0-9][0-9]*)/ ) {
			$price = $1;
		}
	}
	$price;
}

sub
carsnow {  # expensive count of cars today
# try to call this only when we expect it to have changed
# $main::ncarsnow = carsnow();
	my($k,$i);
	$i = 0;
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold") {
			#printf("%3d %s\n", $i+1, $main::carnames{$k});
			++$i;
		}
	}
	$i;
}

sub
getcar {
	my($shortform,$fullname,$line) = @@_;
	my($newid);

	$newid = &gencarid();
	$main::carids{$newid} = $shortform;  # actually see findcarid
	$main::carnames{$newid} = $fullname;
	$main::carstates{$newid} = "got";   # s.b. "won" or "new" or "used"?
	$main::carlist{$shortform} = $shortform;
	$main::origin{$newid} = $line;
	$main::carprices{$newid} = getcarprice($newid,$line);
	$main::carid{$shortform} = $newid;  # stupid names carids vs carid
	$main::ncarsnow = carsnow();   # expensive?
	my($model) = ($fullname);
	if ($model =~ /['][0-9][0-9]\b/) {
		$model =~ s/(['][0-9][0-9]\b).*$/$1/;
	}
	else {
		while ($model =~ /[(].*[)]\s*$/) {
			# (prize)  (dup) (Cr10.000,new)  (colour)
			if ( $model =~ /[)]\s*[)]\s*$/ ) {
				# (Malachit (green))
				$model =~ s/\s*[(][^)]*[)]\s*[)]\s*$/)/;
			}
			$model =~ s/\s*[(][^()]*[)]\s*$//;
		}
	}
	$main::carmodels{$newid} = $model;
		
}

sub
carvariants {
	my($car) = @@_;

	# Hope matching works; only count prizes
	my($i,$count);
	my($car1,$car2);
	my(%hash,@@list);

	$count = 0;
	$car1 = $car;
	$car1 =~ s/es$//;
	$car2 = $car1;
	$car1 =~ s/s$//;
	@@list = (reverse sort caridsub keys %main::carids);
	foreach $i (@@list) {
		if ($main::carstates{$i} ne "sold" &&
				$main::carnames{$i} =~ /\(prize/ ) {
#printf("Maybe got %s /$car/\n", $main::carnames{$i});
			#  this is a little atrocious
			if ( $main::carnames{$i} =~ /$car/i ||
					$main::carnames{$i} =~ /$car1/i ||
					$main::carnames{$i} =~ /$car2/i ) {
#printf("Got %s\n", $main::carnames{$i});
				$hash{$main::carnames{$i}} = 1;
			}
		}
	}
	@@list = keys %hash;
	undef(%hash);
	return @@list;

}

sub
carcount {
	my($car,$exact) = @@_;

	# Hope matching works; only count prizes
	my($i,$count);
	my($car1,$car2);
	my(@@list);

	$count = 0;
	if ($exact) {
		# suitable for results of carvariants
		#  avoids blueSilEighty matching dkBlueSileighty -- sheesh
		@@list = (reverse sort caridsub keys %main::carids);
		foreach $i (@@list) {
			if ($main::carstates{$i} ne "sold" &&
				$main::carnames{$i} eq $car ) {
				++$count;
			}
		}
	}
	else {
		$car =~ s/[()]/\\$&/g;
		$car1 = $car;
		$car1 =~ s/es$//;
		$car2 = $car1;
		$car1 =~ s/s$//;
		@@list = (reverse sort caridsub keys %main::carids);
		foreach $i (@@list) {
			if ($main::carstates{$i} ne "sold" &&
				$main::carnames{$i} =~ /\(prize/ ) {
				#  this is a little atrocious
				if ( $main::carnames{$i} =~ /$car/i ||
					$main::carnames{$i} =~ /$car1/i ||
					$main::carnames{$i} =~ /$car2/i ) {
					++$count;
				}
			}
		}
	}
#print "carcount:$count $car\n";
	return $count;

}

sub
sellcarid {
	my($carid,$match) = @@_;
	my($what);

	if (!defined($main::carstates{$carid})) {
		&warn("Attempt to sell bad carid: $carid $match\n");
		return;
	}
	if ($main::carstates{$carid} eq "sold") {
		&warn("Carid already sold: $carid $match\n");
		return;
	}
	$what = $main::carnames{$carid};
	$match =~ s/\s*->.*$//;
	$match =~ s/$/.*/;
	if ($what !~ /$match/) {
		&warn("Carid $carid ($what) does not match /$match/\n");
		return;
	}
	$main::carstates{$carid} = "sold";
	if ($main::showlist =~ /,sold,/i ) {
		print "${main::maxtoday}:$carid ($what) sold!\n";
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
sellentry {
	my($num,$car) = @@_;
	my($i,$k,$what,$temp);

	$i = 0;
	$what = "";
	$temp = "";
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold") {
			if (++$i == $num) {
				$temp = $main::carnames{$k};
				if ($temp =~ /$car/ ) {
					$what = $temp;
					$main::carstates{$k} = "sold";
					last;
				}
			}
		}
	}
	if ($what) {
		if ($main::showlist =~ /,sold,/i ) {
			print "${main::maxtoday}:$car ($what) sold!\n";
		}
	}
	else {
		print "${main::maxtoday}:Entry $num ($temp) doesn't match \/$car\/\n";
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
marksold {
	# I do not think we use this
	my($id) = @@_;

	$main::carstates{$id} = "sold";   # I think that's all we need, now
}

sub
sellcar {
	my($car,$oldest) = @@_;
	my($i,$what,$temp,$temp2);
	my($ix,@@list);

	# if ($oldest) we want to remove oldest car, else most recent

	$car =~ s/^\s*//;
	$car =~ s/\s*$//;
	@@list = (sort caridsub keys %main::carids);
	@@list = reverse @@list if not ($oldest);
	foreach $ix (@@list) {
		$temp = $main::carnames{$ix};
		$temp =~ s/^\s*//;
		$temp =~ s/\s*$//;
		$temp2 = $temp;
		# (prize,B/Sunday) is now an unexpected suffix
		$temp2 =~ s/\s*\(prize[^\)]*\)\s*$//;
		if ( ($temp eq "$car" || $temp2 eq "$car")
			&& $main::carstates{$ix} ne "sold") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	foreach $ix (@@list) {
		$temp = $main::carnames{$ix};
		# this is sort of dumb...
		# prize annotation should not be part of car name?
		$temp =~ s/\(prize.*\)$//;
		if ($temp eq "$car" && $main::carstates{$ix} ne "sold") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	foreach $ix (@@list) {
		$temp = $main::carnames{$ix};
		if ($temp =~ /\(prize/ && $temp =~ /$car/i &&
				$main::carstates{$ix} ne "sold") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
	while ($car =~ /es$/) {
		$car =~ s/es$//;
	}
	while ($car =~ /s$/) {
		$car =~ s/s$//;
	}
	foreach $ix (@@list) {
		$temp = $main::carnames{$ix};
		if ($temp =~ /\(prize/ && $temp =~ /$car/i &&
				$main::carstates{$ix} ne "sold") {
			$what = $temp;
			$main::carstates{$ix} = "sold";
			$main::ncarsnow = carsnow();   # expensive?
			return $what;
		}
	}
#print "Could not find $car.\n";
	return "";
}

sub
sell {
	my($stuff) = @@_;
	my(@@count,@@name);
	my(@@variants);
	my($i,$n,$tname,$oldest,$sold,$var);
	
	$oldest = 0; #default always sell youngest
	@@count = ();
	@@name = ();

	
	if ($main::showlist =~ /,sell,/ ) {
		print "${main::maxtoday}:sell: $stuff\n";
	}
	$stuff =~ s/^\s*car //i;
	$oldest = $stuff =~ /^\s*oldest\b/i;
	$stuff =~ s/^\s*oldest\b//i;
	$stuff =~ s/^\s*//;
	$stuff =~ s/\s*->.*//;
	# Either need to make sellcar handle optional (prize,...)
	# Or repeat the attempt here
	# Actually problem is garage says "(prize" but sell line doesn't
	if ($sold = &sellcar($stuff, $oldest) ) {
		# literal sale, usually of purchased car...
		if ($main::showlist =~ /,sold,/i ) {
			print "${main::maxtoday}:$stuff ($sold) sold!\n";
		}
		return;
	}
	$stuff =~ s/\bCr[1-9][0-9,]*//g;
	$stuff =~ s/\s*$//;
	if ($stuff =~ /^entry\s+(\d+)\s+(.*)/ && defined($2)) {
#print "sell entry:$1 $2\n";
		&sellentry($1,$2);
		return;
	}
	if ($stuff =~ /^carid\s+([\-\w]+)\s+(.*)/ && defined($2)) {
#print "sell entry:$1 $2\n";
		&sellcarid($1,$2);
		return;
	}
	$stuff =~ s/\b[1-9][0-9]* {0,1}cars{0,1}//g;
	$stuff =~ s/\bday {0,1}[1-9][0-9]*//g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}day//g;
	$stuff =~ s/\b[1-9][0-9]* {0,1}day//g;
	$stuff =~ s/\ba\b/1/gi;
	$stuff =~ s/\(\d+\)//g;
	$stuff =~ s/\band\b//gi;
	$stuff =~ s/\bold\b//gi;
	$stuff =~ s/\balso\b//gi;
	$stuff =~ s/\bmost\b//gi;
	$stuff =~ s/\brecent\b//gi;
	while ($stuff =~ /[\w\[\]\-]/ ) {
		$stuff =~ s/^[^\w\[\]\-]//;
#print "stuff:$stuff\n";
		if ($stuff =~ /^(\d+)/ && defined($1) ) {
#print "number:$1\n";
			push @@count,$1;
			$stuff =~ s/^\d+//;
		}
		else {
			if ($stuff =~ /^excess */) {
				push @@count,-1;
				$stuff =~ s/^excess *//;
			}
			else {
				push @@count,1;
			}
		}
		$stuff =~ s/^[^\w\[\]\-]+//;
		if ($stuff =~ /^([\w'\/\[\]\-#.]+)/ && defined($1) ) {
			push @@name,$1;
			$stuff =~ s/^[\w'\/\[\]\-#.]+//;
		}
		else {
			last;
		}
	}
	for ($i = 0; defined($name[$i]); ++$i) {
		if ($main::showlist =~ /,sales,/ ) {
			print "${main::maxtoday}:Sell $count[$i] $name[$i].\n";
		}
		$tname = $name[$i];
		$n = $count[$i];
		for ($n = $count[$i]; $n > 0; --$n) {
			if ($sold = &sellcar($tname, $oldest)) {
				if ($main::showlist =~ /,sold,/i ) {
					print "${main::maxtoday}:$tname ($sold) sold!\n";
				}
			}
			else {
				print "${main::maxtoday}:Could not sell $tname.\n";
				last;
			}
		}
		if ($n < 0) {
			$n = -$n;
			@@variants = &carvariants($tname);
			foreach $var (@@variants) {
#printf("Sell  - $n $var, (%d).\n", &carcount($var,1));
				while (&carcount($var,1) > $n) {
#print "Sell $var.\n";
					if ($sold = &sellcar($var, $oldest)) {
						if ($main::showlist =~ /,sold,/i ) {
							print "${main::maxtoday}:$var ($sold) sold!\n";
						}
					}
					else {
						print "${main::maxtoday}:Could not sell $var.\n";
						last;
					}
				}
			}
		}
	}
	$main::ncarsnow = carsnow();   # expensive?
}

sub
daycheck {
	my($day) = @@_;

	if ($day < $main::mintoday || $main::maxtoday < $day) {
		return 0;
	}
	return 1;
}

sub
dodateline {
	my($line) = @@_;

	if ($line !~ /1999$/ && $line !~ /20[012][0-9]$/) {
		&warn("Bad date line: $_\n");
	}
	if ($main::enddate ne "") {
		$main::done = $line =~ /$main::enddate/i;
	}
	$main::lastdateline = $line."\n";
	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		# Problem is we really want this in the log not selected yet
		addcarlog($main::selected,$line);		
	}
}

sub
dopragma {
	my($line) = @@_;
	my($what,$value,$league,$length);

	$line =~ /^\s*pragma\s+(\w+)/;
	$what = $1;

	if ($what =~ /^no/) {
		$what =~ s/^no//;
		$main::pragmas =~ s/,$what,/,/;
	}
	else {
		if ($main::pragmas !~ /,$what,/) {
			$main::pragmas .= "$what,";
		}
	}

}

sub
doselect{
	my($line,$rest,$r1,$r2) = @@_;

	if ($rest =~ /^select\s*car\s+(\S+)/ && defined($1)) {
		if ($1 eq "none") {
# Wed Apr 14, 2021
# Empty selection turns off selection checking
# We never used this, so change it to be something which cannot match
			$main::selected = "no car selected";
# This will be useful to allow "verbose carlog" to include comments and status
			return;
		}
		if ( findcarid($1,$line) ) {
			$main::selected = $1;
			addcarlog($1,$line);		
			return;
		}
	}
	&warn("Bad select: $line\n");
}

sub
getgsb { # get Gold, Silver, Bronze (counts)
	my %h = @@_;
	my ($i, @@sorted, %m);

	%m = ();
	@@sorted = sort lidsub keys %h;
	for ($i = 0; $i <= $#sorted; ++$i) {
		++$m{$h{$sorted[$i]}};  # create $m{"G"}, $m{"S"}, $m{"B"}
	}

	return %m;
}
	

%main::lresults = ();
sub
updatemedal {
	my($lid,$medal) = @@_;
	my($oldr);

#printf "updatemedal %s %s\n", $lid, $medal;
	$medal = "F" if !defined($medal);
	return if ($medal eq "F");
	if (!defined($main::lresults{$lid})) {
		$main::lresults{$lid} = $medal;   # know $medal is not F
	}
	else {
		$oldr = $main::lresults{$lid};
		if ($medal eq "G") {
			$main::lresults{$lid} = $medal;
		}
		elsif ($medal eq "S") {
			$main::lresults{$lid} = $medal if ($oldr ne "G");
		}
		# $medal must be B, and $lresults is defined
	}
} 

sub
dolicenseline {
	my($line,$rest,$start,$end) = @@_;
	my($diff);
	my($lid,$medal);

#&warn("Good license line: $line\n");
	if (!&daycheck($start) ) {
		&warn("Bad license start day(not ${main::maxtoday}): $_\n");
	}
	$diff = $end - $start;
	if ( $diff < 0 ) {
		&warn("Bad license end day: $_\n");
	}
	$main::mintoday = $end + $main::var{'minlicenseinc'};
	$main::maxtoday = $end + $main::var{'maxlicenseinc'};
	# Almost need completely different routine for GT3, but maybe not?
	return if $main::pragmas !~ /,gt4,/;

	$lid = $rest;   # Note, line includes the day number
	#$lid =~ s/\s*\d+\s+//;  # Remove day number
	$lid =~ s/^licen[^ ]*\s+//;   # Must be a license line
	$lid =~ s/^\s+//;
	$lid =~ s/\s+.*$//;
	$lid =~ s/\n//g;
	$lid =~ s/\(.*//;  # Allow a parenthetical (!) or something
	if ($lid =~ /coffee/) {
		; # handle coffee later
	}
	# Note Gran Turismo actually uses hyphens in test names, e.g. S-16
	elsif ($lid !~ /^[I]{0,1}[BAS][\-]{0,1}[\d]{1,2}$/ || $lid =~ /IS/) {
		&warn("Bad license line (result first?): $line\n");
	}
	else {
		$lid =~ s/[\-]//;  # allow B-1, but use B1 internally
		$medal = $rest;
		#$medal =~ s/\s*\d+\s+//;  # Remove day number
		$medal =~ s/^licen[^ ]*\s+//;
		$medal =~ s/^\s+//;
		$medal =~ s/^I{0,1}[BAS]\d+[\-]{0,1}(\([^ ]*){0,1}\s+//;  # Remove $lid; we allow IS!
		if ( $medal =~ /^([FBSG])\b/ ) {
			$medal = $1;
		}
		else {
# Probably we should just complain in this case
			# Comments between $lid and $medal
#print "S14 medal=$medal\n" if ($lid eq "S14");
			&warn("License medal not first: $line\n")
				if ($main::showlist =~ /,licen[sc]e,/ );
			$medal =~ s/^[A-Za-z]+\s+//;
			$medal =~ s/[A-Za-z]{3,}//g;   # Seattle
			$medal =~ s/^[^ ]+\@@[^ ]+//;   # FordGT@@Seattle
			$medal =~ s/\bI{0,1}[BAS]\d+\b//g;  # lid can fool us
#			$medal =~ s/\b[\-\+][\:\.\d]{3,100}[BSG]\b//g;  # ignore +0.001G
# For some reason \b prevented matches
			$medal =~ s/[\-\+][\:\.\d]{3,}[BSG]{0,1}//g;  # ignore +0.001G
#print "S14 medal=$medal\n" if ($lid eq "S14");
			if ($medal =~ /[0-9\s]([BSG])\b/) { # 1st medal letter
				$medal = $1;
			}
			else {
				$medal =~ /([BSG])\b/;
				$medal = $1;
			}
		}
#print "S14 medal=$medal\n" if ($lid eq "S14");
		$medal = "F" if !defined($medal);
		updatemedal($lid,$medal);
	}

}

sub
otherprize {
	my($prize) = @@_;

	$prize =~ s/\s*\(.*//;
	$prize =~ s/^\s//;
	return 1 if ($prize eq "full");
	return 1 if ($prize eq "none");
	return 1 if ($prize eq "next");  # Hmm...
	return 1 if ($prize eq "1st");
	return 1 if ($prize =~ /^2nd/);
	return 1 if ($prize =~ /^3rd/);
	return 1 if ($prize =~ /^4th/);
	return 1 if ($prize =~ /^5th/);
	return 1 if ($prize =~ /^6th/);
	return 1 if ($prize =~ /^8-/);   #  8-(
	return 1 if ($prize =~ /\s8-/);   #  8-(
                              # but don't match Z28-30th
	#return 1 if ($prize =~ /credits/);
	return 0;
}

sub
event_length {
	my($event) = @@_;

	if (defined($main::serieslen{$event})) {
		return $main::serieslen{$event};
	}
	return 0;
}

sub
check_event {
	my($event) = @@_;
	my($league,$series,$track,$rest);

	return 0 if !defined($event);
	if ( $event =~ /([^\/]*)\/(.*)/ ) {
		($league,$series) = ($1,$2);
	}
	return 0 if !defined($league) || !defined($main::league{$league});
	return 0 if !defined($series);
	if ($series =~ /[\/]/) {
		$series =~ /([^\/]*)\/(.*)/;
		($series,$track) = ($1,$2);
		return 0 if !defined($main::series{"$league/$series"});
		return 0 if !defined($main::track{$track});
	}
	else {
		return 0 if !defined($main::series{"$league/$series"});
	}
	return 1;
}

sub
record_race_prize {
	my ($r,$s) = @@_;  # race, prize
	my ($temp);

	return if ($s =~ /credits/ || &otherprize($s));
	$temp = $s;
	$temp =~ s/\s*\(sold\)\s*//;
	$temp =~ s/\s*\(dup\)\s*//;
	$temp =~ s/\s*$//;
	# Perhaps one of these should record some of the above?
	# Currently they are same info; presumably want to derive from them
	push @@main::prizes,"${r}: $temp";
	push @@main::events,"${r}: $temp";
}

sub
doseriesline {
	my($line,$rest,$start,$end) = @@_;
	my($diff);
	my($i,$none,$pat,$race,$event,$length,$suff,$prev,$after);
	my($car,$prize,$count,$status,$temp);

	if ($start eq "") {
		return;		# assume a harmless comment?
	}
	if (!&daycheck($start) ) {
		&warn("Bad start day(not ${main::maxtoday}): $_\n");
	}
	# there's sort of an assumption every event takes at least one day
	#  so daycounter actually becomes $end+1 i.e. $start+$diff+1
	$diff = $end - $start;
	if ( $diff < 0 || $main::maxserieslen < $diff) {
		&warn("Bad end day: $_\n");
	}
	$main::mintoday = $end + $main::var{'minseriesinc'};
	$main::maxtoday = $end + $main::var{'maxseriesinc'};
	$none = 1;
	if ($rest =~ /(\S+)\s+(\S+)\s+(.*)/ ) {
		($car,$event,$after) = ($1,$2,$3);
	}
	if ( !defined($event) ) {
		&warn("event not defined: $line\n");
		return;
	}
	if (&check_event($event) == 0) {
		&warn("Unrecognized event ($event): $line\n");
		$event = " ";
		return;
	}
	else {
		$length = &event_length($event);
		if ($diff != $length) {
			&warn("Bad end day for series \"$event\": $line\n");
		}
		$car =~ s/^\s*//;
		$car =~ s/[,\s].*//;
		checkcar($car,$line);
		addcarlog($car,$line);
		
	}
	$none = 0;
	if ( !defined($event) ) {
		&warn("event not defined: $line\n");
		return;
	}
	if ( $rest =~ m/(\S+.*\s+)(\S+[\/]${event})(\s.*)/ ) {
		$rest =~ /(\S+.*\s+)(\S+\/${event})(\s.*)/ ;
		($prev,$race,$after) = ($1,$2,$3);
	}
	else {
		$rest =~ /(\S+.*\s+)(${event})(\s.*)/ ;
		($prev,$race,$after) = ($1,$2,$3);
	}
	if ( !defined($after) ) {
		&warn("$rest has no after\n");
		return;
	}
	$status = "";
	$prize = $rest;
	$prize =~ s/red /red#/g;
	$prize =~ s/black /black#/g;
	$prize =~ s/ LM/#LM/g;
        $prize =~ s/^.* ([\w\[])/$1/;
        $prize =~ s/[!]//g;
	if ($prize =~ /([(].*)/ && defined($1)) {
		$status = $1;
		$prize =~ s/[(].*//;
	}
	if ($prize !~ /ConceptCar/ ) {
		$prize =~ s/Concept/ConceptCar/;
	}
	$prize =~ s/#/ /g;
	$prize =~ s/ *$//g;
#	if ( &otherprize($prize) == 0 &&
#			$main::raceprizes{$event} !~ /,${prize},/ ) {
#		&warn("Unrecognized prize ($prize) for $race: $line\n");
#	}
	if ($status =~ /([(][^)]*[)])(.*)/) {
		$count = $1;
		$status = $2;
		if ($status =~ /([(][^)]*[)])(.*)/) {
			$status = $1;
		}
	}
	if ($prize eq "next") {
		if (defined($main::prize_event) && $main::prize_event ne "") {
			 &warn("Next for $main::prize_event never claimed: $line\n");
		}
		$main::prize_event = $race;
	}
	record_race_prize($race,$prize);
	if ($status ne "(sold)" && $line !~ /[(]sold[)]/ ) {
		if ($prize !~ /credits/ && &otherprize($prize) == 0) {
			getcar($prize,"$prize(prize, $race)",$line);
		}
	}
}

sub
check_hash {
	my($old, $new) = @@_;

	if (defined($old) && $old ne "") {
		&warn("Duplicate definition: $new\n");
	}
	return $new;
}


sub
docardef {
	my($line) = @@_;
	my($what,$value,$carid);

	$line =~ /^\s*cardef\s+(\S+)\s+([\S]+)/;
	$what = $1;
	$value = $2;

	if (!defined($what) || !defined($value)) {
		&warn("Bad cardef: $line\n");
		return;
	}
	if (defined($main::cardefs{$what})) {
		&warn("Already defined: $line\n");
		return;
	}
	$carid = findcarid($value,$line);
	if (!$carid) {
		&warn("Bad carid: $line\n");
		return;
	}
	if ($main::carstates{$carid} eq "sold") {
		&warn("Already sold car: $line\n");
		return;
	}
	$main::cardefs{$what} = $carid;
}

sub
douncardef {
	my($line) = @@_;
	my($what);

	$line =~ /^\s*uncardef\s+(\S+)/;
	$what = $1;

	if (!defined($main::cardefs{$what})) {
		&warn("No such cardef: $line");
		return;
	}
	delete($main::cardefs{$what});
 	# is following advisable?
	#if (defined($main::carlist{$what})) {
	#	delete($main::carlist{$what});
	#}
}

sub
dosetvar {
	my($line) = @@_;
	my($what,$value,$carid);

	if ( !($line =~ /^\s*setvar\s+(\S+)\s*\=\s*([\S]+)/) ) {
		&warn("Bad setvar: $line\n");
		return;
	}
	$what = $1;
	$value = $2;
	# assert defined($what) && defined($value)

	$main::var{$what} = $value;
}

sub
findcarid { # given explicit cardef or carid, or unique shortform, return carid
	    # warn (first time) about unresolvable names
	my($carname,$line) = @@_;
	my($k,$id);

	if (defined($main::carids{$carname})) {
		# We were given a carid; just return it (NOT carids{$carname})
		return $carname;
	}
# We have both %carids and %carid
	if (defined($main::carid{$carname})) {
		# quick map of short forms to carid
		return $main::carid{$carname};
	}
	if (defined($main::cardefs{$carname} )) {
		return $main::cardefs{$carname};
	}
	# Did not find via above; search all $carids{}
	$id = "";
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carids{$k} eq $carname &&
				$main::carstates{$k} ne "sold") {
			if ($id eq "") {
				$id = $k;
			}
			else {
				if ($line ne "") {
					# should we warn here?
				&warn("Ambiguous car ($carname): $line\n");
					# Use first if $line is not set
					return undef;
				}
			}
		}

	}
	if ( $id ne "" ) {
		return $id;
	}
	if (!defined($main::carlist{$carname})) {
		&warn("Unrecognized car ($carname): $line\n");
		# Reduce diagnostics by defining here
		$main::carlist{$carname} = $carname;
	}
	return undef;
}

sub
dodefine {
	my($line) = @@_;
	my($what,$value,$league,$length);

	$line =~ /^\s*define\s+(\w+)\s+([\S]+)/;
	$what = $1;
	$value = $2;

	if ($what =~ /league/i) {
	   $main::league{$value} = &check_hash($main::league{$value}, $value);
	}
	elsif ($what =~ /series/i) {
	   $league = "";
	   if ($value !~ /^([^\s\/]+)\/([^\s\/]+)$/) {
		#Problems: A/S+S E/All-night
		&warn("Bad series name: $value\n");
	   }
	   else {
		   $league = $1;
	   }
	   if (!defined($main::league{$league})) {
		&warn("Undefined league in series name: $value\n");
	   }
	   $main::series{$value} = &check_hash($main::series{$value}, $value);
	   $length = 1;
	   if ( $line =~ /^\s*define\s+(\w+)\s+([\S]+)\s+(\d+)/ ) {
		$length = $3;
	   }
	   if ($length > $main::maxserieslen) {
		$main::maxserieslen = $length;
	   }
	   $main::serieslen{$value} = $length-1;
	}
	elsif ($what =~ /track/i) {
	   $main::track{$value} = &check_hash($main::track{$value}, $value);
	}
	else {
		&warn("Bad definition: $line");
	}
}


$main::fid = 'LOG0';
sub
doinclude {
	no strict 'refs';
	my($line) = @@_;
	my($filename, $oldfid, $n);

	$line =~ /^\s*include\s+(\S+)/;
	$filename = $1;
	$oldfid = $main::fid;
	$n = $main::fid;
	$n =~ s/LOG//;
	++$n;
#print "$main::fid $n\n";
	$main::fid = 'LOG' . "$n";
	if (!open($main::fid,"<$filename") ) {
		&warn("Cannot open include \"$filename.\"\n");
		$main::fid = $oldfid;
	}
}

sub
dostatusline {
	my($line,$rest,$r1,$r2) = @@_;
	#my($day,$stuff,$sf,$fullname);

	if (!&daycheck($r1) ) {
		&warn("Bad single day note(not ${main::maxtoday}): $line\n");
	}
	# Assert $rest =~ /^Cr[0-9]/
	# grr... seems difficult to undef $1 ...
	# If you need to, 'a' =~ /a/   will do it. I.e. a successful match.

	# Later check Ncars, medal counts perhaps license standing?

	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		addcarlog($main::selected,$line);		
	}
	if ( $main::pragmas =~ /,gt4,/ && $rest =~
	   m:([0-9]{1,2}[GB][ /]{1,3}[0-9]{1,2}[S][ /]{1,3}[0-9]{1,2}[GB]): ) {
		# Later perhaps license stats for GT3
		my $licstats = $1;
		my ($m, $s);
		my (%gsb);
		$s = "";
		%gsb = getgsb(%main::lresults);
		for $m ("G", "S", "B") {
			if (!defined($gsb{$m}) ) {
				$gsb{$m} = 0;
			}
			$s .= sprintf("%d%s ", $gsb{$m}, $m);
		}
		# Compare %gsb/$s with canonical version of $licstats
		my ($logresults) = ("");
		$licstats =~ /\b([0-9]+G)\b/;
		$logresults .= "$1 " if (defined($1));
		$licstats =~ /\b([0-9]+S)\b/;
		$logresults .= "$1 " if (defined($1));
		$licstats =~ /\b([0-9]+B)\b/;
		$logresults .= "$1 " if (defined($1));
		if ($main::showlist =~ /,licen[sc]e,/ ) {
			printf "%s %s %s - %s\n",
				$r1, $licstats, $logresults, $s;
		}
		if ( $logresults ne $s ) {
			&warn("$logresults ne $s: $line\n");
		}
	}
	if ( ( $main::showlist =~ /,warn,/i || $main::showlist !~ /,garage,/)
		 && $rest =~ m:\b([0-9]{1,4})[ ]{0,3}car[s]{0,1}\b:i ) {
		# commas?
		my ($logncars);
		$logncars = $1;
		if ($logncars != $main::ncarsnow) {
			&warn("Car count not ${main::ncarsnow}): $line\n");
		}
	}

	$main::mintoday = $r2;
	$main::maxtoday = $r2;
}


# $e = set_from_race($e);
sub
race_to_set {  # derive "set" (event) name from one of its races
	my($s) = @@_;
# E,g, GT4   B/Sunday/AMii  => B/Sunday
#   But  SC/Normal/AmalfiR => SC/Normal/Amalfi

	# A prize is for the set, not the race
	# Perhaps this depends on pragma
	# Or perhaps we need "prizeevent" defns
	if ($s !~ m:/(Easy|Normal|Hard)/: ) { # ugh!
		while ($s =~ m:/.*/: ) {
			$s =~ s:/[^/]*$:: ;
		}
	}
	else {  # and ugh!
		$s =~ s/R$//;
		$s =~ s/ii$//;
	}
	return $s;
}

sub
dowin {   # Handle  150 +1 win car  RSC'02  Toyota RSC Rally Raid Car '02
# Note: also   59 +1 win car Nike   Nike One 2022 (prize,IBlicenseB)
	my($line,$rest,$r1,$r2) = @@_;
	#my($day,$stuff,$sf,$fullname);
	my($stuff,$sf,$fullname);
	my($tstuff,$event);

	if ($rest !~ /^win\s+(.*)/ || !defined($1)) {
		return;
	}
	$stuff = $1;
#print "stuff:$stuff\n";
	if ($main::selected ne "") {
		addcarlog($main::selected,$line);
	}
	if ($stuff !~ /^\s*car\s+(\S+)/ || !defined($1) ) {
		if (!$main::var{'allowanyprize'} ) {
			&warn("Bad win: $line\n");
		}
		else {
			getcar($stuff,$stuff,$line);
			$main::prize_event = "";
		}
		return;
	}
	$event = "";
	$tstuff = $stuff;
	while ($tstuff =~ m:\s*\([^\)]*\)\s*$: ) {
#&warn("Eat parentheses: $line\n");
		if ($tstuff =~ m:(\(prize[^\)]*)\)\s*$: ) {
#&warn("Found prize: $line\n");
			$event = $1;
			$event =~ s/^\(prize,//;
			$event =~ s/\)\s*$//;
			last;
		}
# Good candidate for infinite loop here...
		$tstuff =~ s:\s*\([^\)]*\)\s*$:: ;
	}


	if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
#$main::prize_event = "";
# Problem: some prize car names include parentheses
		$sf = $1;
		if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
			$fullname = $2;
			$fullname =~ s/^[^\w\[]*//;
			$fullname =~ s/->\s.*//;
			$fullname =~ s/\s*$//;
			$fullname =~ s/^\s*//;
			if ($event ne "") {
				# Actually probably a non-race prize
				record_race_prize($event,$fullname);
			}
			elsif (defined($main::prize_event) && $main::prize_event ne "") {
				my ($e) = ($main::prize_event);
				# assert ($event eq "")
				$e = race_to_set($e);
				$fullname =~ s/$/ (prize,$e)/;
				# push event info here...
				record_race_prize($e,$fullname);
			}
			# Need a GOOD way for prize info to be passed
			getcar($sf,$fullname,$line);
			if ($main::showlist =~ /,buy,/i) {
				print "${main::maxtoday}:win $sf - $fullname.\n";
			}
		}
		else {
			# Need a way for prize info to be passed
			# I don't think we ever use this form?
			getcar($sf,$sf,$line);
		}
	}
	if ($event eq "") {
# Perhaps having $main::prize_event set for a win with event should be an error
		if (!defined($main::prize_event) || $main::prize_event eq "") {
			&warn("prize_event not set: $line\n");
		}
		$main::prize_event = "";
	}

}

sub
normalizeparts {
	my($car,$line) = @@_;
	my($stuff, $dayno, $op);
	my ($tok);
	my ($mod);

# 208  mod car   CivicTypeR WR1 WR2 WR3  -805-780-755  Cr1000 Cr5000 Cr20,000
# 451  buy parts whiteCelica'70 (Tom's) Rmuff Cr4600 Rbr Bctlr  Cr4600 Cr10,300
# 451  mod car   whiteCelica'70   pol+bal  Cr5250  Cr11,000
# 451  mod car   whiteCelica'70   WR1 WR2 WR3 Cr1100 Cr5300 Cr21,000
	$stuff = $line;
	$stuff =~ s/\n//g;
	$stuff =~ s/^\s*//;  # Had had obscure bug ctrl\ instead of "^\"
	$stuff =~ s/^\s*$//;   # Can't hurt
	$dayno = $stuff;
	$dayno =~ s/\s+.*$//;
	$stuff =~ s/^\S+\s*//;
	$op = $stuff;
	if ($op =~ /^\+\d/) {
		# In GT4, this actually implies wheels
		$stuff =~ s/^\S+\s*//;
		$op = $stuff;
	}
	$op =~ s/\s.*$//;  #  s.b. "buy" or "mod"
			# Will later make into "parts" or "mod"
	$stuff =~ s/^\S+\s*//;
	$tok = "";
	for ( ; ; ) {
		last if ($stuff eq "");
		$tok = $stuff;
		$tok =~ s/\s+.*$//;
		$op = $tok if ($tok eq "parts");
		$stuff =~ s/^\S+\s*//;
		last if ($tok eq $car);
	}
	if ($tok ne $car) {
		# Perhaps this will be redundant noise given "select"
		&warn("Could not find $car: $line\n");
	}
	while ($stuff =~ /,\s*Cr/i ) {
		# Ensure prices are separated by spaces, not commas
		$stuff =~ s/,\s*Cr/ Cr/ig;
	}
	while ($stuff =~ /Cr\d+,\d/i ) {
		# Reomve optional commas from Cr10,000
		$stuff =~ s/(Cr\d+),(\d)/$1$2/;
	}
	while ($stuff =~ /Cr\d+[.]\d/i ) {
		&warn("Period instead of comma: $line\n");
		$stuff =~ s/(Cr\d+)[.](\d)/$1$2/;
	}
	# Now for things like
        # 117 mod car   Silvia'88K  WR1  Cr1000  ->1071kg
        # 120 buy parts Silvia'88K  Rmuff  ->257hp
        # 706  mod car  March  WR1 WR2 WR3 -805-780-755  Cr1000 Cr5000 Cr20,000
	# Appears we only did 805 -> 780 in comments
	# Recently we usually use only "-" with no spaces
	# We cannot safely remove spaces before "-".
	$stuff =~ s/(\d)to(\d)/$1-$2/g;  # probably should've just changed log
	my($p) = $stuff;
	$mod = "";
	while ( $stuff =~ m/(\d*-[\d\-\>]+(hp|kg){0,1})/ ) {
		$mod .= $1;
		$stuff =~ s/\d*-[\d\-\>]+(hp|kg){0,1}//;
		 # remove anything with digits and "->"
		# avoid T-S3 changing to TS3
	}
# Maybe later we can use such mod information somehow
	if ($main::showlist =~ /,mods,/ && $p ne $stuff) {
		print " B:",$p,"\n A:",$stuff,"\n";
		print " mod:$mod\n";
	}

	# Back in gt3-game1 I tended to put prices in parentheses
	#  But they do not seem semantically significant
	while ($stuff =~ /\((Cr\d+[^()]*)\)/ ) {
		#  72   buy parts Trueno SpSusp (Cr3,000)
		#  72   buy parts Trueno SpSusp (Cr3000)
		# Add space in case parenthesis was used as token separator
		$stuff =~ s/\((Cr\d+[^()]*)\)/ $1/;
		#  72   buy parts Trueno SpSusp  Cr3000
	}
	$stuff =~ s/\(\?\)//g;  # FWIW
	$stuff =~ s/,/ /g;  # Any remaining commas could be spaces
	$stuff =~ s/\+/ /g; # I use "pol+bal" a lot; also "cage+refresh"
	$stuff =~ s/\s+/ /g;   # Multiple spaces not semantically significant
	$stuff =~ s/\s*$//;  # just to be sure
	$stuff =~ s/^\s*//;  # just to be sure
	#  Note in GT3 you bought tire combinations e.g. T-R3/T-R3
  	#  66   buy parts Trueno T2/T2 (Cr10,000)

	#return ($op, $tok. $stuff);  # Sure I assigned funcs to arrays before
	return $op . " " . $tok . " " . $stuff;
}

sub
doparts {
	my($car,$line) = @@_;


	my($buf);
	my($stuff, $op);
	my ($tok);

	#($op, $tok, $stuff) = normalizeparts($car,$line);
	$buf = normalizeparts($car,$line);
# A question becomes, what should be left after normalize ?
#  For now we leave anything left in parentheses, and also NNNkg and NNNhp
#	print "$buf\n"  if ($main::showlist =~ /,rawparts,/ );
	($op, $tok, $stuff) = split(/\s/,$buf,3);
# N.B. if you don't specify ",3" you get only the first solitted element
	print "$op $tok :$stuff\n"  if ($main::showlist =~ /,rawparts,/ );

# Mostly gt3-game1 use of parentheses...
# Old "alias" throwback
#   (alias [R]FalconXR8)
# Tuner names
#   (Trial)
#   (HKS)
#   (Mine's)
#   (Amuse)
#   (from Blitz)
# "Daily wheels"
#   (daily)
# Colours (for wings and wheels)
#   (silver)
#   (Black)
#   (black)
#   (yellow)
#   (red)
#   (red 4x2 spokes)
# Asides
#   (don't fit)
# Alternate GT3 tire designations
#   (SSl/SSl)
#   (M/M)
#
# Also brief attempt in gt4-game2 to track the "codenames"
# I will simply remove those, however.
# buy Cougar :Rtrans("FC") 3clu("TR") Cr10000 Cr4600

# So...
#  buy Crossfire :NA1 NA2 Cr4700 Cr12000 chip N2O Cr1250 Cr5000
#  becomes $parts{"Crossfire:NA1"} = "Cr4700";
#  becomes $parts{"Crossfire:NA2"} = "Cr12000";
#  becomes $parts{"Crossfire:chip"} = "Cr4700";
#  becomes $parts{"Crossfire:N2O"} = "Cr5000";
#
# Assume Cr0 applies to all everything before it, i.e.
# buy redSkyline'67 :T-N1 T-N2 T-N3 Cr0 T-S1 T-S3 Cr4100 Cr5600
# becomes $parts{"redSkyline'67:T-N1"} = "Cr0";
# becomes $parts{"redSkyline'67:T-N2"} = "Cr0";
# becomes $parts{"redSkyline'67:T-N3"} = "Cr0";
# becomes $parts{"redSkyline'67:T-S1"} = "Cr4100";
# becomes $parts{"redSkyline'67:T-S3"} = "Cr5600";
#
# Except we want to use   car2495 redSkyline'67 Nissan Skyline 2000GT-B ...
# So...  $parts{"car2495:T-N1"} = "Cr0";
# etc...
#
	my($id);
	my(@@prices);
	my(@@parts);
	my(@@tokens);
	my($t,$p);

	@@prices = ();
	@@parts = ();
	$id = findcarid($tok);
	if (!defined($id)) {  # probably can't happen
		&warn("Cannot find carid for $tok, $line\n");
		return;
	}
	if ($stuff =~ /\bwheel/ || $stuff =~ /\bwing/ ) {
		# This test is very data dependent
		$t = "Cr0";
		if ( $stuff =~ /\b(Cr\d+)\b/ ) {
			$t = $1;
			$stuff =~ s/\bCr\d+\b//;
			$stuff =~ s/\s+/ /g;
		}
		$p = $id.":".$stuff;
		$main::carparts{$p} = $t;
		return;
	}
	$stuff =~ s/\s+\([^\)]*\)\s+/ /g;  # till we figure out how to process
	$stuff =~ s/\s+\([^\)]*\)/ /g;  # till we figure out how to process
	$stuff =~ s/\([^\)]*\)\s+/ /g;  # till we figure out how to process
	# Any remaining parentheses must be embedded in a "token"...
	$stuff =~ s/\([^\)]*\)//g;  # till we figure out how to process
	$stuff =~ s/\s+/ /g;
	$stuff =~ s/^\s+//g;  # sigh.  split will return empty tokens...
	$stuff =~ s/\s+$//g;
	@@tokens = split(/\s+/,$stuff);
	for $t (@@tokens) {
		if ($t =~ /^\d+hp$/i || $t =~ /\d+kg/i ||
			$t =~ /^\(/ || $t =~ /\)$/ ) {
			; # skip these "comments"
			# problem: we handle "(this comment)"
			#            but not "(this is a comment)"
			# Except that we removed them earlier...
		}
		elsif ($t eq "Cr0") {
			while (defined($p = shift(@@parts)) ) {
				$p = $id.":".$p;
				$main::carparts{$p} = $t;
			}
		}
		elsif ($t =~ /^Cr\d/) {
			if (!defined($p = shift(@@parts)) ) {
				&warn("No part for $t, $line\n");
			}
			else {
				$p = $id.":".$p;
				$main::carparts{$p} = $t;
			}
		}
		else {
			$t =~ s/\s*\(.*\)\s*//;
			push @@parts, $t;
		}
	}
	while (defined($p = shift(@@parts)) ) {
		$p = $id.":".$p;
		if ($main::showlist =~ /,carparts,/ ||
			  $main::showlist =~ /,warn,/ ) {
			&warn("No price for $p, $line\n");
			# currently a problem with "wheels" purchases
		}
		$main::carparts{$p} = "Cr0";
	}
}

sub
dodaynote {
	my($line,$rest,$r1,$r2) = @@_;
	my($day,$stuff,$sf,$fullname);

	if (!&daycheck($r1) ) {
		&warn("Bad single day note(not ${main::maxtoday}): $_\n");
	}
	# grr... seems difficult to undef $1 ...
	if ($rest =~ /^buy\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "stuff:$stuff\n";
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
			$sf = $1;
			if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
				$fullname = $2;
				$fullname =~ s/^[^\w\[]*//;
				$fullname =~ s/->\s.*//;
				$fullname =~ s/\s*$//;
				$fullname =~ s/^\s*//;
				&getcar($sf,$fullname,$line);
				if ($main::showlist =~ /,buy,/i) {
					print "${main::maxtoday}:buy $sf - $fullname.\n";
				}
			}
			else {
				&getcar($sf,$sf,$line);
			}
		}
		elsif ($stuff =~ /^\s*parts\s+(\S+) /) {
			checkcar($1,$line);
			addcarlog($1,$line);
			doparts($1,$line);
		}
		elsif ($stuff =~ /^\s*wheels\s+/) {
			# In gt4, wheels are really a part
			;
		}
		else {
			&warn("Bad purchase: $line\n");
		}
	}
	if ($rest =~ /^win\s+(.*)/ && defined($1)) {
		dowin($line,$rest,$r1,$r2);
	}
	if ($rest =~ /^change\s+(.*)/ && defined($1)) {
		my ($stuff) = ($1);
		$stuff =~ s/^\s*oil\s*//;
		$stuff =~ s/^\s*car\s*//;
#print "stuff:$stuff\n";
# this was cheating; eventually identifier will be checked
		if ($stuff =~ /^(\S+)/ && defined($1) ) {
			checkcar($1,$line);
			addcarlog($1,$line);
		}
		else {
			&warn("Bad change: $line\n");
		}
	}
	if ($rest =~ /^mod\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "stuff:$stuff\n";
# this was cheating; eventually identifier will be checked
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
			checkcar($1,$line);
			addcarlog($1,$line);
			doparts($1,$line);
		}
		else {
			&warn("Bad mod: $line\n");
		}
	}
	if ($rest =~ /^sell\s+(.*)/ && defined($1)) {
		$stuff = $1;
#print "sell stuff:$stuff\n";
		&sell($stuff);
	}

	$main::mintoday = $r2;
	$main::maxtoday = $r2;
}

sub
donote {
	my($line) = @@_;

	if ($main::showlist =~ /,carlog,/ && $main::showlist =~ /,verbose,/ ) {
		addcarlog($main::selected,$line);		
	}
}

sub
getlog {  # get lines, closing includes
	no strict 'refs';
	my($line) = @@_;
	my($n);


	for (;;) {
		$line = <$main::fid>;
		if (!defined($line)) {
			close($main::fid);
			$n = $main::fid;
			$n =~ s/LOG//;
			if ( $n == 0 ) {
				return $line;
			}
			--$n;
			$main::fid = 'LOG' . "$n";
		}
		else {
			return $line;
		}
	}
}

my($log,$daylimit);

$main::lastdateline = "";
%main::carlogs = ();
sub
addcarlog {
	my($car,$line) = @@_;

	if ($car eq "" || $car eq "no car selected") {
		return;
	}
	if (!defined($main::carlogs{$car})) {
		$main::carlogs{$car} = "";
		if ($main::showlist =~ /,verbose,/) {
			$main::carlogs{$car} = $main::lastdateline;
		}
	}
	if ($line !~ /^\s*$/) {
		$main::carlogs{$car} .= $line."\n";
	}
}
	

while ( defined($ARGV[0]) ) {
	my($temp);
	if ( $ARGV[0] =~ /^show=/i ) {
		$temp = $ARGV[0];
		$temp =~ s/^show=//i;	
		$temp = ",$temp,";
		$temp =~ s/,+/,/g;
		# Expand a few lazy alternatives we allow
		$temp =~ s/,partstotals,/,carpartstotals,/;
		$temp =~ s/,parts,/,carparts,/;
		$temp =~ s/,prices,/,carprices,/;
		# Would be nice to make plurals optional
		$main::showlist .= ",$temp,";
	}
	elsif (!defined($log)) {
		$log = $ARGV[0];
	}
	elsif (!defined($daylimit)) {
		if ($ARGV[0] =~ /^\d+$/) {
			$daylimit = $ARGV[0];
		}
		else {
			$temp = $ARGV[0];
			# change something like "Jan 10"
			#   into a pattern, like...
			# /^Jan[^0-9]*10/
			$temp =~ s/,/ /g;
			$temp =~ s/ +/[^0-9]*/;
			$temp =~ s/$/\\b/;
			$temp =~ s/^/^/;
			$main::enddate = $temp;
			
		}
	}
	shift @@ARGV;
}
if (!defined($log)) {
	$log = "log";
}
if (!defined($daylimit)) {
	$daylimit = -1;
}
if (!defined($main::showlist)) {
	$main::showlist = ",garage,";
}
$main::showlist =~ s/all/pragmas,buy,sell,sales,sold,carids,garage,/;

{
	no strict 'refs';
	if (!open($main::fid,"<$log") ) {
		die "Cannot open log $log.\n";
	}
}


#while ($main::mintoday <= $daylimit && <LOG>) {
while (defined($_ = &getlog())) {
	my($line) = $_;
	my($license,$r1,$r2,$rest);

	last if ($main::done);
	last if ($daylimit > 0 && $main::mintoday > $daylimit);
	$line =~ s/\n//g;
	$license = $line;
	$license =~ s/^.{10}//;
	$license =~ s/(\S+)\s.*/$1/;
	$r1 = "";
	$r2 = "";
	$rest = $line;
	if ( $line =~ /^[A-Z]/) {
		;
	}
	elsif ( $line =~ /^ {9,9}/ ) {
		# line beginning with 9 spaces assumed to be comment
		;
	}
	elsif ( $line =~ /^([ \d]{3,3}\d)\-(\d[ \d]{3,3})(.*)/ ) {
		# day range (numbers max 4 digits)
		$r1 = $1;
		$r2 = $2;    # n.b. must grab all $N before doing other subs
		$rest = $3;
		$r1 =~ s/\s//g;
		$r2 =~ s/\s//g;
	}
	elsif ( $line =~ /^\s*(\d+)\s*\+(\d+)(.*)/ ) {
		# new range indication by +increment
		$r1 = $1;
		$r2 = $2;    # n.b. must grab all $N before doing other subs
		$rest = $3;
		$r2 += $r1;
	}
	elsif ( $line =~ /^\s*(\d+)\s+(.*)/ ) {
		# single day
		$r1 = $1;
		$rest = $2;
		$r2 = $r1;
	}
	$rest =~ s/^\s*//;

	if ( $line =~ /^\s*note/i ) {
		&donote($line);
	}
	elsif ( $line =~ /^\s*pragma/i ) {
		&dopragma($line);
	}
	elsif ( $line =~ /^\s*include/i ) {
		&doinclude($line);
	}
	elsif ( $line =~ /^\s*define/i ) {
		&dodefine($line);
	}
	elsif ( $line =~ /^[A-Z]/) {
		&dodateline($line);
	}
	elsif ( $line =~ /^\s*cardef/i ) {
		&docardef($line);
	}
	elsif ( $line =~ /^\s*uncardef/i ) {
		&douncardef($line);
	}
	elsif ( $line =~ /^\s*setvar/i ) {
		&dosetvar($line);
	}
	elsif ( $line =~ /^ {9,9}/ ) {
		# line beginning with 9 spaces assumed to be comment
		# ORLY?
		;
	}
	elsif ( $rest =~ /^Cr[0-9]/ ) {
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^power\b/ ) {
		$rest =~ s/^power\s*//;  # process stats on power off lines
		$rest =~ s/^off\s*//;
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^reset\b/ ) {
		$rest =~ s/^reset\s*//;  # process stats on reset lines
		&dostatusline($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^select\b/ ) {
		&doselect($line,$rest,$r1,$r2);
	}
	elsif ( $rest =~ /^buy\b/ ||
		$rest =~ /^change\b/ ||
		$rest =~ /^fit\b/ ||
		$rest =~ /^mod\b/ ||
		$rest =~ /^perm\b/ ||
		$rest =~ /^sell\b/ ||
		$rest =~ /^skip\b/ ||
		$rest =~ /^wash\b/ ||
		$rest =~ /^win\b/ ) {
		&dodaynote($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $rest =~ /^licen[sc]e/ ) {
		if ($line =~ /^\s*\d+\s+\+\d+/ ) {
			# for historical reasons, use $r2-1
			&dolicenseline($line,$rest,$r1,$r2-1);
			# at least until we reason it out
		}
		else {
			&dolicenseline($line,$rest,$r1,$r2);
		}
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\-\d+\s+/ ) {
		&doseriesline($line,$rest,$r1,$r2);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\s+\+\d+/ ) {
		# for historical reasons, use $r2-1
		&doseriesline($line,$rest,$r1,$r2-1);
	}
	elsif ( $r1 ne "" && $line =~ /^\s*\d+\s+/ ) {
		&doseriesline($line,$rest,$r1,$r2);
	}
	elsif ( $line =~ /^\s{0,20}\d/ ) {
		&warn("Unrecognized line: $line\n");
	}
	else {
		# Surprisingly, lines beginning "#' will fall through to here
		&donote($line);
	}
}
close ($main::fid);

sub
expand {
	my($s) = @@_;

	$s;
}

if ($main::showlist =~ /,pragmas,/ ) {
	printf("%s\n", $main::pragmas);
}
if ($main::showlist =~ /,rawevents,/ ) {
	my($i);
	for ($i = 0; $i <= $#main::events; ++$i) {
		printf("%s\n", &expand($main::events[$i]) );
	}
}
if ($main::showlist =~ /,events,/ ) {
	my($i,$prev,@@sorted);
	@@sorted = sort @@main::events;
	$prev = "";
	for ($i = 0; $i <= $#sorted; ++$i) {
		if ($sorted[$i] ne $prev) {
			printf("%s\n", &expand($sorted[$i]) );
			$prev = $sorted[$i];
		}
	}
}
if ($main::showlist =~ /,prizes,/ ) {
	my($i,$prev,@@sorted);
	@@sorted = sort @@main::prizes;
	$prev = "";
	for ($i = 0; $i <= $#sorted; ++$i) {
		if ($sorted[$i] ne $prev) {
			printf("%s\n", &expand($sorted[$i]) );
			$prev = $sorted[$i];
		}
	}
}
if ($main::showlist =~ /,carids,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carids) {
		printf("%s %s %s (%s)\n", $k, $main::carids{$k},
			$main::carnames{$k}, $main::carstates{$k});
	}
}
if ($main::showlist =~ /,prices,/ || $main::showlist =~ /,carprices,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carprices) {
		printf("%s %s %s\n", $k, $main::carids{$k},
			$main::carprices{$k});
	}
}

sub
tocredits {  # N.B. money, not attributions/accolades
	my ($num) = @@_;
	my ($portion,$remain);
	my ($sign,$s);

	$sign = "";
	$remain = $num;
	if ($remain < 0) {
		$sign = "-";
		$remain = 0 - $remain;
	}
	$s = "";
	for ( ;; ) {
		$portion = $remain;
		$remain = int ( $remain / 1000);
		$portion -= $remain * 1000;
		if ($remain > 0) {
			$s = sprintf(",%3.3d", $portion) . $s;
		}
		else {
			$s = sprintf("Cr%d", $portion) . $s;
		}
		last if ($remain <= 0);
	}
	return $sign . $s;
}
sub
fromcredits {  # N.B. money, not attributions/accolades
	my ($s) = @@_;
	my ($num);

	$s =~ s/^Cr//i;
	$s =~ s/,//g;
	$num = 0 + $s;
	return $num;
}
	
if ( $main::showlist =~ /,carparts,/ ||
		$main::showlist =~ /,carpartstotals,/ ) {
	my($k,$cark,$car);
	my($prevk,$total,$prevcar);
	$prevk = "";
	$prevcar = "";
	$total = 0;
	foreach $k (sort caridcolonsub keys %main::carparts) {
		$cark = $k;
		$cark =~ s/:.*//;
		$car = $main::carids{$cark};
		$car = "WHAT?" if (!defined($car));
		if ( $cark ne $prevk ) {
			if ($prevk ne "" &&
				   $main::showlist =~ /,carpartstotals,/ ) {
				printf("%s %s:Total %s\n", $prevcar, $prevk,
					&tocredits($total) );
			}
			$prevk = $cark;
			$prevcar = $car;
			$total = 0;
		}
		if ( $main::showlist =~ /,carparts,/ ) {
			printf("%s %s %s\n", $car, $k, $main::carparts{$k});
		}
		$total += &fromcredits($main::carparts{$k});
	}
	if ($prevk ne "" && $main::showlist =~ /,carpartstotals,/ ) {
		printf("%s %s:Total %s\n", $prevcar, $prevk,
			&tocredits($total) );
	}
	
}
if ($main::showlist =~ /,garage,/ ) {
	my($k,$i);
	$i = 0;
	foreach $k (sort caridsub keys %main::carids) {
		if ($main::carstates{$k} ne "sold") {
			printf("%3d %s\n", $i+1, $main::carnames{$k});
			++$i;
		}
	}
}
if ($main::showlist =~ /,licen[sc]e,/ ) {
	my($i,@@sorted);
	@@sorted = sort lidsub keys %main::lresults;
	for ($i = 0; $i <= $#sorted; ++$i) {
		printf("%s: %s\n", $sorted[$i], $main::lresults{$sorted[$i]} );
	}

	
}
if ($main::showlist =~ /,origin,/ ) {
	# Shows origins based on carid
	my($i,@@sorted);
	@@sorted = sort caridsub keys %main::origin;
	for ($i = 0; $i <= $#sorted; ++$i) {
		printf("%s - %s\n", $sorted[$i], $main::origin{$sorted[$i]} );
	}
}
if ($main::showlist =~ /,models,/ ) {
	# Shows models based on carid
	my($i,@@sorted);
	@@sorted = sort caridsub keys %main::carmodels;
	for ($i = 0; $i <= $#sorted; ++$i) {
	      printf("%s - %s\n", $sorted[$i], $main::carmodels{$sorted[$i]} );
	}
}
if ($main::showlist =~ /,carlog,/ ) {
	my($i,@@sorted);
	@@sorted = sort keys %main::carlogs;
	for ($i = 0; $i <= $#sorted; ++$i) {
		my($sf,$ci,$org);
		$sf = $sorted[$i];
		#$ci = $main::carid{$sf};
		$ci = findcarid($sf,"");
		if (defined($ci) && defined($main::origin{$ci}) ) {
			$org = $main::origin{$ci}."\n";
		}
		else {
			$org = "";
		}
		printf("%s:\n", $sf );
		printf("%s", $org );
		printf("%s\n", $main::carlogs{$sorted[$i]} );
	}
}

@


1.77
log
@Arrange to produce output for show=carpartstotals only.

Also arrange for optional "car" on "carparts" and "carpartstotals" to be
handled by effectively changing the option when short form is given.
Also for "carprices".
This could cause us trouble later it we find new places to use the
options...
@
text
@d1780 7
a1786 9
		if ($temp eq "parts") {
			$temp = "car".$temp;
		}
		elsif ($temp eq "partstotals") {
			$temp = "car".$temp;
		}
		elsif ($temp eq "prices") {
			$temp = "car".$temp;
		}
@


1.76
log
@Add show=/,partstotals,/
Somewhat revealing.  GT4 tends to be a lot more costly than GT3.
@
text
@d20 1
d35 1
d37 1
d40 2
a41 1
#   "show=mods" really debugging; shows extracted power and weight mod notes
d43 2
a44 1
#   "show=pragmas"  FWIW
d47 1
a47 1
# Short-term thoughts...
a52 1
#   See diff gt4garage gt4garage-ARRIbeta
a58 1
#      But parts inventory, and perhaps expense, should be possible
d1627 1
a1627 2
		if ($main::showlist =~ /,parts,/ ||
			  $main::showlist =~ /,carparts,/ ||
d1780 9
d2052 2
a2053 1
if ($main::showlist =~ /,parts,/ || $main::showlist =~ /,carparts,/ ) {
d2066 1
a2066 1
					$main::showlist =~ /,partstotals,/ ) {
d2074 3
a2076 1
		printf("%s %s %s\n", $car, $k, $main::carparts{$k});
d2079 1
a2079 2
	if ($prevk ne "" &&
			$main::showlist =~ /,partstotals,/ ) {
@


1.75
log
@Tweaked handling of parentheses in "parts" lines.
@
text
@d2002 39
d2042 5
a2046 1
	my($k,$car);
d2048 3
a2050 3
		$car = $k;
		$car =~ s/:.*//;
		$car = $main::carids{$car};
d2052 10
d2063 6
d2070 1
@


1.74
log
@Improve(?) handling of parenthesized comments in parts lines.
Avoid cases where split returns empty tokens.
@
text
@d1585 4
d1591 2
a1592 2
	$stuff =~ s/^\s+//g;
	$stuff =~ s/\s+$//g;  # sigh.  split will return empty tokens...
@


1.73
log
@Implement "setvar" and use a few instances to ultimately allow
gt4garage to correctly process ARRI-game2
@
text
@d1506 2
d1587 2
d1591 8
a1598 1
		if ($t eq "Cr0") {
a1612 4
		elsif ($t =~ /^\(/ ) {
			# ignore for now
			;
		}
d1614 1
a1614 1
			$t =~ s/\(.*\)//;
@


1.72
log
@Use price for wing or wheels if it was given.
@
text
@d42 7
d61 1
d74 7
d810 2
a811 2
	$main::mintoday = $end + 1;
	$main::maxtoday = $end + 1;
d958 2
a959 2
	$main::mintoday = $end + 1;
	$main::maxtoday = $end + 1;
d1102 16
d1330 7
a1336 1
		&warn("Bad win: $line\n");
d1874 3
@


1.71
log
@Picking away at parts evaluation.
Look for "wheel" and "wing" and treat as a whole line.
But there are still problems.
@
text
@d1535 7
d1543 1
a1543 1
		$main::carparts{$p} = "Cr0";   # should find or choose price
@


1.70
log
@Added the counterpart to the too many prices check.
But it shows there is currently a problem understanding "wheels".
@
text
@d1525 2
a1528 3
	$stuff =~ s/\([^\)]*\)//g;  # till we figure out how to process
	$stuff =~ s/\s+/ /g;
	@@tokens = split(/\s+/,$stuff);
d1534 8
a1541 1
	my($t,$p);
@


1.69
log
@A crude implementation of "show=carparts".
Created caridcolonsub for sorting.
Should indicate parts or mod, and eventually perhaps things which wear.
 
Finds a few mistakes in old logs.
 
We should also indicate for each car the total spent.
Easyish to do.  Hard part is deciding how to format it.
@
text
@d1527 2
d1560 10
@


1.68
log
@Split normalizeparts from doparts.
Cannot remember how to return and assign arrays from functions.
@
text
@d36 1
d146 59
a1519 1
# findcarid is expensive however?
d1521 38
a1558 1

d1924 10
@


1.67
log
@Add and tidy some comments.
Add show=carprices
@
text
@d1303 1
a1303 1
doparts {
a1304 1

d1327 1
d1334 1
d1393 20
a1412 1
print "$op $tok :$stuff\n"  if ($main::showlist =~ /,rawparts,/ );
@


1.66
log
@Comments on "doparts" processing.
Change "+" to spaces.
Remove leading spaces, just in case any end up left.
@
text
@d28 1
a28 1
#     dump stored tables of event/prizes; seem redundant
d34 3
d47 1
d91 1
d94 1
d216 18
d259 1
d1801 7
@


1.65
log
@Finally figured out how we interpret a given carid as a valid car
identifier by looking it up.
Add shortform hash search to findcarid; maybe this is faster?
Document how carlist is an error suppressor.
But that there is no longer any initial "cardata".
@
text
@d1317 1
d1321 1
d1361 1
d1364 1
@


1.64
log
@***** Fix(?) confusion over $carids{} versus $carid{}
***** We should really compare results before and after this change
@
text
@d106 1
d1007 4
d1013 1
a1015 5
	if (defined($main::carids{$carname})) {
		# I think this is just plain wrong...
		# We were lucky we never got any matches?
		return $carname;
	}
d1019 1
d1043 1
@


1.63
log
@Add show=mods
(Really just conditional debugging)
Comment on how we will generate inventory from "buy parts" and "mod" lines.
Segue into discussion of %carids versus %carid
@
text
@d1007 3
d1011 2
@


1.62
log
@Comment about parts "codenames".
@
text
@d234 1
a234 1
	$main::carid{$shortform} = $newid;
d1006 1
d1275 1
d1318 22
d1385 20
@


1.61
log
@Show $op in rawparts
So removed "+1" if it occurred.
Listed observed use of parentheses.
@
text
@d1356 5
@


1.60
log
@Picking away at evaluation of raw parts line.
@
text
@d1287 5
d1325 1
d1331 25
a1355 1
print "$tok :$stuff\n"  if ($main::showlist =~ /,rawparts,/ );
@


1.59
log
@Adding preparation for analysis to turn "buy parts" into an "inventory".
@
text
@d1301 2
a1302 2
	while ($stuff =~ /,Cr/i ) {
		$stuff =~ s/,Cr/ Cr/ig;
d1311 11
d1323 2
@


1.58
log
@Add show=models
My idea is carmodels hash might later be used for parts checking.  Maybe.
@
text
@d68 1
a68 1
@@main::cardata = ();   # now we initialize all data via "mod car" in the log
d111 1
a111 1
lidsub() {  # sort B1..A1..IB1..IA1..S1..S16
d1269 48
d1348 1
d1351 1
d1382 1
@


1.57
log
@Crucial changes to allow log author to make "sell" work in cases
where the car name contains pattern characters (specifically "()")
@
text
@d84 8
d236 16
d1648 8
@


1.56
log
@Add comments indicating what this program does.
Also indicate its options.
And also suggest future possibilities for what this program might do,
although the marginal utility of new features is decreasing.
@
text
@d323 2
d331 1
a331 1
		print "${main::maxtoday}:$match ($what) sold!\n";
@


1.55
log
@Use record_race_prize.
@
text
@d3 50
@


1.54
log
@Modularize record_race_prize
Perhaps fix a bug, perhaps change a specification.
 
Modularize race_to_set which currently has a kludge for GT4 SC events.
@
text
@d748 1
a748 1
	my ($r,$s) = @@_;
d756 2
d1158 5
a1162 1
			if (defined($main::prize_event) && $main::prize_event ne "") {
d1164 5
a1168 5
				if ($event eq "") {
					$e = race_to_set($e);
					$fullname =~ s/$/ (prize,$e)/;
					# push event info here...
				}
d1178 1
@


1.53
log
@Make the kludge perhaps a little more justifiably general.
@
text
@d747 14
d855 1
a855 12
	if ($prize !~ /credits/ && &otherprize($prize) == 0) {
		$temp = $prize;
		$temp =~ s/\(sold\)//;
		$temp =~ s/\(dup\)//;
		push @@main::prizes,"${race}: $prize";
	}
	$temp = $prize;
	$temp =~ s/\(sold\)//;
	$temp =~ s/\(dup\)//;
	if ($prize !~ /credits/ && &otherprize($temp) == 0) {
		push @@main::events,"${race}: $temp";
	}
d1087 23
d1159 1
a1159 13
					# A prize is for the set, not the race
					# Perhaps this depends on pragma
					# Or perhaps we need "prizeevent" defns
					if ($e !~ m:/(Easy|Normal|Hard)/: ) { # ugh!
						while ($e =~ m:/.*/: ) {
							$e =~ s:/[^/]*$:: ;
						}
					}
					else {  # and ugh!
						$e =~ s/R$//;
						$e =~ s/ii$//;
					}
					# Is space in the following correct?
d1161 1
@


1.52
log
@Kludge, at least for now, to avoid saying only "SC/Easy" set for
GT4 SC (special conditions) events.
@
text
@d1135 2
a1136 1
					if ($e !~ m:^SC/: ) { # ugh!
@


1.51
log
@Try to sell both literal garage entry, and entry without (prize,P/Sunday)
Actually seemed to work.

Raises the question of whether our sales methods are reasonable.
@
text
@d1135 8
a1142 2
					while ($e =~ m:/.*/: ) {
						$e =~ s:/[^/]*$:: ;
@


1.50
log
@*** BAd version*** half-implemented garage prize annotation.
Seems to have broken lots of old "sell" and then "select".
@
text
@d326 1
a326 1
	my($i,$what,$temp);
d339 5
a343 1
		if ($temp eq "$car" && $main::carstates{$ix} ne "sold") {
d412 3
@


1.49
log
@Move the growing "win" processing into a subroutine for modularity.
@
text
@d1083 1
d1085 4
a1088 2
	if ($rest =~ /^win\s+(.*)/ && defined($1)) {
		$stuff = $1;
d1090 17
a1106 2
		if ($main::selected ne "") {
			addcarlog($main::selected,$line);
d1108 25
a1132 12
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
$main::prize_event = "";
			$sf = $1;
			if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
				$fullname = $2;
				$fullname =~ s/^[^\w\[]*//;
				$fullname =~ s/->\s.*//;
				$fullname =~ s/\s*$//;
				$fullname =~ s/^\s*//;
				getcar($sf,$fullname,$line);
				if ($main::showlist =~ /,buy,/i) {
					print "${main::maxtoday}:win $sf - $fullname.\n";
d1135 4
a1138 2
			else {
				getcar($sf,$sf,$line);
d1142 8
a1149 1
			&warn("Bad win: $line\n");
d1151 1
@


1.48
log
@Half-implemented recognition of "next" followed by +1 win prizes.
@
text
@d1078 38
d1156 1
a1156 26
		$stuff = $1;
#print "stuff:$stuff\n";
		if ($main::selected ne "") {
			addcarlog($main::selected,$line);
		}
		if ($stuff =~ /^\s*car\s+(\S+)/ && defined($1) ) {
$main::prize_event = "";
			$sf = $1;
			if ($stuff =~ /^\s*car\s+(\S+)\s+(.+)/ && defined($2) ) {
				$fullname = $2;
				$fullname =~ s/^[^\w\[]*//;
				$fullname =~ s/->\s.*//;
				$fullname =~ s/\s*$//;
				$fullname =~ s/^\s*//;
				getcar($sf,$fullname,$line);
				if ($main::showlist =~ /,buy,/i) {
					print "${main::maxtoday}:win $sf - $fullname.\n";
				}
			}
			else {
				getcar($sf,$sf,$line);
			}
		}
		else {
			&warn("Bad win: $line\n");
		}
@


1.47
log
@Last change also added oil changes to carlog,verbose,
But it included a spurious removal of newlines, which I have undone.
@
text
@d21 1
d688 2
d692 1
a692 1
	return 1 if ($prize eq "next");
d769 1
a769 1
		&warn("Unrecognized race: $event\n");
d828 6
d843 3
a845 1
	push @@main::events,"${race}: $prize";
d1124 1
@


1.46
log
@Add datelines to carlog.
@
text
@d1188 3
a1190 1
			close($main::fid); $n = $main::fid; $n =~ s/LOG//;
@


1.45
log
@Add verbose carlog to include comments (notes) and status lines.
Tweak the handling of "select car none" to allow us to avoid logging
things to a particular carlog.
@
text
@d523 5
d1133 14
d1188 1
a1188 3
			close($main::fid);
			$n = $main::fid;
			$n =~ s/LOG//;
d1203 1
d1214 3
@


1.44
log
@Note that '#' lines work, semi-accidentally.
@
text
@d551 5
a555 1
			$main::selected = "";
d1014 3
d1154 3
d1191 3
d1197 3
a1199 1
	$main::carlogs{$car} .= $line."\n";
@


1.43
log
@Throwing gt1 and gt2 logs against this found a few failed assertions
of sorts.
@
text
@d1356 1
@


1.42
log
@Usually use the first applicable cardef.
There is a problem when an explicit cardef occurs after the
appropriate one for acquisition.

Log prizes won to the currently selected car.
A problem is that we leave selection selected when doing missions.
@
text
@d31 1
d150 15
d176 1
d280 1
d290 1
d311 1
d316 1
d341 1
d353 1
d363 1
d379 1
d500 1
d709 6
a714 3
	$event =~ /([^\/]*)\/(.*)/;
	($league,$series) = ($1,$2);
	return 0 if !defined($main::league{$league});
d749 7
a755 2
	$rest =~ /(\S+)\s+(\S+)\s+(.*)/;
	($car,$event,$after) = ($1,$2,$3);
d1040 9
d1452 1
@


1.41
log
@Discovered I already had findcarid routine.
But there is a problem that really you want to evaluate each
carid at the game day it is selected, not afterwards.
That is not very easy.
 
But, for instance, if you do
./gt4garage show=carlog gt4-game1 500
by limiting days evaluated to 500, you avoid some ambiguities.
@
text
@d878 2
a879 1
				# should we warn here?
d881 3
a883 1
				return undef;
d1054 3
@


1.40
log
@Arranged to indicate origin of most cars, but a few don't get any.
Also I seem to have a bad habit of re-using the shortform, thereby
overwriting and earlier one with a later one.  E.g. the result
shows car obtained after being used.
@
text
@d154 1
a154 1
	$main::carids{$newid} = $shortform;
d1390 2
a1391 1
		$ci = $main::carid{$sf};
@


1.39
log
@Working towards showing the car origin in carlog.
Can now show the log line which is the origin of each carid.
@
text
@d29 2
d159 1
d1388 12
a1399 1
		printf("%s:\n%s\n", $sorted[$i], $main::carlogs{$sorted[$i]} );
@


1.38
log
@Add short form to "buy" (actually acquisition) output.
@
text
@d76 1
a76 1
caridsub() {
d81 1
d83 1
d94 1
d96 1
d148 1
a148 1
	my($shortform,$fullname) = @@_;
d156 1
d791 1
a791 1
			getcar($prize,"$prize(prize, $race)");
d1025 1
a1025 1
				&getcar($sf,$fullname);
d1031 1
a1031 1
				&getcar($sf,$sf);
d1056 1
a1056 1
				getcar($sf,$fullname);
d1062 1
a1062 1
				getcar($sf,$sf);
d1372 8
@


1.37
log
@Sudden inspiration to add show=carlog
Works well except it doesn't show the origins of the car.
Seems to suggest I only used at most 162 of my 538 cars.

Works for GT3, too.  (51 of 149 were used)
@
text
@d1022 1
a1022 1
					print "${main::maxtoday}:buy $fullname.\n";
d1053 1
a1053 1
					print "${main::maxtoday}:win $fullname.\n";
@


1.36
log
@Changes to hopefully allow lines like...
 135 power off Cr429,209   1.0%   1015A 0B   Slicense  0G 3S 77B  28cars
Also changes to allow
 2547     license S-16 S Nurb   7:20.233S  (many tries)  +12.533G
I.e. hyphens in license test names.
@
text
@d522 1
d727 1
a727 1
	
d1031 1
d1070 1
d1119 12
d1367 7
@


1.35
log
@Added indicator of how to reset $1
@
text
@d569 1
a569 1
	my($line,$start,$end) = @@_;
d586 2
a587 2
	$lid = $line;   # Note, line includes the day number
	$lid =~ s/\s*\d+\s+//;  # Remove day number
d589 1
d596 2
a597 1
	elsif ($lid !~ /^[I]{0,1}[BAS][\d]{1,2}$/ || $lid =~ /IS/) {
d601 3
a603 2
		$medal = $line;
		$medal =~ s/\s*\d+\s+//;  # Remove day number
d605 2
a606 1
		$medal =~ s/^I{0,1}[BAS]\d+(\([^ ]*){0,1}\s+//;  # Remove $lid; we allow IS!
d1237 9
a1253 2
		$rest =~ /^power\b/ ||
		$rest =~ /^reset\b/ ||
d1263 1
a1263 1
			&dolicenseline($line,$r1,$r2-1);
d1267 1
a1267 1
			&dolicenseline($line,$r1,$r2);
@


1.34
log
@Added some use of "pragmas" to make this still work
(i.e. not complain incorrectly, but do less checking) for GT3.
In gt3-game1 we did lots of "   power off  CrNNN ..."
@
text
@d956 1
@


1.33
log
@Did a crude comparison of log license results to compiled license results.
@
text
@d581 5
a631 2
	$main::mintoday = $end + 1;
	$main::maxtoday = $end + 1;
d959 3
a961 1
	if ( $rest =~ m:([0-9]{1,2}[GB][ /]{1,3}[0-9]{1,2}[S][ /]{1,3}[0-9]{1,2}[GB]): ) {
@


1.32
log
@Flag "license G B1" as an error; don't interpret as "test G<null>".
Indicate "handle coffee later".
Fix status line day error message.
 
Indicate what's needed to flag errors in license medal totals.
Not sure best way to do it.
@
text
@d969 7
d977 5
a981 1
			printf "%s %s - %s\n", $r1, $licstats, $s;
@


1.31
log
@Trying to audit license results.
@
text
@d54 2
d64 2
d587 7
a593 1
	if ($lid !~ /coffee/) {
d949 1
a949 1
		&warn("Bad single day note(not ${main::maxtoday}): $_\n");
d968 1
@


1.30
log
@Switch "Cr" lines from no-op "dodaynote" to future "dostatusline".
In particular, we want to check 3G 19S 68ÂB.  Perhaps car count also.
@
text
@d524 15
d945 17
@


1.29
log
@Detailed improvement(?) to allow e.g. IA15(!)
@
text
@d919 17
d1167 1
d1171 1
a1171 1
		&dodaynote($line,$rest,$r1,$r2);
@


1.28
log
@Remove debugging statements.
Add warning about hard-to-parse license results if in license mode.
@
text
@d572 1
a572 1
		$medal =~ s/^I{0,1}[BAS]\d+\s+//;  # Remove $lid; we allow IS!
@


1.27
log
@Added ,license, show keyword
Wasted/used lots of time discovering limitations on use of \b
in pattern matching.  But finally I think I'm at the point where
I should change my old log to clarify a couple of ambiguities
or data errors.
@
text
@d577 1
d579 3
a581 1
print "S14 medal=$medal\n" if ($lid eq "S14");
d589 1
a589 1
print "S14 medal=$medal\n" if ($lid eq "S14");
d598 1
a598 1
print "S14 medal=$medal\n" if ($lid eq "S14");
@


1.26
log
@I think we are tracking medal results.
@
text
@d49 23
d530 1
d554 1
a554 1
#&warn("Good license line:$_\n");
d562 3
a564 2
	$lid = $line;
	$lid =~ s/^licen[^ ]*\s+//;
d567 1
d570 1
d572 24
a595 4
		$medal =~ s/^[^ ]+\s+//;
		$medal =~ s/^[^ ]+@@[^ ]+//;   # FordGT@@Seattle
		$medal =~ /^[0-9\s]([FBSG])/; # 1st medal letter
		$medal = $1;
a597 1

d1253 7
@


1.25
log
@/xhbin/perl5 => /usr/bin/perl
@
text
@d501 22
d528 1
d538 15
d1205 2
@


1.24
log
@Changed embarrassing date assumptions.
@
text
@d1 1
a1 1
#!/xhbin/perl5 -w
@


1.23
log
@Fix uncardef so that it actually works.
Needed to add omitted anchors for keyword matches.
@
text
@d456 1
a456 1
	if ($line !~ /1999$/ && $line !~ /200[0-9]$/) {
@


1.22
log
@Implement select (at least partially).
@
text
@d716 1
a716 1
	$line =~ /^\s*uncardef\s+(\w+)/;
d724 4
a727 3
	if (!defined($main::carlist{$what})) {
		delete($main::carlist{$what});
	}
d1040 1
a1040 1
	if ( $line =~ /\s*note/i ) {
d1043 1
a1043 1
	elsif ( $line =~ /\s*pragma/i ) {
d1046 1
a1046 1
	elsif ( $line =~ /\s*include/i ) {
d1049 1
a1049 1
	elsif ( $line =~ /\s*define/i ) {
d1055 1
a1055 1
	elsif ( $line =~ /\s*cardef/i ) {
d1058 1
a1058 1
	elsif ( $line =~ /\s*uncardef/i ) {
@


1.21
log
@Don't refuse a carname because of sold versions.
@
text
@d15 1
d81 15
d485 18
d606 1
a606 1
		findcarid($car,$line);
d859 2
a860 2
		elsif ($stuff =~ /^\s*parts\s+/) {
			;
d898 1
a898 1
			findcarid($1,$line);
d1066 3
@


1.20
log
@Implemented cardef and uncardef, and arranged to use carid concept.
@
text
@d709 2
a710 1
		if ($main::carids{$k} eq $carname) {
@


1.19
log
@Rearranged verbose (optional) output a bit.
Implemented "sell carid".
@
text
@d27 2
a556 7
	#$rest = $line;
	#if ($rest =~ /^\s*(\d+)-(\d+)\s*/ ) {
	#	$rest =~ s/^\s*(\d+)-(\d+)\s*//;
	#}
	#else {
	#	$rest =~ s/^\s*(\d+)\s*//;
	#}
a557 1
# print "$rest\n";
d572 2
a573 4
		if (!defined($main::carlist{$car}) ) {
			&warn("Unrecognized car ($car): $line\n");
			$main::carlist{$car} = $car;
		}
d649 83
d863 1
a863 1
			$main::carlist{$1} = $1;
d1018 6
@


1.18
log
@Rewrote sellentry routine.
And that allowed me to remove $main::garage entirely!
Should be much simpler now, although I could do with some routines
(e.g. marksold, etc.)
@
text
@d189 24
d233 1
a233 1
			print "${main::maxtoday}:$car ($temp) sold!\n";
d243 1
a243 3
	# this does not work
	my($car,$oldest) = @@_;
	my($ix,@@list);
d245 1
a245 11
	@@list = sort caridsub keys %main::carids;
	if ($oldest) {
		@@list = reverse @@list;
	}
	foreach $ix (@@list) {
		if ($main::carids{$ix} eq $car) {
			if (!defined($main::carstates{$ix}) ) {
				$main::carstates{$ix} = "sold";
			}
		}
	}
d343 5
d875 1
a875 1
$main::showlist =~ s/all/,buy,sell,sales,sold,garage,/;
d1000 3
d1031 7
a1046 10
}
if ($main::showlist =~ /,carids,/ ) {
	my($k);
	foreach $k (sort caridsub keys %main::carids) {
		printf("%s %s %s (%s)\n", $k, $main::carids{$k},
			$main::carnames{$k}, $main::carstates{$k});
	}
}
if ($main::showlist =~ /,pragmas,/ ) {
	printf("%s\n", $main::pragmas);
@


1.17
log
@I think the "sell excess" stuff is working, although it's too finicky to
be useful.
@
text
@a17 1
@@main::garage = ();
d191 1
a191 1
	my($i,$what,$temp);
d193 1
a193 1
	$i = $num - 1;
d195 11
a205 3
	$temp = $main::garage[$i];
	if ($temp =~ /$car/ ) {
		($what) = splice @@main::garage,$i,1;
a622 1
			push @@main::garage,"$prize(prize, $race)";
a726 1
				push @@main::garage,$fullname;
a756 1
				push @@main::garage,$fullname;
@


1.16
log
@Reimplements garage as evaluation of carnames and carstates, working
for at least simple sale cases, anyway.
carvariants, etc. need rewriting now.
@
text
@d124 5
a128 2
	for ($i = $#main::garage; $i >= 0; --$i) {
		if ($main::garage[$i] =~ /\(prize\)/ ) {
d130 5
a134 4
			if ( $main::garage[$i] =~ /$car/i ||
					$main::garage[$i] =~ /$car1/i ||
					$main::garage[$i] =~ /$car2/i ) {
				$hash{$main::garage[$i]} = 1;
d151 1
d157 4
a160 2
		for ($i = $#main::garage; $i >= 0; --$i) {
			if ($main::garage[$i] eq $car ) {
d171 4
a174 2
		for ($i = $#main::garage; $i >= 0; --$i) {
			if ($main::garage[$i] =~ /\(prize\)/ ) {
d176 3
a178 3
				if ( $main::garage[$i] =~ /$car/i ||
						$main::garage[$i] =~ /$car1/i ||
						$main::garage[$i] =~ /$car2/i ) {
d382 1
a382 1
#print "Sell  - $n $var.\n";
d466 1
d724 1
a724 1
				&getcar($sf,"");
d755 1
a755 1
				getcar($sf,"");
@


1.15
log
@Kludges to handle the fact that series and license lines used to
default to increment of one (still do) but you want to be able to say
+N where N is the number of races in a series.
Perhaps we will want to use a pragme.
@
text
@d224 1
a224 1
	my($ix);
d230 4
a233 3
	for ($i = $#main::garage; $i >= 0; --$i) {
		$ix = $oldest ? ($#main::garage - $i) : $i;
		$temp = $main::garage[$ix];
d236 3
a238 2
		if ($temp eq "$car") {
			($what) = splice @@main::garage,$ix,1;
d242 2
a243 1
	for ($i = $#main::garage; $i >= 0; --$i) {
a245 2
		$ix = $oldest ? ($#main::garage - $i) : $i;
		$temp = $main::garage[$ix];
d247 3
a249 2
		if ($temp eq "$car") {
			($what) = splice @@main::garage,$ix,1;
d253 6
a258 5
	for ($i = $#main::garage; $i >= 0; --$i) {
		$ix = $oldest ? ($#main::garage - $i) : $i;
		if ($main::garage[$ix] =~ /\(prize/ &&
					$main::garage[$ix] =~ /$car/i ) {
			($what) = splice @@main::garage,$ix,1;
d268 6
a273 5
	for ($i = $#main::garage; $i >= 0; --$i) {
		$ix = $oldest ? ($#main::garage - $i) : $i;
		if ($main::garage[$ix] =~ /\(prize/ &&
					$main::garage[$ix] =~ /$car/i ) {
			($what) = splice @@main::garage,$ix,1;
d607 1
a607 1
			getcar($prize,$prize);
d998 7
a1004 3
	my($i);
	for ($i = 0; $i <= $#main::garage; ++$i) {
		printf("%3d %s\n", $i+1, $main::garage[$i]);
@


1.14
log
@Changed needed to actually make NNN +N type lines work.
@
text
@a912 3
	elsif ( $r1 ne "" && $rest =~ /^licen[sc]e/ ) {
		&dolicenseline($line,$r1,$r2);
	}
d929 11
a939 1
	elsif ( $r1 ne "" && $line =~ /\s+\d+\-\d+\s+/ ) {
d942 5
a946 1
	elsif ( $r1 ne "" && $line =~ /\s+\d+\s+/ ) {
@


1.13
log
@Simplify(?) dodaynote, adding capability for a day range.
Add "skip" keyword which will be useful for gradually creating logs.
@
text
@d498 1
a498 1
	my($line,$start,$end) = @@_;
d500 1
a500 1
	my($rest,$i,$none,$pat,$race,$event,$length,$suff,$prev,$after);
d517 7
a523 7
	$rest = $line;
	if ($rest =~ /^\s*(\d+)-(\d+)\s*/ ) {
		$rest =~ s/^\s*(\d+)-(\d+)\s*//;
	}
	else {
		$rest =~ s/^\s*(\d+)\s*//;
	}
d933 1
a933 1
		&doseriesline($line,$r1,$r2);
d936 1
a936 1
		&doseriesline($line,$r1,$r2);
@


1.12
log
@Added support for "pragmas".
@
text
@d685 1
a685 1
	my($line) = @@_;
d688 1
a688 6
	$line =~ /^\s*(\d+)/;
if ( !defined($1) ) {
print $line,"\n";
}
	$day = $1;
	if (!&daycheck($day) ) {
a690 2
	$main::mintoday = $day;
	$main::maxtoday = $day;
d692 2
a693 2
	if ($line =~ /^\s*(\d+)\s+buy\s+(.*)/ && defined($2)) {
		$stuff = $2;
d723 2
a724 2
	if ($line =~ /^\s*(\d+)\s+win\s+(.*)/ && defined($2)) {
		$stuff = $2;
d748 2
a749 2
	if ($line =~ /^\s*(\d+)\s+mod\s+(.*)/ && defined($2)) {
		$stuff = $2;
d759 2
a760 2
	if ($line =~ /^\s*(\d+)\s+sell\s+(.*)/ && defined($2)) {
		$stuff = $2;
d764 3
d917 1
a917 1
		&dodaynote($line);
d927 1
d930 1
a930 1
		&dodaynote($line);
@


1.11
log
@Minor tweaks.
Corrected pattern for series/event check.
Attempted to add selling via carids hash, but haven't got yet.
Old "selling" was just too kludgey.
@
text
@d15 1
d410 20
d901 3
d997 3
@


1.10
log
@New syntax for "define series" requires a League to be specified.
Options series length is now processed.
With a different set of event definitions, this still works for GT3.
@
text
@d201 19
d612 1
a612 1
	   if ($value !~ /(\w+)\/(\w+)/) {
d970 2
a971 1
		printf("%s %s %s\n", $k, $main::carids{$k}, $main::carnames{$k});
@


1.9
log
@Allow definable series length.
@
text
@d447 1
a447 1
		return 0 if !defined($main::series{$series});
d451 1
a451 1
		return 0 if !defined($main::series{$series});
d582 1
a582 1
	my($what,$value,$length);
d592 11
@


1.8
log
@Still compatible with GT3.
Recognizes daynotes before series lines.
(Specific keywords must not match carnames).
Do more flexible processing of serieslines.
Will this allow
   609 +1 buy wing Cien'02 3DtypeDS
Do we need to check for erroneous day increments?
Probably not, running day check should catch it.
@
text
@d23 2
d427 10
d469 2
d472 1
a472 1
	if ( $diff < 0 || 6 < $diff) {
a484 1
	$length = 0;
d494 1
d582 1
a582 1
	my($what,$value);
d593 8
a600 1
		# would be nice to record # of days for other games (GT1)
@


1.7
log
@Comments.
Prepare to recognize new "increment" series line.
Remove old "do1dayline" call.
@
text
@a554 12
do1dayline {
	my($line,$day) = @@_;

	&warn("Unknown single day event: $_\n");
	if (!&daycheck($day) ) {
		&warn("Bad single day event(not ${main::maxtoday}): $_\n");
	}
	$main::mintoday = $day;
	$main::maxtoday = $day + 1;
}

sub
d818 2
a819 2
	elsif ( $line =~ /^([ \d]{3,3}\d)[ ]{6,6}(.*)/ ) {
		# single day (numbers max 4 digits)
a821 1
		$r1 =~ s/\s//g;
d848 13
a860 1
	elsif ( $line =~ /^[ \d]{3,3}\d-\d[ \d]{3,3}/ ) {
d863 1
a863 2
	elsif ( $line =~ /^[ \d]{3,3}\d[ ]{5,5}/ ) {
		# series used to be indicated by extra spaces
a864 3
	}
	elsif ( $line =~ /^[ ]{0,3}\d{1,5}/ ) {
		&dodaynote($line);
@


1.6
log
@Maintain and print fullnames by carids.
@
text
@d811 4
d816 1
d823 7
d831 1
d852 1
a860 4
	elsif ( $r1 ne "" &&
		( $license =~ /^[AB][1-8]/ || $license =~ /^IA[1-8]/ ) ) {
		&dolicenseline($line,$r1,$r2);
	}
d865 1
a866 4
	}
	elsif ( $line =~ /^[ \d]{4,4}\d[ ]{6,6}/ ) {
		# this should not occur any more;  all licenses
		&do1dayline($line,$r1,$r2);
@


1.5
log
@Now computes carids, and can sort by them.
============== Still works for GT3 ==========================
(Does not diverge yet).
@
text
@d97 1
a97 1
	my($fullname) = @@_;
d101 2
a102 1
	$main::carids{$newid} = $fullname;
d104 1
a104 1
	$main::carlist{$fullname} = $fullname;
d549 1
a549 1
			getcar($prize);
d626 1
a626 1
	my($day,$stuff,$fullname);
d643 1
a643 1
			&getcar($1);
d650 1
d656 3
d674 1
a674 1
			getcar($1);
d681 1
d687 3
d917 1
a917 1
		printf("%s %s\n", $k, $main::carids{$k});
@


1.4
log
@Define "getcar" routine, and just about got "carid" notion into the log.
@
text
@d43 34
@


1.3
log
@Tweaked "include" to syntax check and work.
Tested 13 deep (simple).
@
text
@d43 29
d514 1
a514 1
			$main::carlist{$prize} = $prize;
d608 1
a608 1
			$main::carlist{$1} = $1;
d635 1
a635 1
			$main::carlist{$1} = $1;
d655 1
d677 1
a677 1
getlog {
d869 6
@


1.2
log
@Includes probably working?
@
text
@d541 1
d545 2
a546 1
	$line =~ /^\s*include\s+([\/\w+])/;
d551 2
a552 1
	$main::fid = 'LOG' . $n;
d554 1
a554 1
		&warn("Cannot open include $filename.\n");
d663 1
a663 1
			$main::fid = 'LOG' . $n;
@


1.1
log
@Initial revision
@
text
@d537 19
d643 25
d710 5
a714 2
if (!open(LOG,"<$log")) {
	die "Cannot open log $log.\n";
d719 1
a719 1
while (<LOG>) {
d753 3
d795 1
a795 1
close (LOG);
@
